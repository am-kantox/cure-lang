module DependentTypes do
  export [demo_all/0]

  # Import standard types
  import Std [List, Result]
  import Std.Vector [zip_with/3, fold/3]
  
  # === LENGTH-INDEXED VECTORS ===

  # Vector type parameterized by length and element type
  # Vector(T, n: Nat) ensures vectors always have exactly n elements

  # Create vectors with known lengths
  def make_vec3(x: Float, y: Float, z: Float): Vector(Float, 3) =
    [x, y, z]

  def make_vec4(x: Float, y: Float, z: Float, w: Float): Vector(Float, 4) =
    [x, y, z, w]

  # def vec_len(vec: Vector(Float, n)): Int = n

  # Safe vector operations - length checked at compile time
  def dot_product(v1: Vector(Float, n), v2: Vector(Float, n)): Float =
    # The type system guarantees v1 and v2 have the same length
    let products = zip_with(v1, v2, fn(x, y) -> x * y end)
    fold(products, 0.0, fn(x, acc) -> acc + x end)

  # === DEMONSTRATION FUNCTIONS ===

  def vector_operations(): Unit =
    print("\n=== Vector Operations ===\n")
    
    let v1 = make_vec3(1.0, 2.0, 3.0)
    let v2 = make_vec3(4.0, 5.0, 6.0)
    
    let dot_result = dot_product(v1, v2)
    print("Dot product: " ++ show(dot_result))  # 32.0

    # let vec3_len = vec_len(v1)
    # print("Vector length: " ++ show(vec3_len))
    
    ok

  def demo_all(): Unit =
    print("=== Dependent Types Demonstration ===\n")
    
    # Demonstrate compile-time safety
    print("All operations below are compile-time verified for safety!\n")
    
    vector_operations()

    ok

end
