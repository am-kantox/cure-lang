%% Refinement Types Example
%% Demonstrates the use of refinement types with when clauses for compile-time verification

module RefinementTypes

%% Basic refinement types that constrain integer values
type Positive = Int when x > 0
type NonZero = Int when x /= 0
type Percentage = Int when x >= 0 and x =< 100
type Even = Int when x % 2 == 0

%% Divide function that requires non-zero divisor
%% The type system ensures we can't pass zero as the divisor
def safe_divide(a: Int, b: NonZero): Int =
    a / b

%% Absolute value always returns a positive or zero result
def absolute(n: Int): Nat =
    if n < 0 then -n else n end

%% Function that requires positive input
def sqrt_positive(n: Positive): Float =
    math.sqrt(n)

%% Function that works with percentages
def apply_discount(price: Int, discount: Percentage): Int =
    price - (price * discount / 100)

%% Demonstrate subtyping: Positive <: NonZero
%% This function accepts NonZero, but we can pass Positive values
def reciprocal(n: NonZero): Float =
    1.0 / n

%% Example usage (commented out as this is just a demonstration)
%% def main() =
%%     let x: Positive = 42 in            % OK: 42 > 0
%%     let y: NonZero = 10 in              % OK: 10 /= 0
%%     let z: Percentage = 15 in           % OK: 0 <= 15 <= 100
%%     
%%     let result1 = safe_divide(100, y) in
%%     let result2 = sqrt_positive(x) in
%%     let result3 = apply_discount(100, z) in
%%     let result4 = reciprocal(x) in      % OK: Positive <: NonZero
%%     
%%     %% These would be caught at compile time:
%%     %% let bad1 = safe_divide(100, 0) in        % ERROR: 0 is not NonZero
%%     %% let bad2: Positive = 0 in                 % ERROR: 0 is not positive
%%     %% let bad3: Percentage = 150 in             % ERROR: 150 > 100
%%     
%%     result1
%%     end

%% Advanced example: combining multiple constraints
type PositiveEven = Int when x > 0 and x % 2 == 0

def process_positive_even(n: PositiveEven): Int =
    n / 2  % Safe because n is always even and positive
