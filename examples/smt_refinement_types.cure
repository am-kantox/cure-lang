%% Cure Language - Refinement Types with Z3 SMT Verification
%% This file demonstrates refinement types that are verified at compile-time
%% using the Z3 SMT solver.

module RefinementTypes

%% ============================================================================
%% Basic Refinement Types
%% ============================================================================

%% Positive integers - proven > 0 by SMT
type Positive = Int when x > 0

%% Non-zero integers - for safe division
type NonZero = Int when x /= 0

%% Natural numbers in a specific range
type Percentage = Int when x >= 0 and x =< 100

%% Even numbers
type Even = Int when x % 2 == 0

%% Odd numbers  
type Odd = Int when x % 2 == 1

%% ============================================================================
%% Safe Division - Refinement Types Prevent Division by Zero
%% ============================================================================

%% Safe division - divisor proven non-zero by type system
def safe_div(dividend: Int, divisor: NonZero) -> Int do
  %% Z3 proves: divisor /= 0, so this division is safe
  dividend / divisor
end

%% Using safe_div with a Positive number
%% Z3 proves: Positive <: NonZero (subtyping via implication)
def example_safe_div() -> Int do
  let x: Positive = 10 in
  safe_div(100, x)  %% Type checker proves x is NonZero using SMT
end

%% ============================================================================
%% Range-Constrained Functions
%% ============================================================================

%% Set volume - only accepts valid percentages
def set_volume(level: Percentage) -> String do
  %% Z3 proves: 0 <= level <= 100
  if level == 0 then
    "Muted"
  else if level < 50 then
    "Quiet"
  else if level < 80 then
    "Medium"
  else
    "Loud"
  end
end

%% Invalid calls are caught at compile time:
%% set_volume(-5)  %% ❌ Compile error: -5 does not satisfy x >= 0
%% set_volume(150) %% ❌ Compile error: 150 does not satisfy x <= 100

%% ============================================================================
%% Dependent Refinements - Constraints Depend on Other Values
%% ============================================================================

%% A positive number must be less than a maximum
type Bounded(max: Int) = Int when x > 0 and x < max

%% Age must be reasonable
type Age = Int when x >= 0 and x =< 150

%% Temperature in Celsius (reasonable range)
type Temperature = Int when x >= -273 and x =< 1000

%% ============================================================================
%% Refinement Type Arithmetic
%% ============================================================================

%% Adding two positive numbers yields a positive number
%% Z3 proves: (x > 0) and (y > 0) => (x + y > 0)
def add_positive(x: Positive, y: Positive) -> Positive do
  x + y  %% Result automatically proven Positive by SMT
end

%% Multiplying two odd numbers yields an odd number
%% Z3 proves: (x % 2 == 1) and (y % 2 == 1) => ((x * y) % 2 == 1)
def multiply_odd(x: Odd, y: Odd) -> Odd do
  x * y  %% Result proven Odd by SMT
end

%% ============================================================================
%% Array Bounds Checking with Dependent Types
%% ============================================================================

%% Safe array index - index must be non-negative and less than length
def safe_get(arr: List(T), index: Int) -> Option(T) when index >= 0 do
  if index < length(arr) then
    Some(arr[index])  %% Z3 proves: 0 <= index < length, so access is safe
  else
    None
  end
end

%% Safe head - requires non-empty list
def safe_head(xs: List(T)) -> T when length(xs) > 0 do
  xs[0]  %% Z3 proves: length > 0, so xs[0] exists
end

%% Safe tail - requires non-empty list
def safe_tail(xs: List(T)) -> List(T) when length(xs) > 0 do
  drop(xs, 1)
end

%% ============================================================================
%% Financial Calculations with Precise Constraints
%% ============================================================================

%% Money amount - must be non-negative
type Money = Int when x >= 0

%% Interest rate - between 0% and 100%
type InterestRate = Int when x >= 0 and x =< 100

%% Calculate compound interest
def compound_interest(
  principal: Money,
  rate: InterestRate,
  years: Positive
) -> Money do
  %% Z3 proves all inputs are in valid ranges
  let rate_decimal = rate / 100 in
  let multiplier = 1 + rate_decimal in
  principal * power(multiplier, years)
end

%% ============================================================================
%% Temperature Conversions with Range Verification
%% ============================================================================

%% Celsius to Fahrenheit - preserves reasonable range
def celsius_to_fahrenheit(c: Temperature) -> Int do
  %% Z3 verifies: if -273 <= c <= 1000, then result is in valid range
  (c * 9 / 5) + 32
end

%% ============================================================================
%% RGB Color Components - Byte Range
%% ============================================================================

type ColorComponent = Int when x >= 0 and x =< 255

def make_rgb(r: ColorComponent, g: ColorComponent, b: ColorComponent) -> Int do
  %% Z3 proves: all components in valid byte range
  (r * 65536) + (g * 256) + b
end

%% ============================================================================
%% Refinement Subtyping Examples
%% ============================================================================

%% Z3 proves these subtyping relationships:
%% - Positive <: NonZero (every positive is non-zero)
%% - Even <: Int (every even number is an integer)
%% - Percentage <: NonZero (except 0, which is edge case)

def use_nonzero(x: NonZero) -> Int do
  100 / x
end

def test_subtyping() -> Int do
  let pos: Positive = 5 in
  use_nonzero(pos)  %% ✅ Z3 proves: Positive <: NonZero
end

%% ============================================================================
%% Guard Verification with SMT
%% ============================================================================

%% Pattern matching with refinement constraints
def classify_number(x: Int) -> String do
  match x do
    | n when n > 0 and n % 2 == 0 -> "Positive Even"
    | n when n > 0 and n % 2 == 1 -> "Positive Odd"
    | n when n < 0 and n % 2 == 0 -> "Negative Even"
    | n when n < 0 and n % 2 == 1 -> "Negative Odd"
    | 0 -> "Zero"
  end
  %% Z3 verifies: All integer cases covered (exhaustive)
end

%% ============================================================================
%% Overflow Prevention
%% ============================================================================

%% Safe addition - prevents integer overflow for reasonable ranges
type SafeInt = Int when x >= -1000000 and x =< 1000000

def safe_add(x: SafeInt, y: SafeInt) -> SafeInt do
  %% Z3 proves: result stays within SafeInt range
  x + y
end

%% ============================================================================
%% Invariant Maintenance
%% ============================================================================

%% A sorted pair - first element always <= second
type SortedPair(T) = {T, T} when fst <= snd

def make_sorted_pair(a: Int, b: Int) -> SortedPair(Int) do
  if a <= b then
    {a, b}  %% Z3 proves: a <= b, so constraint satisfied
  else
    {b, a}  %% Z3 proves: b < a, so b <= a after swap
  end
end

%% Extract minimum from sorted pair
def get_min(pair: SortedPair(Int)) -> Int do
  let {a, b} = pair in
  a  %% Z3 knows: a <= b, so a is minimum
end

%% ============================================================================
%% Compilation and Verification
%% ============================================================================

%% To compile with SMT verification:
%%   cure compile --smt-verify smt_refinement_types.cure
%%
%% The compiler will:
%% 1. Extract refinement constraints from type definitions
%% 2. Generate verification conditions for function bodies
%% 3. Call Z3 to prove constraints hold
%% 4. Report any violations as compile-time errors
%%
%% Example compile-time errors caught by Z3:
%%
%% let x: Positive = -5  
%% ❌ Error: Refinement type violation
%%    Required: x > 0
%%    But: x = -5
%%    Counterexample: x = -5
%%
%% safe_div(10, 0)
%% ❌ Error: Type mismatch
%%    Expected: NonZero (where x /= 0)
%%    Got: 0
%%    Counterexample: Dividing by 0 violates NonZero constraint

%% ============================================================================
%% Benefits of Refinement Types with Z3
%% ============================================================================

%% 1. **Compile-Time Safety**: Errors caught before runtime
%% 2. **No Runtime Overhead**: Constraints verified at compile time
%% 3. **Documentation**: Types express invariants precisely
%% 4. **Refactoring Confidence**: Changes verified automatically
%% 5. **Mathematical Proof**: Z3 provides formal guarantees

%% End of refinement types example
