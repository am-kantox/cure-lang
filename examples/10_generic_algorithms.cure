module generic_algorithms

export [
    main/0,
    sort/1,
    unique/1,
    group_by/2,
    max_by/2
]

% Import typeclass definitions
import typeclass [Show, Eq, Ord, show, compare]

% ============================================================================
% Generic Sorting Algorithm
% ============================================================================

% Generic quicksort using Ord typeclass
def sort(list: List(T)): List(T) where Ord(T) =
    match list do
        [] -> []
        [pivot | rest] ->
            let smaller = [x | x <- rest, compare(x, pivot) == LT]
            let equal = [x | x <- rest, compare(x, pivot) == EQ]
            let larger = [x | x <- rest, compare(x, pivot) == GT]
            sort(smaller) ++ [pivot] ++ equal ++ sort(larger)
    end

% ============================================================================
% Unique Elements (using Eq)
% ============================================================================

% Remove duplicates from a list
def unique(list: List(T)): List(T) where Eq(T) =
    match list do
        [] -> []
        [x | xs] -> [x | remove_all(x, unique(xs))]
    end

def remove_all(elem: T, list: List(T)): List(T) where Eq(T) =
    [x | x <- list, x != elem]

% ============================================================================
% Group By (using Eq on keys)
% ============================================================================

% Group elements by a key function
def group_by(f: T -> K, list: List(T)): List({K, List(T)}) where Eq(K) =
    match list do
        [] -> []
        [x | xs] ->
            let key = f(x)
            let {matching, others} = partition_by_key(key, f, xs)
            [{key, [x | matching]} | group_by(f, others)]
    end

def partition_by_key(key: K, f: T -> K, list: List(T)): {List(T), List(T)} where Eq(K) =
    match list do
        [] -> {[], []}
        [x | xs] ->
            let {matching, others} = partition_by_key(key, f, xs)
            if f(x) == key then
                {[x | matching], others}
            else
                {matching, [x | others]}
            end
    end

% ============================================================================
% Max By (using Ord on comparison key)
% ============================================================================

% Find maximum element by a key function
def max_by(f: T -> K, list: List(T)): Option(T) where Ord(K) =
    match list do
        [] -> None
        [x] -> Some(x)
        [x | xs] ->
            match max_by(f, xs) do
                None -> Some(x)
                Some(max_elem) ->
                    if compare(f(x), f(max_elem)) == GT then
                        Some(x)
                    else
                        Some(max_elem)
                    end
            end
    end

% ============================================================================
% Example Data Types
% ============================================================================

record Person do
    name: String
    age: Int
    score: Float
end
derive Show, Eq, Ord  % Ordered by name, then age, then score

record Product do
    id: Int
    name: String
    price: Float
end
derive Show, Eq

% Custom Ord instance for Product (order by price)
instance Ord(Product) do
    def compare(p1: Product, p2: Product): Ordering =
        compare(p1.price, p2.price)
end

% ============================================================================
% Usage Examples
% ============================================================================

def test_sort_numbers(): List(Int) =
    let numbers = [3, 1, 4, 1, 5, 9, 2, 6]
    sort(numbers)  % [1, 1, 2, 3, 4, 5, 6, 9]

def test_sort_people(): List(Person) =
    let people = [
        Person { name: "Bob", age: 30, score: 85.5 },
        Person { name: "Alice", age: 25, score: 92.0 },
        Person { name: "Charlie", age: 35, score: 78.0 }
    ]
    sort(people)  % Sorted by name (Alice, Bob, Charlie)

def test_unique(): List(Int) =
    let numbers = [1, 2, 2, 3, 1, 4, 3, 5]
    unique(numbers)  % [1, 2, 3, 4, 5]

def test_group_by(): List({Int, List(String)}) =
    let words = ["cat", "dog", "bird", "cow", "bat", "ant"]
    group_by(length, words)
    % Groups by length:
    % [{3, ["cat", "dog", "cow", "bat", "ant"]}, {4, ["bird"]}]

def test_max_by_age(): Option(Person) =
    let people = [
        Person { name: "Alice", age: 25, score: 92.0 },
        Person { name: "Bob", age: 30, score: 85.5 },
        Person { name: "Charlie", age: 35, score: 78.0 }
    ]
    max_by(fn(p: Person) -> p.age, people)  % Some(Charlie) - oldest

def test_max_by_score(): Option(Person) =
    let people = [
        Person { name: "Alice", age: 25, score: 92.0 },
        Person { name: "Bob", age: 30, score: 85.5 },
        Person { name: "Charlie", age: 35, score: 78.0 }
    ]
    max_by(fn(p: Person) -> p.score, people)  % Some(Alice) - highest score

% ============================================================================
% Working with Products
% ============================================================================

def test_sort_by_price(): List(Product) =
    let products = [
        Product { id: 1, name: "Laptop", price: 999.99 },
        Product { id: 2, name: "Mouse", price: 25.50 },
        Product { id: 3, name: "Keyboard", price: 79.99 }
    ]
    sort(products)  % Sorted by price (Mouse, Keyboard, Laptop)

def test_cheapest_product(): Option(Product) =
    let products = [
        Product { id: 1, name: "Laptop", price: 999.99 },
        Product { id: 2, name: "Mouse", price: 25.50 },
        Product { id: 3, name: "Keyboard", price: 79.99 }
    ]
    % Use min_by (inverse of max_by)
    match sort(products) do
        [] -> None
        [first | _] -> Some(first)
    end

% ============================================================================
% Generic Binary Search
% ============================================================================

% Binary search on sorted list
def binary_search(target: T, list: List(T)): Option(Int) where Ord(T) =
    binary_search_helper(target, list, 0, length(list) - 1)

def binary_search_helper(target: T, list: List(T), low: Int, high: Int): Option(Int) where Ord(T) =
    if low > high then
        None
    else
        let mid = (low + high) / 2
        let mid_elem = nth(list, mid)
        match compare(target, mid_elem) do
            EQ -> Some(mid)
            LT -> binary_search_helper(target, list, low, mid - 1)
            GT -> binary_search_helper(target, list, mid + 1, high)
        end
    end

def test_binary_search(): Option(Int) =
    let sorted_numbers = [1, 3, 5, 7, 9, 11, 13, 15]
    binary_search(7, sorted_numbers)  % Some(3) - index of 7

% ============================================================================
% Generic Merge
% ============================================================================

% Merge two sorted lists
def merge(list1: List(T), list2: List(T)): List(T) where Ord(T) =
    match {list1, list2} do
        {[], ys} -> ys
        {xs, []} -> xs
        {[x | xs], [y | ys]} ->
            match compare(x, y) do
                LT -> [x | merge(xs, [y | ys])]
                EQ -> [x | merge(xs, [y | ys])]
                GT -> [y | merge([x | xs], ys)]
            end
    end

def test_merge(): List(Int) =
    let list1 = [1, 3, 5, 7]
    let list2 = [2, 4, 6, 8]
    merge(list1, list2)  % [1, 2, 3, 4, 5, 6, 7, 8]

% ============================================================================
% Generic Comparison Functions
% ============================================================================

% Check if list is sorted
def is_sorted(list: List(T)): Bool where Ord(T) =
    match list do
        [] -> true
        [_] -> true
        [x, y | rest] ->
            match compare(x, y) do
                GT -> false
                _ -> is_sorted([y | rest])
            end
    end

% Find all elements between min and max (inclusive)
def between(min: T, max: T, list: List(T)): List(T) where Ord(T) =
    [x | x <- list, 
         compare(x, min) != LT and compare(x, max) != GT]

% Partition list into elements less than, equal to, and greater than pivot
def partition(pivot: T, list: List(T)): {List(T), List(T), List(T)} where Ord(T) =
    let less = [x | x <- list, compare(x, pivot) == LT]
    let equal = [x | x <- list, compare(x, pivot) == EQ]
    let greater = [x | x <- list, compare(x, pivot) == GT]
    {less, equal, greater}

% ============================================================================
% Main Entry Point
% ============================================================================

def main(): Int =
    println("=== Generic Algorithms Demo ===")
    
    % Test sorting
    println("Sorted numbers: " ++ show(test_sort_numbers()))
    println("Sorted people: " ++ show(test_sort_people()))
    
    % Test unique
    println("Unique elements: " ++ show(test_unique()))
    
    % Test max_by
    match test_max_by_age() do
        Some(person) -> println("Oldest person: " ++ show(person))
        None -> println("No people")
    end
    
    % Test binary search
    match test_binary_search() do
        Some(index) -> println("Found at index: " ++ show(index))
        None -> println("Not found")
    end
    
    % Test merge
    println("Merged lists: " ++ show(test_merge()))
    
    0  % Success

% ============================================================================
% Key Takeaways
% ============================================================================

% 1. GENERIC ALGORITHMS
%    - Write once, use with any type that satisfies constraints
%    - sort(), unique(), max_by() work with all comparable types
%
% 2. TYPECLASS CONSTRAINTS
%    - where Ord(T) enables comparison operations
%    - where Eq(T) enables equality checking
%    - Constraints ensure type safety
%
% 3. CUSTOM INSTANCES
%    - Can override default ordering (Product by price)
%    - Derive for simple cases, manual for custom logic
%
% 4. COMPOSABILITY
%    - Generic functions compose naturally
%    - No code duplication
%    - Type-safe abstractions
%
% 5. PERFORMANCE
%    - Monomorphization eliminates overhead
%    - Generated code equivalent to hand-written versions
%    - No runtime penalty for abstraction
