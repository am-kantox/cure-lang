%% Let-Polymorphism Test
%% Demonstrates Hindley-Milner style let-polymorphism

module LetPolymorphismTest do
  export [test_let_poly/0, test_generalization/0]

  %% Classic let-polymorphism example
  %% The identity function is generalized in the let binding
  def test_let_poly() -> {Int, String} =
    let id = fn(x) -> x in
    % id is polymorphic: forall T. T -> T
    % Can be used at different types
    {id(42), id("hello")}
  end

  %% Test generalization with multiple uses
  def test_generalization() -> Bool =
    let
      % This function is generalized to: forall T. T -> T -> T
      first = fn(x, y) -> x,
      % This one to: forall T, U. T -> U -> T  
      const = fn(x) -> fn(y) -> x end
    in
      % Both can be used polymorphically
      first(10, 20) == const(10)("ignored")
    end

  %% Polymorphic list operations using let
  def test_list_ops() -> List(Int) =
    let
      % Generalized to: forall T. List(T) -> Int
      len = fn(xs) ->
        match xs do
          [] -> 0
          [_ | t] -> 1 + len(t)
        end,
      % Generalized to: forall T. List(T) -> List(T)
      reverse = fn(xs) ->
        let rev_helper = fn(acc, ys) ->
          match ys do
            [] -> acc
            [h | t] -> rev_helper([h | acc], t)
          end
        in
        rev_helper([], xs)
      end
    in
      % Both work on any type of list
      if len([1, 2, 3]) == 3 then
        reverse([1, 2, 3])
      else
        []
      end
  end

  %% Nested let with multiple levels of polymorphism
  def test_nested_poly() -> {Int, String, Bool} =
    let
      % Outer polymorphic function
      apply = fn(f, x) -> f(x),
      % Another polymorphic helper
      pair = fn(a, b) -> {a, b}
    in
      let
        % Specialized versions created on demand
        add_one = fn(x) -> x + 1,
        to_upper = fn(s) -> s  % Simplified, would call string library
      in
        % apply is used polymorphically with different function types
        {apply(add_one, 41), apply(to_upper, "test"), apply(fn(x) -> x, true)}
      end
    end

  %% Polymorphic recursion through let bindings
  def test_poly_recursion() -> List(Int) =
    let
      % Polymorphic map defined locally
      map = fn(f, xs) ->
        match xs do
          [] -> []
          [h | t] -> [f(h) | map(f, t)]
        end,
      % Polymorphic filter
      filter = fn(pred, xs) ->
        match xs do
          [] -> []
          [h | t] ->
            if pred(h) then
              [h | filter(pred, t)]
            else
              filter(pred, t)
            end
        end
    in
      % Compose polymorphic functions
      let doubled = map(fn(x) -> x * 2, [1, 2, 3, 4, 5]) in
      filter(fn(x) -> x > 5, doubled)
    end

end
