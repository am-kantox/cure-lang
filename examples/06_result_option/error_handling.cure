# Cure Language - Result and Option Types Example
# Demonstrates error handling and optional values

module ErrorHandling do
  export [main/0]
  
  # Option type - represents optional values
  def option_examples(): Int do
    let some_value = Some(42) in
    let no_value = None in
    
    let val1 = match some_value do
      Some(x) -> x
      None -> 0
    end in
    
    let val2 = match no_value do
      Some(x) -> x
      None -> -1
    end in
    
    val1
  end
  
  # Result type - represents success or failure
  def result_examples(): Int do
    let success = Ok(100) in
    let failure = Error("Something went wrong") in
    
    let val1 = match success do
      Ok(x) -> x
      Error(_) -> 0
    end in
    
    let val2 = match failure do
      Ok(x) -> x
      Error(_) -> -1
    end in
    
    val1
  end
  
  # Safe division returning Result
  def safe_divide(x: Int, y: Int): Result(Int, String) do
    match y do
      0 -> Error("Division by zero")
      _ -> Ok(x / y)
    end
  end
  
  # Using safe division
  def division_examples(): Int do
    let result1 = safe_divide(10, 2) in
    let result2 = safe_divide(10, 0) in
    
    let val1 = match result1 do
      Ok(x) -> x
      Error(_) -> -1
    end in
    
    val1
  end
  
  # Safe list head returning Option
  def safe_head<T>(list: List(T)): Option(T) do
    match list do
      [] -> None
      [h | _] -> Some(h)
    end
  end
  
  # Safe list indexing
  def safe_nth<T>(list: List(T), n: Int): Option(T) do
    match n do
      0 -> safe_head(list)
      _ -> match list do
        [] -> None
        [_ | t] -> safe_nth(t, n - 1)
      end
    end
  end
  
  # Map over Option
  def map_option<A, B>(opt: Option(A), f: A -> B): Option(B) do
    match opt do
      Some(x) -> Some(f(x))
      None -> None
    end
  end
  
  # Map over Result
  def map_result<T, E, U>(res: Result(T, E), f: T -> U): Result(U, E) do
    match res do
      Ok(x) -> Ok(f(x))
      Error(e) -> Error(e)
    end
  end
  
  # FlatMap for Option (bind/and_then)
  def flat_map_option<A, B>(opt: Option(A), f: A -> Option(B)): Option(B) do
    match opt do
      Some(x) -> f(x)
      None -> None
    end
  end
  
  # FlatMap for Result
  def flat_map_result<T, E, U>(res: Result(T, E), f: T -> Result(U, E)): Result(U, E) do
    match res do
      Ok(x) -> f(x)
      Error(e) -> Error(e)
    end
  end
  
  # Option with default value
  def option_or<T>(opt: Option(T), default: T): T do
    match opt do
      Some(x) -> x
      None -> default
    end
  end
  
  # Result with default value
  def result_or<T>(res: Result(T, String), default: T): T do
    match res do
      Ok(x) -> x
      Error(_) -> default
    end
  end
  
  # Chaining operations with Result
  def chained_operations(x: Int): Result(Int, String) do
    let step1 = safe_divide(x, 2) in
    let step2 = flat_map_result(step1, fn(val) -> 
      safe_divide(val, 3)
    end) in
    step2
  end
  
  # Converting between Option and Result
  def option_to_result<T>(opt: Option(T), error: String): Result(T, String) do
    match opt do
      Some(x) -> Ok(x)
      None -> Error(error)
    end
  end
  
  def result_to_option<T>(res: Result(T, String)): Option(T) do
    match res do
      Ok(x) -> Some(x)
      Error(_) -> None
    end
  end
  
  # Practical example - parsing and validation
  def validate_positive(x: Int): Result(Int, String) do
    match x > 0 do
      true -> Ok(x)
      false -> Error("Number must be positive")
    end
  end
  
  def validate_even(x: Int): Result(Int, String) do
    match x % 2 == 0 do
      true -> Ok(x)
      false -> Error("Number must be even")
    end
  end
  
  def validate_and_process(x: Int): Result(Int, String) do
    let step1 = validate_positive(x) in
    let step2 = flat_map_result(step1, validate_even) in
    map_result(step2, fn(val) -> val * 2 end)
  end
  
  def main(): Int do
    let opt_ex = option_examples() in
    let res_ex = result_examples() in
    let div_ex = division_examples() in
    
    let list = [10, 20, 30, 40] in
    let head = safe_head(list) in
    let second = safe_nth(list, 1) in
    
    let mapped_opt = map_option(Some(5), fn(x) -> x * 2 end) in
    let mapped_res = map_result(Ok(10), fn(x) -> x + 5 end) in
    
    let chained = chained_operations(12) in
    let validated = validate_and_process(8) in
    
    0
  end
end
