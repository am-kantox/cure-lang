# Finite State Machine Examples in Cure
# Demonstrates FSM definitions, state transitions, and integration with processes

module FiniteStateMachines do
  export [demo_all/0, tcp_demo/0, vending_machine_demo/0, game_state_demo/0]

  # Import standard types for communication
  import Std [Result, Option, List]

  # === TCP CONNECTION STATE MACHINE ===

  fsm TcpConnection do
    # All possible states
    states: [Closed, Listen, SynSent, SynReceived, Established, 
             FinWait1, FinWait2, Closing, TimeWait, CloseWait, LastAck]
    
    # Initial state
    initial: Closed
    
    # State definitions with transitions
    state Closed do
      event(:listen) -> Listen
      event(:connect) -> SynSent
    end
    
    state Listen do
      event(:syn_received) -> SynReceived
      event(:close) -> Closed
    end
    
    state SynSent do
      event(:syn_ack_received) -> Established
      event(:syn_received) -> SynReceived
      event(:timeout) -> Closed
      event(:close) -> Closed
    end
    
    state SynReceived do
      event(:ack_received) -> Established
      event(:timeout) -> Closed
      event(:close) -> Closed
    end
    
    state Established do
      event(:fin_received) -> CloseWait
      event(:close) -> FinWait1
      event({:data, payload: Binary}) -> Established
    end
    
    state FinWait1 do
      event(:ack_received) -> FinWait2
      event(:fin_received) -> Closing
    end
    
    state FinWait2 do
      event(:fin_received) -> TimeWait
    end
    
    state Closing do
      event(:ack_received) -> TimeWait
    end
    
    state TimeWait do
      event(:timeout) -> Closed
    end
    
    state CloseWait do
      event(:close) -> LastAck
    end
    
    state LastAck do
      event(:ack_received) -> Closed
    end
  end

  # === VENDING MACHINE STATE MACHINE ===

  type Coin = Quarter | Dime | Nickel
  type Product = Soda | Chips | Candy
  type VendingEvent = 
    | InsertCoin(Coin)
    | SelectProduct(Product)
    | Cancel
    | ServiceMode
    | Restock

  record VendingData do
    balance: Nat  # in cents
    inventory: Map(Product, Nat)
  end

  fsm VendingMachine do
    states: [Idle, WaitingForSelection, Dispensing, OutOfOrder, Maintenance]
    
    initial: Idle
    
    state Idle do
      event(InsertCoin(Quarter)) -> WaitingForSelection  # 25 cents
      event(InsertCoin(Dime)) -> Idle                    # 10 cents, not enough
      event(InsertCoin(Nickel)) -> Idle                  # 5 cents, not enough
      event(ServiceMode) -> Maintenance
    end
    
    state WaitingForSelection do
      event(InsertCoin(coin)) -> WaitingForSelection     # Add more money
      event(SelectProduct(product)) -> Dispensing        # If enough money
      event(Cancel) -> Idle                              # Refund money
    end
    
    state Dispensing do
      event(:product_dispensed) -> Idle
      event(:product_stuck) -> OutOfOrder
    end
    
    state OutOfOrder do
      event(ServiceMode) -> Maintenance
    end
    
    state Maintenance do
      event(Restock) -> Maintenance
      event(:service_complete) -> Idle
    end
  end

  # === GAME STATE MACHINE ===

  type GameEvent =
    | StartGame
    | PauseGame
    | ResumeGame
    | PlayerDied
    | LevelComplete
    | GameOver
    | RestartGame

  fsm GameState do
    states: [MainMenu, Playing, Paused, GameOverScreen, Loading]
    
    initial: MainMenu
    
    state MainMenu do
      event(StartGame) -> Loading
    end
    
    state Loading do
      event(:loading_complete) -> Playing
    end
    
    state Playing do
      event(PauseGame) -> Paused
      event(PlayerDied) -> GameOverScreen
      event(LevelComplete) -> Loading  # Load next level
    end
    
    state Paused do
      event(ResumeGame) -> Playing
      event(GameOver) -> MainMenu
    end
    
    state GameOverScreen do
      event(RestartGame) -> Loading
      event(:timeout) -> MainMenu
    end
  end

  # === PROTOCOL STATE MACHINE ===

  type ProtocolMessage =
    | Handshake(String)
    | Ack
    | Data(Binary)
    | Heartbeat
    | Disconnect

  fsm Protocol do
    states: [Disconnected, Handshaking, Connected, Error]
    
    initial: Disconnected
    
    state Disconnected do
      event(Handshake(version)) -> Handshaking
    end
    
    state Handshaking do
      event(Ack) -> Connected
      event(:timeout) -> Error
      event(Disconnect) -> Disconnected
    end
    
    state Connected do
      event(Data(payload)) -> Connected
      event(Heartbeat) -> Connected
      event(Disconnect) -> Disconnected
      event(:connection_lost) -> Error
    end
    
    state Error do
      event(Handshake(version)) -> Handshaking
      event(:reset) -> Disconnected
    end
  end

  # === WORKFLOW STATE MACHINE ===

  type WorkflowEvent =
    | Submit
    | Approve
    | Reject
    | RequestChanges
    | Resubmit
    | Cancel

  record WorkflowData do
    submitter: String
    approver: Option(String)
    comments: List(String)
  end

  fsm DocumentWorkflow do
    states: [Draft, Submitted, UnderReview, Approved, Rejected, 
             ChangesRequested, Cancelled]
    
    initial: Draft
    
    state Draft do
      event(Submit) -> Submitted
      event(Cancel) -> Cancelled
    end
    
    state Submitted do
      event(:assign_reviewer) -> UnderReview
      event(Cancel) -> Cancelled
    end
    
    state UnderReview do
      event(Approve) -> Approved
      event(Reject) -> Rejected
      event(RequestChanges) -> ChangesRequested
    end
    
    state ChangesRequested do
      event(Resubmit) -> Submitted
      event(Cancel) -> Cancelled
    end
    
    state Approved do
      # Terminal state
    end
    
    state Rejected do
      event(Resubmit) -> Submitted
    end
    
    state Cancelled do
      # Terminal state
    end
  end

  # === FSM PROCESS INTEGRATION ===

  # Process that manages an FSM instance
  process fsm_manager(fsm_type: FsmType) do
    def loop(fsm_instance: FsmInstance, data: Any) do
      receive do
        {:send_event, event, from: Pid} ->
          match fsm_send(fsm_instance, event) do
            {:ok, new_state} ->
              send(from, {:state_changed, new_state})
              loop(fsm_instance, data)
            {:error, reason} ->
              send(from, {:error, reason})
              loop(fsm_instance, data)
          end
        
        {:get_state, from: Pid} ->
          send(from, {:current_state, fsm_get_state(fsm_instance)})
          loop(fsm_instance, data)
        
        {:stop} ->
          :ok
      end
    end
    
    let instance = fsm_spawn(fsm_type)
    loop(instance, {})
  end

  # === FSM UTILITIES ===

  # Helper to create and manage TCP connections
  def create_tcp_connection(): Pid =
    spawn(fsm_manager, [TcpConnection])

  def send_tcp_event(connection: Pid, event: TcpEvent): Result(State, String) =
    send(connection, {:send_event, event, self()})
    receive do
      {:state_changed, new_state} -> Ok(new_state)
      {:error, reason} -> Error(reason)
    end

  # Helper for vending machine
  def create_vending_machine(): Pid =
    spawn(fsm_manager, [VendingMachine])

  def insert_coin_and_select(machine: Pid, coin: Coin, product: Product): Unit =
    send(machine, {:send_event, InsertCoin(coin), self()})
    receive do
      {:state_changed, new_state} ->
        print("After coin: " ++ show(new_state))
        send(machine, {:send_event, SelectProduct(product), self()})
    end

  # === COMPLEX FSM WITH GUARDS AND CONDITIONS ===

  type UserAction = Login(String, String) | Logout | AccessResource(String)
  type AuthEvent = LoginSuccess | LoginFailure | SessionTimeout | Unauthorized

  fsm Authentication do
    states: [LoggedOut, LoggedIn, Locked]
    
    initial: LoggedOut
    
    state LoggedOut do
      event(Login(user, pass)) -> 
        # This would involve validation logic
        if valid_credentials(user, pass) 
        then LoggedIn 
        else LoggedOut
      
      event(Login(user, pass)) -> Locked  # After 3 failed attempts
    end
    
    state LoggedIn do
      event(Logout) -> LoggedOut
      event(SessionTimeout) -> LoggedOut
      event(AccessResource(resource)) ->
        if has_permission(resource)
        then LoggedIn
        else LoggedIn  # Stay logged in but deny access
    end
    
    state Locked do
      event(:unlock_timer) -> LoggedOut
    end
  end

  # === FSM COMPOSITION ===

  # Higher-level FSM that manages multiple sub-FSMs
  process connection_pool(size: Nat) do
    def loop(connections: List(Pid), available: List(Pid)) do
      receive do
        {:get_connection, from: Pid} ->
          match available do
            [conn | rest] ->
              send(from, {:connection, conn})
              loop(connections, rest)
            [] ->
              send(from, {:no_connection})
              loop(connections, available)
          end
        
        {:release_connection, conn: Pid} ->
          loop(connections, conn :: available)
      end
    end
    
    let initial_connections = map(1..size, fn(_) -> create_tcp_connection() end)
    loop(initial_connections, initial_connections)
  end

  # === DEMONSTRATION FUNCTIONS ===

  def tcp_demo(): Unit =
    print("=== TCP Connection State Machine ===")
    
    let conn = fsm_spawn(TcpConnection)
    
    print("Initial state: " ++ show(fsm_get_state(conn)))  # Closed
    
    fsm_send(conn, :listen)
    print("After listen: " ++ show(fsm_get_state(conn)))  # Listen
    
    fsm_send(conn, :syn_received)
    print("After syn_received: " ++ show(fsm_get_state(conn)))  # SynReceived
    
    fsm_send(conn, :ack_received)
    print("After ack_received: " ++ show(fsm_get_state(conn)))  # Established
    
    fsm_send(conn, {:data, "Hello, World!"})
    print("After data: " ++ show(fsm_get_state(conn)))  # Still Established
    
    fsm_send(conn, :close)
    print("After close: " ++ show(fsm_get_state(conn)))  # FinWait1
    
    ok

  def vending_machine_demo(): Unit =
    print("\\n=== Vending Machine State Machine ===")
    
    let machine = fsm_spawn(VendingMachine)
    
    print("Initial state: " ++ show(fsm_get_state(machine)))  # Idle
    
    fsm_send(machine, InsertCoin(Dime))
    print("After dime: " ++ show(fsm_get_state(machine)))  # Still Idle (not enough)
    
    fsm_send(machine, InsertCoin(Quarter))
    print("After quarter: " ++ show(fsm_get_state(machine)))  # WaitingForSelection
    
    fsm_send(machine, SelectProduct(Soda))
    print("After selection: " ++ show(fsm_get_state(machine)))  # Dispensing
    
    fsm_send(machine, :product_dispensed)
    print("After dispensed: " ++ show(fsm_get_state(machine)))  # Idle
    
    ok

  def game_state_demo(): Unit =
    print("\\n=== Game State Machine ===")
    
    let game = fsm_spawn(GameState)
    
    print("Initial state: " ++ show(fsm_get_state(game)))  # MainMenu
    
    fsm_send(game, StartGame)
    print("After start: " ++ show(fsm_get_state(game)))  # Loading
    
    fsm_send(game, :loading_complete)
    print("After loading: " ++ show(fsm_get_state(game)))  # Playing
    
    fsm_send(game, PauseGame)
    print("After pause: " ++ show(fsm_get_state(game)))  # Paused
    
    fsm_send(game, ResumeGame)
    print("After resume: " ++ show(fsm_get_state(game)))  # Playing
    
    fsm_send(game, PlayerDied)
    print("After death: " ++ show(fsm_get_state(game)))  # GameOverScreen
    
    ok

  def workflow_demo(): Unit =
    print("\\n=== Document Workflow State Machine ===")
    
    let workflow = fsm_spawn(DocumentWorkflow)
    
    print("Document created: " ++ show(fsm_get_state(workflow)))  # Draft
    
    fsm_send(workflow, Submit)
    print("After submit: " ++ show(fsm_get_state(workflow)))  # Submitted
    
    fsm_send(workflow, :assign_reviewer)
    print("After assignment: " ++ show(fsm_get_state(workflow)))  # UnderReview
    
    fsm_send(workflow, RequestChanges)
    print("After request changes: " ++ show(fsm_get_state(workflow)))  # ChangesRequested
    
    fsm_send(workflow, Resubmit)
    print("After resubmit: " ++ show(fsm_get_state(workflow)))  # Submitted
    
    fsm_send(workflow, :assign_reviewer)
    fsm_send(workflow, Approve)
    print("After approval: " ++ show(fsm_get_state(workflow)))  # Approved
    
    ok

  def demo_all(): Unit =
    print("=== Finite State Machine Demonstrations ===")
    print("State machines provide type-safe state management with compile-time guarantees!")
    
    tcp_demo()
    vending_machine_demo() 
    game_state_demo()
    workflow_demo()
    
    print("\\n=== Process Integration Demo ===")
    let tcp_manager = create_tcp_connection()
    
    match send_tcp_event(tcp_manager, :listen) do
      Ok(new_state) -> print("TCP Manager state: " ++ show(new_state))
      Error(err) -> print("TCP Manager error: " ++ err)
    end
    
    print("\\n=== Connection Pool Demo ===")
    let pool = spawn(connection_pool, [3])
    
    send(pool, {:get_connection, self()})
    receive do
      {:connection, conn} -> 
        print("Got connection from pool")
        send(pool, {:release_connection, conn})
        print("Released connection back to pool")
      {:no_connection} -> 
        print("No connections available")
    end
    
    print("\\nAll FSM examples completed successfully!")
    print("FSMs provide:")
    print("- Type-safe state transitions")
    print("- Compile-time validation of state machines") 
    print("- Integration with the actor model")
    print("- Composable state management")
    
    ok

  # === UTILITY FUNCTIONS ===

  defp valid_credentials(user: String, pass: String): Bool = 
    # Simplified validation
    user == "admin" && pass == "password"

  defp has_permission(resource: String): Bool =
    # Simplified permission check
    resource != "classified"

end