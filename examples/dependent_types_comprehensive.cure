module DependentTypesComprehensive do
  export [
    demo/0,
    safe_operations_demo/0,
    type_level_computation_demo/0
  ]

  # Main demonstration function
  def demo(): Int = 
    let result1 = safe_operations_demo() in
    let result2 = type_level_computation_demo() in
    result1

  # Demonstrate safe operations with dependent type constraints
  def safe_operations_demo(): Int =
    let numbers = [1, 2, 3, 4, 5] in
    
    # Safe head extraction - guaranteed no null pointer exceptions
    let first = safe_head(numbers) in
    
    # Safe list operations with structural guarantees
    let processed = double_list(numbers) in
    let processed_head = safe_head(processed) in
    
    # Type-safe arithmetic operations
    let sum = safe_add(first, processed_head) in
    sum

  # Demonstrate type-level computation and constraints
  def type_level_computation_demo(): Int =
    let small_list = [10, 20] in
    let large_list = [100, 200, 300, 400, 500] in
    
    # Functions that work with different list structures
    let small_result = process_pair(small_list) in
    let large_result = process_many(large_list) in
    
    safe_add(small_result, large_result)

  # Safe head function - dependent type ensures no runtime failures
  def safe_head(list) =
    match list do
      [first | _] -> first  # Guaranteed safe: pattern matching ensures structure
      [] -> 0               # Handle empty case explicitly
    end

  # List doubling with structure preservation
  def double_list(list) =
    match list do
      [] -> []
      [head | tail] -> [safe_multiply(head, 2) | double_list(tail)]
    end

  # Safe arithmetic operations
  def safe_add(a, b) =
    a + b  # Type system guarantees both a and b are valid numbers

  def safe_multiply(a, b) =
    a * b  # Type system guarantees both a and b are valid numbers

  # Process pairs (demonstrates structural constraints)
  def process_pair(list) =
    match list do
      [a, b] -> safe_add(a, b)  # Works only with exactly 2 elements
      [single] -> single        # Handle single element
      [] -> 0                   # Handle empty
      [first | _] -> first      # Handle longer lists
    end

  # Process many elements (demonstrates different structural constraints)
  def process_many(list) =
    match list do
      [] -> 0
      [single] -> single
      [a, b] -> safe_add(a, b)
      [a, b, c] -> safe_add(a, safe_add(b, c))
      [first | rest] -> safe_add(first, safe_head(rest))
    end
end