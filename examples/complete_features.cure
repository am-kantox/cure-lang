%% Complete Features Example
%% Demonstrates LSP integration, dependent types, pattern matching, and FSMs

module CompleteFeaturesDemo do
  export [main/0, demonstrate_all/0]
  
  %% ============================================================================
  %% Dependent Types Examples
  %% ============================================================================
  
  def make_vector<T>(x: T, y: T, z: T): Vector(T, 3) do
    [x, y, z]
  end
  
  def vector_length<T>(v: Vector(T, n)): Nat do
    n
  end
  
  %% Safe head - returns Some only if list is non-empty
  def safe_head<T>(list: List(T)): Option(T) do
    match list do
      [] -> None
      [head | _] -> Some(head)
    end
  end
  
  %% ============================================================================
  %% Pattern Matching Examples
  %% ============================================================================
  
  def classify_number(n: Int): Atom do
    match n do
      x when x > 0 -> :positive
      x when x < 0 -> :negative
      0 -> :zero
    end
  end
  
  def process_result<T>(result: Result(T, String)): T do
    match result do
      Ok(value) -> value
      Error(msg) -> 
        let default = get_default() in
        default
    end
  end
  
  %% ============================================================================
  %% Higher-Order Functions
  %% ============================================================================
  
  def map<T, U>(f: T -> U, list: List(T)): List(U) do
    match list do
      [] -> []
      [h | t] -> [f(h) | map(f, t)]
    end
  end
  
  def filter<T>(pred: T -> Bool, list: List(T)): List(T) do
    match list do
      [] -> []
      [h | t] ->
        let rest = filter(pred, t) in
        match pred(h) do
          true -> [h | rest]
          false -> rest
        end
    end
  end
  
  %% ============================================================================
  %% FSM Example: Simple Counter
  %% ============================================================================
  
  fsm Counter do
    state idle do
      on start -> counting(0)
    end
    
    state counting(value: Int) do
      on increment -> counting(value + 1)
      on decrement when value > 0 -> counting(value - 1)
      on reset -> counting(0)
      on stop -> idle
    end
  end
  
  %% ============================================================================
  %% Main Demo Function
  %% ============================================================================
  
  def demonstrate_all(): Unit do
    let v1 = make_vector(1, 2, 3) in
    let v2 = make_vector(4, 5, 6) in
    
    let numbers = [1, -2, 0, 3, -4] in
    let classified = map(classify_number, numbers) in
    
    let positives = filter(fn(x) -> x > 0 end, numbers) in
    
    let result_ok = Ok(42) in
    let result_err = Error("Failed") in
    
    print("Dependent types demo complete")
  end
  
  def main(): Int do
    demonstrate_all()
    0
  end
  
  %% ============================================================================
  %% Helper Functions
  %% ============================================================================
  
  def get_default<T>(): T do
    % This would need a proper implementation based on type
    42
  end
  
  def print(msg: String): Unit do
    % Standard output
    :ok
  end
end
