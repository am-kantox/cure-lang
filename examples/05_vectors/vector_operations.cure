# Cure Language - Vector Operations Example
# Demonstrates length-indexed vectors with dependent types

module VectorOperations do
  import Std.Vector
  export [main/0]
  
  # Create vectors of specific lengths
  def create_vectors(): Int do
    let v2 = [1, 2] as Vector(Int, 2) in
    let v3 = [10, 20, 30] as Vector(Int, 3) in
    let v5 = [1, 2, 3, 4, 5] as Vector(Int, 5) in
    
    0
  end
  
  # Vector length is known at compile time
  def vector_lengths(): Int do
    let v3 = [1, 2, 3] as Vector(Int, 3) in
    let len = Vector.length(v3) in  # Returns Nat = 3
    
    let v5 = [10, 20, 30, 40, 50] as Vector(Int, 5) in
    let len5 = Vector.length(v5) in  # Returns Nat = 5
    
    0
  end
  
  # Map preserves vector length
  def map_examples(): Vector(Int, 5) do
    let numbers = [1, 2, 3, 4, 5] as Vector(Int, 5) in
    
    let doubled = Vector.map(numbers, fn(x) -> x * 2 end) in  # Still Vector(Int, 5)
    let squared = Vector.map(numbers, fn(x) -> x * x end) in
    
    doubled
  end
  
  # Zip requires same-length vectors
  def zip_examples(): Vector(Int, 5) do
    let v1 = [1, 2, 3, 4, 5] as Vector(Int, 5) in
    let v2 = [10, 20, 30, 40, 50] as Vector(Int, 5) in
    
    # Type system ensures both vectors have same length
    let sums = Vector.zip_with(v1, v2, fn(x) -> fn(y) -> x + y end end) in
    
    sums
  end
  
  # Filter converts to List (length unknown at compile time)
  def filter_examples(): List(Int) do
    let numbers = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10] as Vector(Int, 10) in
    
    # Filter returns List since result length depends on runtime values
    let evens = Vector.filter(numbers, fn(x) -> x % 2 == 0 end) in
    
    evens
  end
  
  # Fold operation on vectors
  def fold_examples(): Int do
    let numbers = [1, 2, 3, 4, 5] as Vector(Int, 5) in
    
    let sum = Vector.fold(numbers, 0, fn(x) -> fn(acc) -> acc + x end end) in
    let product = Vector.fold(numbers, 1, fn(x) -> fn(acc) -> acc * x end end) in
    
    sum
  end
  
  # Reverse operation preserves length
  def reverse_example(): Vector(Int, 5) do
    let numbers = [1, 2, 3, 4, 5] as Vector(Int, 5) in
    let empty = [] as Vector(Int, 0) in
    
    let reversed = Vector.reverse(numbers, empty) in  # Vector(Int, 5)
    
    reversed
  end
  
  # Contains check
  def contains_examples(): Bool do
    let numbers = [1, 2, 3, 4, 5] as Vector(Int, 5) in
    
    let has_three = Vector.contains(numbers, 3) in
    let has_ten = Vector.contains(numbers, 10) in
    
    has_three
  end
  
  # Working with different vector sizes
  def different_sizes(): Int do
    let v1 = [1] as Vector(Int, 1) in
    let v2 = [1, 2] as Vector(Int, 2) in
    let v3 = [1, 2, 3] as Vector(Int, 3) in
    let v10 = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10] as Vector(Int, 10) in
    
    0
  end
  
  # Type-safe vector operations
  def type_safe_operations(): Vector(Int, 3) do
    let vec = [10, 20, 30] as Vector(Int, 3) in
    
    # Map maintains type-level length
    let doubled = Vector.map(vec, fn(x) -> x * 2 end) in
    let plus_one = Vector.map(doubled, fn(x) -> x + 1 end) in
    
    plus_one
  end
  
  # Demonstrate compile-time length checking
  def safe_indexing(): Int do
    let v5 = [10, 20, 30, 40, 50] as Vector(Int, 5) in
    
    # The type system knows this vector has exactly 5 elements
    # So certain operations are guaranteed safe
    let len = Vector.length(v5) in
    
    0
  end
  
  def main(): Int do
    let created = create_vectors() in
    let lengths = vector_lengths() in
    let mapped = map_examples() in
    let zipped = zip_examples() in
    let filtered = filter_examples() in
    let folded = fold_examples() in
    let reversed = reverse_example() in
    let has = contains_examples() in
    let sizes = different_sizes() in
    let safe = type_safe_operations() in
    let indexed = safe_indexing() in
    
    0
  end
end
