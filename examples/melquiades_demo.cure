# Melquíades Operator Demo
# The |-> operator sends messages to external BEAM GenServers

module MelquiadesDemo do
  import Std.String [trim/1, upcase/1]

  export [
    send_notification/2,
    send_with_record/3,
    send_to_global/2,
    send_via_registry/3,
    example_usage/0
  ]

  # Define a message record
  record NotificationMsg do
    msg_type: Atom
    content: String
    priority: Int
  end

  # Define another record for complex messages
  record UserEvent do
    user_id: Int
    event_action: String
    timestamp: Int
  end

  # Send a simple message to a local GenServer
  # The message can be any term
  def send_notification(server_name: Atom, message: String): Unit =
    message |-> server_name

  # Send a record message (will be converted to map with __from__ = MelquiadesDemo)
  def send_with_record(server: Atom, notification_type: Atom, content: String): Unit = (
    let msg = NotificationMsg{
      msg_type: notification_type,
      content: content,
      priority: 5
    }
    msg |-> server
  )

  # Send to a globally registered GenServer
  # In Cure, we construct GenServerRef types for different name formats
  def send_to_global(name: Atom, message: String): Unit = (
    # Global name: {:global, name}
    let global_ref = {:global, name}
    message |-> global_ref
  )

  # Send via a process registry (like Registry)
  def send_via_registry(registry: Atom, key: String, message: String): Unit = (
    # Via tuple: {:via, Registry, {RegistryName, key}}
    let via_ref = {:via, :Registry, {registry, key}}
    message |-> via_ref
  )

  # Example usage showing different message types
  def example_usage(): Unit = (
    # Simple message to local server
    let _ = "Hello, World!" |-> :my_server

    # Record message (auto-converted to map with __from__)
    let user_event = UserEvent{
      user_id: 42,
      event_action: "login",
      timestamp: 1701000000
    }
    let _ = user_event |-> :event_handler

    # Chain with other operations
    let result = compute_message()
    let _ = result |-> :result_processor

    # Tuple message
    let _ = {:notification, "System started"} |-> :logger

    # List message
    let _ = [1, 2, 3, 4, 5] |-> :list_processor
    
    # Return Unit
    {}
  )

  # Helper function to demonstrate chaining
  def compute_message(): String =
    "Computed result"

  # Complex example: Send multiple messages in sequence
  def broadcast_event(user_event: UserEvent, servers: List(Atom)): Unit =
    # Note: This would need to be implemented with proper list iteration
    # For now, showing the concept with just one send
    user_event |-> :server1

  # Example with pattern matching
  def conditional_send(condition: Bool, message: String): Unit =
    match condition do
      true -> message |-> :primary_server
      false -> message |-> :backup_server
    end

  # Example showing the operator in a pipeline
  def process_and_send(data: String): Unit = (
    let processed = data
      |> trim
      |> upcase
    let _ = processed |-> :processor
    {}
  )
end

# Usage notes:
# 
# 1. The |-> operator is named "Melquíades" in honor of the character from
#    Gabriel García Márquez's "One Hundred Years of Solitude"
#
# 2. It always uses gen_server:cast/2 underneath (asynchronous, fire-and-forget)
#
# 3. The operator always returns None since cast always succeeds
#
# 4. When sending records, they are automatically converted to Erlang maps with
#    an injected __from__ key containing the sender module name:
#    
#    NotificationMsg{type: :info, ...} becomes:
#    #{__from__ => 'MelquiadesDemo', type => info, ...}
#
# 5. The target can be:
#    - Local name (atom): :my_server
#    - Global name: {:global, :name}
#    - Via registry: {:via, ModuleName, term()}
#
# 6. This operator is designed for sending messages to Erlang/Elixir GenServers
#    from Cure code, enabling seamless interop with the BEAM ecosystem
