# Pattern Guards Example
# Demonstrates pattern matching with guard expressions in Cure

module PatternGuards do
  export [demo_all/0]

  import Std.Io [println/1]
  import Std.List [length/1]
  import Std.Show [show/1]

  # === BASIC GUARDS ===
  
  # Numeric comparison guards
  def classify_age(age: Int): String =
    match age do
      x when x < 0 -> "Invalid age"
      x when x >= 0 and x < 13 -> "Child"
      x when x >= 13 and x < 20 -> "Teenager"
      x when x >= 20 and x < 65 -> "Adult"
      x when x >= 65 -> "Senior"
    end

  # Multiple conditions with logical operators
  def check_range(n: Int): String =
    match n do
      x when x >= 10 and x <= 20 -> "In range [10, 20]"
      x when x < 10 or x > 20 -> "Out of range"
    end

  # Equality and inequality guards
  def describe_value(n: Int): String =
    match n do
      x when x == 0 -> "Zero"
      x when x == 1 -> "One"
      _ -> "Unknown"
    end

  # === GUARDS WITH ARITHMETIC ===

  # Using arithmetic in guards
  # def check_even_odd(n: Int): String =
  #   match n do
  #     x when x % 2 == 0 -> "Even: " <> show(x)
  #     x when x % 2 == 1 -> "Odd: " <> show(x)
  #   end

  # Complex arithmetic conditions
  def triangle_type(a: Float, b: Float, c: Float): String =
    match {a, b, c} do
      {x, y, z} when x + y <= z or x + z <= y or y + z <= x ->
        "Not a valid triangle"
      {x, y, z} when x == y and y == z ->
        "Equilateral triangle"
      {x, y, z} when x == y or y == z or x == z ->
        "Isosceles triangle"
      _ ->
        "Scalene triangle"
    end

  # === GUARDS WITH LIST PATTERNS ===

  # Guards on list elements
  def analyze_list(list: List(Int)): String =
    match list do
      [] -> "Empty list"
      [x] when x > 0 -> "Single positive element"
      [x] when x < 0 -> "Single negative element"
      [x] when x == 0 -> "Single zero element"
      [x, y] when x > y -> "Two elements, descending"
      [x, y] when x < y -> "Two elements, ascending"
      [x, y] when x == y -> "Two equal elements"
      [head | _] when head > 100 -> "List starts with large number"
      [head | _] when head < 0 -> "List starts with negative"
      _ -> "Other list pattern"
    end

  # === GUARDS WITH RECORDS ===

  record Point do
    x: Float
    y: Float
  end

  # Guards accessing record fields
  def classify_point(p: Point): String =
    match p do
      Point{x: x, y: y} when x == 0.0 and y == 0.0 ->
        "Origin"
      Point{x: x, y: y} when x > 0.0 and y > 0.0 ->
        "First quadrant"
      Point{x: x, y: y} when x < 0.0 and y > 0.0 ->
        "Second quadrant"
      Point{x: x, y: y} when x < 0.0 and y < 0.0 ->
        "Third quadrant"
      Point{x: x, y: y} when x > 0.0 and y < 0.0 ->
        "Fourth quadrant"
      Point{x: x, y: _} when x == 0.0 ->
        "On Y-axis"
      Point{x: _, y: y} when y == 0.0 ->
        "On X-axis"
    end

  def distance_from_origin(p: Point): String =
    match p do
      Point{x: x, y: y} when x * x + y * y < 1.0 ->
        "Inside unit circle"
      Point{x: x, y: y} when x * x + y * y == 1.0 ->
        "On unit circle"
      Point{x: x, y: y} when x * x + y * y > 1.0 ->
        "Outside unit circle"
    end

  # === GUARDS WITH UNION TYPES ===

  type Result(T, E) = Ok(T) | Error(E)

  def process_result(result: Result(Int, String)): String =
    match result do
      Ok(value) when value > 100 ->
        "Large success: " <> show(value)
      Ok(value) when value > 0 and value <= 100 ->
        "Moderate success: " <> show(value)
      Ok(value) when value < 0 ->
        "Non-positive success: " <> show(value)
      Error(msg) when msg == "timeout" ->
        "Connection timeout"
      Error(msg) when msg == "not_found" ->
        "Resource not found"
      Error(msg) ->
        "Error: " <> msg
    end

  # === NESTED GUARDS ===

  record Person do
    name: String
    age: Int
    score: Int
  end

  def evaluate_person(person: Person): String =
    match person do
      Person{age: age, score: score} when age < 18 and score >= 90 ->
        "Outstanding young achiever"
      Person{age: age, score: score} when age < 18 and score >= 70 ->
        "Good young student"
      Person{age: age, score: score} when age >= 18 and age < 65 and score >= 90 ->
        "Excellent adult performer"
      Person{age: age, score: score} when age >= 18 and age < 65 and score >= 70 ->
        "Good adult performer"
      Person{age: age, score: score} when age >= 65 and score >= 80 ->
        "Impressive senior"
      Person{age: age, score: _} when age >= 65 ->
        "Senior participant"
      _ ->
        "Needs improvement"
    end

  # === GUARDS WITH COMPLEX EXPRESSIONS ===

  def fizzbuzz(n: Int): String =
    match n do
      x when x % 15 == 0 -> "FizzBuzz"
      x when x % 3 == 0 -> "Fizz"
      x when x % 5 == 0 -> "Buzz"
      x -> show(x)
    end

  # Temperature classification with multiple thresholds
  def classify_temperature(celsius: Float): String =
    match celsius do
      t when t < -273.15 -> "Invalid (below absolute zero)"
      t when t < -50.0 -> "Extremely cold"
      t when t >= -50.0 and t < 0.0 -> "Freezing"
      t when t >= 0.0 and t < 15.0 -> "Cold"
      t when t >= 15.0 and t < 25.0 -> "Comfortable"
      t when t >= 25.0 and t < 35.0 -> "Warm"
      t when t >= 35.0 -> "Hot"
    end

  # === GUARDS WITH NEGATIVE CONDITIONS ===

  def validate_input(n: Int): String =
    match n do
      x when x > 10 ->
        "Valid large number"
      0 -> "Zero not allowed"
      1 -> "One not allowed"
      x when x < 10 ->
        "Valid small number"
    end

  # === TYPE CHECKING GUARDS ===

  # Type guards allow runtime type checking in pattern guards
  # Common type checking functions:
  #   - is_integer(x)  : Check if x is an integer
  #   - is_float(x)    : Check if x is a float
  #   - is_number(x)   : Check if x is any number (int or float)
  #   - is_atom(x)     : Check if x is an atom
  #   - is_boolean(x)  : Check if x is a boolean (true/false)
  #   - is_list(x)     : Check if x is a list
  #   - is_tuple(x)    : Check if x is a tuple
  #   - is_binary(x)   : Check if x is a binary/string
  #   - is_function(x) : Check if x is a function
  #   - is_pid(x)      : Check if x is a process identifier

  # Polymorphic function with type guards
  def describe_type(value: Any): String =
    match value do
      x when is_integer(x) and x >= 0 ->
        "Positive integer: " <> show(x)
      x when is_integer(x) and x < 0 ->
        "Negative integer: " <> show(x)
      x when is_float(x) ->
        "Float: " <> show(x)
      x when is_atom(x) ->
        "Atom: " <> show(x)
      x when is_boolean(x) ->
        "Boolean: " <> show(x)
      x when is_list(x) ->
        "List with length " <> show(length(x))
      x when is_tuple(x) ->
        "Tuple"
      x when is_binary(x) ->
        "String/Binary: " <> x
      _ ->
        "Unknown type"
    end

  # Combining type guards with value conditions
  def safe_divide(a: Any, b: Any): String =
    match {a, b} do
      {x, y} when is_number(x) and is_number(y) and y != 0 ->
        let result = x / y
        "Result: " <> show(result)
      {x, y} when is_number(x) and is_number(y) and y == 0 ->
        "Error: Division by zero"
      {x, y} when not is_number(x) ->
        "Error: First argument is not a number"
      {x, y} when not is_number(y) ->
        "Error: Second argument is not a number"
      _ ->
        "Error: Invalid arguments"
    end

  # Type-based list processing
  def process_mixed_list(items: List(Any)): String =
    match items do
      [] -> "Empty list"
      [x | rest] when is_integer(x) and x > 0 ->
        "Starts with positive integer"
      [x | rest] when is_float(x) ->
        "Starts with float"
      [x | rest] when is_atom(x) ->
        "Starts with atom"
      [x | rest] when is_list(x) ->
        "Starts with nested list"
      _ ->
        "Other pattern"
    end

  # Validating function arguments with type guards
  def validate_config(key: Any, value: Any): String =
    match {key, value} do
      {k, v} when is_atom(k) and is_integer(v) and v >= 0 ->
        "Valid config: atom key with positive integer value"
      {k, v} when is_atom(k) and is_binary(v) ->
        "Valid config: atom key with string value"
      {k, v} when is_atom(k) and is_boolean(v) ->
        "Valid config: atom key with boolean value"
      {k, _} when not is_atom(k) ->
        "Error: Key must be an atom"
      _ ->
        "Error: Invalid configuration"
    end

  # Complex type guard combinations
  def smart_comparison(a: Any, b: Any): String =
    match {a, b} do
      {x, y} when is_number(x) and is_number(y) and x > y ->
        "First number is greater"
      {x, y} when is_number(x) and is_number(y) and x < y ->
        "Second number is greater"
      {x, y} when is_number(x) and is_number(y) and x == y ->
        "Numbers are equal"
      {x, y} when is_binary(x) and is_binary(y) ->
        "Both are strings"
      {x, y} when is_list(x) and is_list(y) ->
        "Both are lists of length " <> show(length(x)) <> " and " <> show(length(y))
      _ ->
        "Cannot compare: incompatible or mixed types"
    end

  # === DEMONSTRATION FUNCTION ===

  def demo_all(): Int =
    println("=== Basic Age Classification ===")
    println(classify_age(5))       # "Child"
    println(classify_age(15))      # "Teenager"
    println(classify_age(30))      # "Adult"
    println(classify_age(70))      # "Senior"

    println("\n=== Range Checking ===")
    println(check_range(15))       # "In range [10, 20]"
    println(check_range(25))       # "Out of range"

    # println("\n=== Even/Odd ===")
    # println(check_even_odd(10))    # "Even: 10"
    # println(check_even_odd(7))     # "Odd: 7"

    println("\n=== Triangle Types ===")
    println(triangle_type(3.0, 4.0, 5.0))     # "Scalene triangle"
    println(triangle_type(5.0, 5.0, 5.0))     # "Equilateral triangle"
    println(triangle_type(5.0, 5.0, 8.0))     # "Isosceles triangle"

    println("\n=== List Analysis ===")
    println(analyze_list([]))          # "Empty list"
    println(analyze_list([42]))        # "Single positive element"
    println(analyze_list([150, 10]))   # "List starts with large number"

    println("\n=== Point Classification ===")
    let p1 = Point{x: 0.0, y: 0.0}
    println(classify_point(p1))        # "Origin"

    println("\n=== Distance from Origin ===")
    println(distance_from_origin(Point{x: 0.5, y: 0.5}))   # "Inside unit circle"
    println(distance_from_origin(Point{x: 2.0, y: 2.0}))   # "Outside unit circle"

    println("\n=== Result Processing ===")
    println(process_result(Ok(150)))                 # "Large success: 150"
    println(process_result(Ok(50)))                  # "Moderate success: 50"
    println(process_result(Error("timeout")))        # "Connection timeout"

    println("\n=== Person Evaluation ===")
    let alice = Person{name: "Alice", age: 16, score: 95}
    println(evaluate_person(alice))    # "Outstanding young achiever"
    let bob = Person{name: "Bob", age: 35, score: 85}
    println(evaluate_person(bob))      # "Good adult performer"

    println("\n=== FizzBuzz ===")
    println(fizzbuzz(15))              # "FizzBuzz"
    println(fizzbuzz(9))               # "Fizz"
    println(fizzbuzz(10))              # "Buzz"
    println(fizzbuzz(7))               # "7"

    println("\n=== Temperature Classification ===")
    println(classify_temperature(-60.0))    # "Extremely cold"
    println(classify_temperature(20.0))     # "Comfortable"
    println(classify_temperature(40.0))     # "Hot"

    println("\n=== Input Validation ===")
    println(validate_input(15))        # "Valid large number"
    println(validate_input(5))         # "Valid small number"
    println(validate_input(0))         # "Zero not allowed"

    println("\n=== Type Checking Guards ===")
    println(describe_type(42))         # "Positive integer: 42"
    println(describe_type(-7))         # "Negative integer: -7"
    println(describe_type(3.14))       # "Float: 3.14"
    println(describe_type(:hello))     # "Atom: hello"
    println(describe_type(true))       # "Boolean: true"
    println(describe_type([1, 2, 3]))  # "List with length 3"
    println(describe_type("text"))     # "String/Binary: text"

    println("\n=== Safe Division with Type Guards ===")
    println(safe_divide(10, 2))        # "Result: 5"
    println(safe_divide(10, 0))        # "Error: Division by zero"
    println(safe_divide("x", 2))       # "Error: First argument is not a number"

    println("\n=== Processing Mixed Lists ===")
    println(process_mixed_list([42, "a", :b]))    # "Starts with positive integer"
    println(process_mixed_list([3.14, 2]))        # "Starts with float"
    println(process_mixed_list([:atom, 1, 2]))    # "Starts with atom"

    println("\n=== Config Validation ===")
    println(validate_config(:port, 8080))         # "Valid config: atom key with positive integer value"
    println(validate_config(:name, "server"))     # "Valid config: atom key with string value"
    println(validate_config(:enabled, true))      # "Valid config: atom key with boolean value"
    println(validate_config("key", 123))          # "Error: Key must be an atom"

    println("\n=== Smart Comparison ===")
    println(smart_comparison(10, 5))              # "First number is greater"
    println(smart_comparison(3, 8))               # "Second number is greater"
    println(smart_comparison("hello", "world"))   # "Both are strings"
    println(smart_comparison([1, 2], [3]))        # "Both are lists..."

    0

end
