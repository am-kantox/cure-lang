# =============================================================================
# LIST FOLD DEMONSTRATION IN CURE
# =============================================================================
# 
# This file demonstrates how to use the fold/3 function pattern for list processing.
# The fold function has the signature: fold(list: List(T), init: U, func: T -> U -> U): U
#
# fold/3 is a powerful higher-order function that processes a list by:
# 1. Taking each element of type T from the list
# 2. Applying a function that combines the element with an accumulator
# 3. Returning a final result of type U
#
# This is equivalent to Haskell's foldr or Python's functools.reduce
# =============================================================================

module ListDemo do
  export [demo_all/0]
  
  import Std [List]
  
  # Main demonstration: Sum the numbers [1, 2, 3] using fold
  # Expected result: 1 + 2 + 3 = 6
  # Actual fold execution: add_curried(1, add_curried(2, add_curried(3, 0)))
  def demo_all(): Int =
    let numbers = [1, 2, 3]
    manual_fold(numbers, 0, add_curried)

  # Additional demonstration functions showing different uses of fold:
  
  # Sum all elements: [1,2,3,4,5] -> 15
  def sum_demo(): Int =
    let numbers = [1, 2, 3, 4, 5]
    manual_fold(numbers, 0, add_curried)
  
  # Product of elements: [2,3,4] -> 24
  def product_demo(): Int =
    let numbers = [2, 3, 4]
    manual_fold(numbers, 1, multiply_curried)
  
  # Count elements: [a,b,c,d,e] -> 5
  def count_demo(): Int =
    let numbers = [10, 20, 30, 40, 50]
    manual_fold(numbers, 0, count_curried)

  # MANUAL FOLD IMPLEMENTATION
  # This demonstrates the fold pattern since Std.List.fold has type inference issues
  def manual_fold(list: List(T), init: U, func: T -> U -> U): U =
    match list do
      [] -> init  # Base case: empty list returns initial value
      [h | t] -> func(h, manual_fold(t, init, func))  # Recursive case
    end

  # CURRIED HELPER FUNCTIONS
  # These implement the T -> U -> U signature required by fold
  
  # Addition: each element is added to accumulator
  def add_curried(x: Int): Int -> Int =
    fn(acc) -> x + acc end
  
  # Multiplication: each element is multiplied with accumulator  
  def multiply_curried(x: Int): Int -> Int =
    fn(acc) -> x * acc end
    
  # Counting: ignores element value, increments counter
  def count_curried(x: Int): Int -> Int =
    fn(acc) -> acc + 1 end

  # USAGE PATTERNS:
  # fold([1,2,3], 0, add_curried) = add_curried(1, add_curried(2, add_curried(3, 0)))
  # fold([2,3,4], 1, multiply_curried) = multiply_curried(2, multiply_curried(3, multiply_curried(4, 1)))
  # fold([a,b,c], 0, count_curried) = count_curried(a, count_curried(b, count_curried(c, 0)))
  #
  # fold is right-associative and processes from right to left
  # Perfect for: aggregations, reductions, transformations, and building results from lists

end
