# Turnstile FSM Example
# Classic two-state FSM: Locked <-> Unlocked
# Demonstrates FSM definition with payload and transition handlers

module Turnstile do
  export [main/0]
  
  import Std.Fsm [fsm_spawn/2, fsm_cast/2, fsm_advertise/2, fsm_state/1]
  import Std.Io [println/1]
  import Std.Core [ok/1, error/1]
  import Std.Show [show/1]
  import Std.Pair [pair/2]
  
  # Payload record - tracks turnstile statistics
  record TurnstilePayload do
    coins_inserted: Int
    people_passed: Int
    denied_attempts: Int
  end
  
  # Define the Turnstile FSM with initial payload
  # Initial state will be Locked (first in the list)
  fsm TurnstilePayload{coins_inserted: 0, people_passed: 0, denied_attempts: 0} do
    Locked --> |coin| Unlocked
    Locked --> |push| Locked
    Unlocked --> |coin| Unlocked
    Unlocked --> |push| Locked
  end
  
  # === DEMO ===
  
  def main(): Int =
    println("=== Turnstile FSM Demo ===")
    println("")
    
    # Start the FSM (initial state will be Locked - first in transition list)
    # fsm_spawn takes FSM type name and initial data
    let initial_data = TurnstilePayload{coins_inserted: 0, people_passed: 0, denied_attempts: 0}
    let fsm_pid = fsm_spawn(:TurnstilePayload, initial_data)
    
    # Give it a friendly name
    let adv_result = fsm_advertise(fsm_pid, :main_turnstile)
    
    # Check initial state
    let result = fsm_state(:main_turnstile)
    println(show(result))
    
    println("")
    
    # Scenario 1: Try to push while locked (should be denied)
    println("→ Pushing while locked...")
    let empty_list = []
    let event1 = pair(:push, empty_list)
    let cast1 = fsm_cast(:main_turnstile, event1)
    let result = fsm_state(:main_turnstile)
    println(show(result))
    
    # Scenario 2: Insert coin (should unlock)
    println("→ Inserting coin...")
    let empty_list2 = []
    let event2 = pair(:coin, empty_list2)
    let cast2 = fsm_cast(:main_turnstile, event2)
    
    # Scenario 3: Push through (should lock again and count passage)
    println("→ Pushing through...")
    let empty_list3 = []
    let event3 = pair(:push, empty_list3)
    let cast3 = fsm_cast(:main_turnstile, event3)
    
    # Scenario 4: Insert another coin
    println("→ Inserting second coin...")
    let empty_list4 = []
    let event4 = pair(:coin, empty_list4)
    let cast4 = fsm_cast(:main_turnstile, event4)
    
    # Scenario 5: Insert coin while unlocked (increments counter but no state change)
    println("→ Inserting coin while unlocked...")
    let empty_list5 = []
    let event5 = pair(:coin, empty_list5)
    let cast5 = fsm_cast(:main_turnstile, event5)
    
    # Final state
    println("")
    println("=== Final State ===")
    let result = fsm_state(:main_turnstile)
    println(show(result))
    
    0
  
end
