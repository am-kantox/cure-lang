# Turnstile FSM Example
# Classic two-state FSM: Locked <-> Unlocked
# Demonstrates FSM definition with payload and transition handlers

module Turnstile do
  export [main/0]
  
  import Std.Fsm [start_fsm/1, fsm_cast/2, fsm_advertise/2, fsm_state/1, StateName, Event, FsmError]
  import Std.Io [println/1]
  import Std.Core [ok/1, error/1]
  import Std.Show [show/1]
  
  # Payload record - tracks turnstile statistics
  record TurnstilePayload do
    coins_inserted: Int
    people_passed: Int
    denied_attempts: Int
  end
  
  # Define the Turnstile FSM with initial payload
  # Initial state will be Locked (first in the list)
  fsm TurnstilePayload{coins_inserted: 0, people_passed: 0, denied_attempts: 0} do
    Locked --> |coin| Unlocked
    Locked --> |push| Locked
    Unlocked --> |coin| Unlocked
    Unlocked --> |push| Locked
  end
  
  # === TRANSITION HANDLERS ===
  
  # Handler: Insert coin
  # - When Locked->Unlocked: unlock and increment coin counter
  # - When Unlocked->Unlocked: increment coin counter (redundant coin)
  def coin(from: StateName, evt: Event, payload: TurnstilePayload): Result({Atom, TurnstilePayload}, FsmError) =
    let new_payload = TurnstilePayload{
      coins_inserted: payload.coins_inserted + 1,
      people_passed: payload.people_passed,
      denied_attempts: payload.denied_attempts
    }
    # Determine next state based on current state
    let next_state = match from do
      :Locked -> :Unlocked
      :Unlocked -> :Unlocked  # Stay unlocked if already unlocked
      _ -> from  # Shouldn't happen, but stay in current state
    end
    ok({next_state, new_payload})
  
  # Handler: Push through turnstile
  # - When Locked->Locked: stay locked, increment denied attempts
  # - When Unlocked->Locked: lock and increment people passed
  def push(from: StateName, evt: Event, payload: TurnstilePayload): Result({Atom, TurnstilePayload}, FsmError) =
    match from do
      :Locked ->
        # Trying to push while locked - denied!
        let new_payload = TurnstilePayload{
          coins_inserted: payload.coins_inserted,
          people_passed: payload.people_passed,
          denied_attempts: payload.denied_attempts + 1
        }
        ok({:Locked, new_payload})
      
      :Unlocked ->
        # Push while unlocked - person passes through, lock again
        let new_payload = TurnstilePayload{
          coins_inserted: payload.coins_inserted,
          people_passed: payload.people_passed + 1,
          denied_attempts: payload.denied_attempts
        }
        ok({:Locked, new_payload})
      
      _ -> error(:invalid_state)
    end
  
  # === DEMO ===
  
  def main(): Int =
    println("=== Turnstile FSM Demo ===")
    println("")
    
    # Start the FSM (initial state will be Locked - first in transition list)
    let fsm_pid = start_fsm(Turnstile)
    
    # Give it a friendly name
    fsm_advertise(fsm_pid, :main_turnstile)
    
    # Check initial state
    let result = fsm_state(:main_turnstile)
    println(show(result))
    
    println("")
    
    # Scenario 1: Try to push while locked (should be denied)
    println("→ Pushing while locked...")
    fsm_cast(:main_turnstile, {:push, []})
    let result = fsm_state(:main_turnstile)
    println(show(result))
    
    # Scenario 2: Insert coin (should unlock)
    println("→ Inserting coin...")
    fsm_cast(:main_turnstile, {:coin, []})
    
    # Scenario 3: Push through (should lock again and count passage)
    println("→ Pushing through...")
    fsm_cast(:main_turnstile, {:push, []})
    
    # Scenario 4: Insert another coin
    println("→ Inserting second coin...")
    fsm_cast(:main_turnstile, {:coin, []})
    
    # Scenario 5: Insert coin while unlocked (increments counter but no state change)
    println("→ Inserting coin while unlocked...")
    fsm_cast(:main_turnstile, {:coin, []})
    
    # Final state
    println("")
    println("=== Final State ===")
    let result = fsm_state(:main_turnstile)
    println(show(result))
    
    0
  
end
