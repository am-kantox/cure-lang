# Cure Language - Polymorphic Types Example
# Demonstrates parametric polymorphism (generics)

module PolymorphicTypes do
  export [main/0, identity/1, first/1, second/1, swap/1]
  
  # Generic identity function - works with any type T
  def identity<T>(x: T): T do
    x
  end
  
  # Get first element of a pair
  def first<A, B>(pair: (A, B)): A do
    match pair do
      (a, b) -> a
    end
  end
  
  # Get second element of a pair
  def second<A, B>(pair: (A, B)): B do
    match pair do
      (a, b) -> b
    end
  end
  
  # Swap elements of a pair
  def swap<A, B>(pair: (A, B)): (B, A) do
    match pair do
      (a, b) -> (b, a)
    end
  end
  
  # Generic map function for lists
  def map<A, B>(list: List(A), f: A -> B): List(B) do
    match list do
      [] -> []
      [h | t] -> [f(h) | map(t, f)]
    end
  end
  
  # Generic filter function
  def filter<T>(list: List(T), pred: T -> Bool): List(T) do
    match list do
      [] -> []
      [h | t] ->
        let filtered_tail = filter(t, pred) in
        match pred(h) do
          true -> [h | filtered_tail]
          false -> filtered_tail
        end
    end
  end
  
  # Generic fold (reduce) function
  def fold<A, B>(list: List(A), init: B, f: A -> B -> B): B do
    match list do
      [] -> init
      [h | t] ->
        let partial = f(h) in
        partial(fold(t, init, f))
    end
  end
  
  # Generic zip function
  def zip<A, B>(list1: List(A), list2: List(B)): List((A, B)) do
    match list1 do
      [] -> []
      [h1 | t1] ->
        match list2 do
          [] -> []
          [h2 | t2] -> [(h1, h2) | zip(t1, t2)]
        end
    end
  end
  
  # Polymorphic option type operations
  def map_option<A, B>(opt: Option(A), f: A -> B): Option(B) do
    match opt do
      Some(x) -> Some(f(x))
      None -> None
    end
  end
  
  # Polymorphic result type operations
  def map_result<T, E, U>(result: Result(T, E), f: T -> U): Result(U, E) do
    match result do
      Ok(value) -> Ok(f(value))
      Error(err) -> Error(err)
    end
  end
  
  def main(): Int do
    let int_id = identity(42) in
    let bool_id = identity(true) in
    let string_id = identity("hello") in
    
    let pair = (10, "ten") in
    let f = first(pair) in
    let s = second(pair) in
    let swapped = swap(pair) in
    
    let numbers = [1, 2, 3, 4, 5] in
    let doubled = map(numbers, fn(x) -> x * 2 end) in
    
    0
  end
end
