# Cure Language - Dependent Types Example
# Demonstrates dependent types with length-indexed vectors and Nat types

module DependentTypes do
  export [main/0, make_vector3/3, safe_head/1, vector_append/2]
  
  # Create a vector of exactly length 3
  def make_vector3<T>(x: T, y: T, z: T): Vector(T, 3) do
    [x, y, z]
  end
  
  # Create a vector of exactly length 2
  def make_pair<T>(x: T, y: T): Vector(T, 2) do
    [x, y]
  end
  
  # The type system ensures vector has exactly n elements
  def vector_length<T>(v: Vector(T, n)): Nat do
    n
  end
  
  # Safe head - can only be called on non-empty vectors
  # Type system prevents calling this on empty vectors
  def safe_head<T>(v: Vector(T, n)): T do
    match v do
      [h | _] -> h
      [] -> 0  # This branch should be unreachable for n > 0
    end
  end
  
  # Vector append - lengths add up
  def vector_append<T>(v1: Vector(T, n), v2: Vector(T, m)): Vector(T, n + m) do
    match v1 do
      [] -> v2
      [h | t] -> [h | vector_append(t, v2)]
    end
  end
  
  # Vector map preserves length
  def vector_map<A, B>(v: Vector(A, n), f: A -> B): Vector(B, n) do
    match v do
      [] -> []
      [h | t] -> [f(h) | vector_map(t, f)]
    end
  end
  
  # Zip two vectors of same length
  def vector_zip<A, B>(v1: Vector(A, n), v2: Vector(B, n)): Vector((A, B), n) do
    match v1 do
      [] -> []
      [h1 | t1] ->
        match v2 do
          [h2 | t2] -> [(h1, h2) | vector_zip(t1, t2)]
          [] -> []  # Should be unreachable when lengths match
        end
    end
  end
  
  # Nat type examples - Peano numbers
  def nat_zero(): Nat do
    Zero
  end
  
  def nat_one(): Nat do
    Succ(Zero)
  end
  
  def nat_two(): Nat do
    Succ(Succ(Zero))
  end
  
  def nat_three(): Nat do
    Succ(Succ(Succ(Zero)))
  end
  
  # Add two Nat numbers
  def nat_add(n: Nat, m: Nat): Nat do
    match n do
      Zero -> m
      Succ(pred) -> Succ(nat_add(pred, m))
    end
  end
  
  # Multiply two Nat numbers
  def nat_mul(n: Nat, m: Nat): Nat do
    match n do
      Zero -> Zero
      Succ(pred) -> nat_add(m, nat_mul(pred, m))
    end
  end
  
  # Convert Nat to Int
  def nat_to_int(n: Nat): Int do
    match n do
      Zero -> 0
      Succ(pred) -> 1 + nat_to_int(pred)
    end
  end
  
  # Matrix type - 2D vector with dependent dimensions
  type Matrix(T, rows: Nat, cols: Nat) = Vector(Vector(T, cols), rows)
  
  # Create a 2x2 matrix
  def make_matrix_2x2<T>(a: T, b: T, c: T, d: T): Matrix(T, 2, 2) do
    [[a, b], [c, d]]
  end
  
  def main(): Int do
    let v3 = make_vector3(1, 2, 3) in
    let v2 = make_pair(4, 5) in
    let combined = vector_append(v3, v2) in  # Type: Vector(Int, 5)
    
    let head = safe_head(v3) in
    
    let n1 = nat_one() in
    let n2 = nat_two() in
    let n3 = nat_add(n1, n2) in
    let n3_int = nat_to_int(n3) in
    
    let matrix = make_matrix_2x2(1, 2, 3, 4) in
    
    0
  end
end
