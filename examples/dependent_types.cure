# Dependent Types Example Program

# Vector with length encoded in the type
def vector_length(v: Vector(T, n: Nat)): Nat = n

# Safe array access - no bounds checking needed at runtime
def safe_get(arr: Array(T, n: Nat), index: Nat): T when index < n =
  arr[index]

# List operations that preserve length information  
def map_preserving_length(f: T -> U, list: List(T, n)): List(U, n) =
  match list do
    [] -> []
    [x|xs] -> [f(x) | map_preserving_length(f, xs)]
  end

# Matrix operations with dimension checking
def matrix_multiply(a: Matrix(m, n, T), b: Matrix(n, p, T)): Matrix(m, p, T) =
  # Implementation would be here - type system ensures dimensions match
  builtin_matrix_multiply(a, b)

# Natural number arithmetic that preserves positivity
def add_natural(x: Nat, y: Nat): Nat = x + y
def add_positive(x: Pos, y: Pos): Pos = x + y

# Length-preserving zip function
def zip(xs: List(T, n), ys: List(U, n)): List({T, U}, n) =
  match xs, ys do
    [], [] -> []
    [x|xs_rest], [y|ys_rest] -> [{x, y} | zip(xs_rest, ys_rest)]
  end

# Factorial that returns a positive number for positive input
def factorial(n: Pos): Pos =
  if n == 1 then 1 else n * factorial(n - 1)

# Safe head function - type system guarantees non-empty list
def head(list: List(T, n)) -> T when n > 0 =
  match list do
    [x|_] -> x
    # No need for empty case - type system prevents it
  end

# String operations with length tracking
def concat_strings(s1: String(n), s2: String(m)): String(n + m) =
  s1 ++ s2

# Main function demonstrating dependent types
def main() =
  let numbers = [1, 2, 3, 4, 5]  # List(Int, 5)
  let doubled = map_preserving_length(x -> x * 2, numbers)  # List(Int, 5)
  let length = vector_length(doubled)  # Nat (specifically 5)
  
  # Safe operations - no runtime bounds checking needed
  let first = head(doubled)  # Type system ensures list is non-empty
  let sum = add_natural(length, 10)  # Nat + Nat = Nat
  
  # Matrix example (would need matrix literals in full implementation)
  # let matrix_a = [[1, 2], [3, 4]]  # Matrix(2, 2, Int)
  # let matrix_b = [[5, 6], [7, 8]]  # Matrix(2, 2, Int) 
  # let result = matrix_multiply(matrix_a, matrix_b)  # Matrix(2, 2, Int)
  
  {first, sum, length}