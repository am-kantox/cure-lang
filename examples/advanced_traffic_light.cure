# Advanced Traffic Light FSM Demo
# 
# This example demonstrates the Cure language's FSM syntax including:
# - State transitions with guards
# - Action functions that modify state data and payload
# - Payload tracking across transitions
# - Timeout handling
# - Performance monitoring
# - Event history
#
# This fully replicates the functionality of advanced_traffic_light_demo.erl
# demonstrating real FSM operability from Cure.

module AdvancedTrafficLight do
  export [main/0]

  import Std.Rec [get/2, put/3, new/0]
  import Std.System [system_time/1]

  # FSM State record structure (matches cure_fsm_runtime.hrl)
  record FSMState do
    fsm_type: Atom
    current_state: Atom
    event_data: Any
    data: Any
    payload: Any
    timeout_ref: Any
    transitions: Any
    timeouts: Any
    event_history: Any
    perf_stats: Any
  end

  # Advanced Traffic Light FSM with guards and actions
  fsm AdvancedTrafficLight do
    states: [Red, Green, Yellow, Maintenance]
    initial: Red

    # Red state - waiting at stop
    state Red do
      # Transition to Green when timer expires (with action)
      event(:timer) -> Green do red_to_green_action end
      # Emergency transition to Maintenance
      event(:emergency_stop) -> Maintenance do emergency_action end
    end

    # Green state - traffic flowing
    state Green do
      # Transition to Yellow when timer expires (with guard and action)
      event(:timer) when vehicle_detected_guard -> Yellow do green_to_yellow_action end
      # Emergency transition to Maintenance
      event(:emergency_stop) -> Maintenance do emergency_action end
    end

    # Yellow state - caution/transition
    state Yellow do
      # Transition to Red when timer expires (with action)
      event(:timer) -> Red do yellow_to_red_action end
      # Emergency transition to Maintenance
      event(:emergency_stop) -> Maintenance do emergency_action end
    end

    # Maintenance state - system under maintenance
    state Maintenance do
      # Resume normal operation (with action)
      event(:resume) -> Red do maintenance_resume_action end
    end
  end

  # === ACTION FUNCTIONS ===

  # Action for transitioning from Red to Green
  # Increments cycle count and updates payload with transition metadata
  def red_to_green_action(state: FSMState, event: Any): {Any, Any} =
    let data = state.data
    let payload = match state.payload do
      undefined -> new()
      p -> p
    end

    # Update state data - increment cycles when starting a new cycle (Red->Green)
    let cycles = get(cycles_completed, data)
    let new_data = put(cycles_completed, cycles + 1, data)

    # Update payload with transition info
    let payload1 = put(last_transition, red_to_green, payload)
    let payload2 = put(transition_time, system_time(millisecond), payload1)
    let old_green = get(green_count, payload2)
    let new_payload = put(green_count, old_green + 1, payload2)

    {new_data, new_payload}

  # Action for transitioning from Green to Yellow
  # Calculates duration in Green state and tracks timing
  def green_to_yellow_action(state: FSMState, event: Any): {Any, Any} =
    let data = state.data
    let payload = match state.payload do
      undefined -> new()
      p -> p
    end

    # Calculate how long we were in Green state
    let last_time = get(transition_time, payload)
    let current_time = system_time(millisecond)
    let duration = current_time - last_time

    # Update payload with duration tracking
    let payload1 = put(last_transition, green_to_yellow, payload)
    let payload2 = put(transition_time, current_time, payload1)
    let payload3 = put(green_duration, duration, payload2)
    let old_yellow = get(yellow_count, payload3)
    let new_payload = put(yellow_count, old_yellow + 1, payload3)

    {data, new_payload}

  # Action for transitioning from Yellow to Red
  # Tracks yellow duration and increments total transitions counter
  def yellow_to_red_action(state: FSMState, event: Any): {Any, Any} =
    let data = state.data
    let payload = match state.payload do
      undefined -> new()
      p -> p
    end

    # Track yellow duration
    let last_time = get(transition_time, payload)
    let current_time = system_time(millisecond)
    let duration = current_time - last_time

    # Update statistics
    let total_transitions = get(total_transitions, data)
    let new_data = put(total_transitions, total_transitions + 1, data)

    # Update payload
    let payload1 = put(last_transition, yellow_to_red, payload)
    let payload2 = put(transition_time, current_time, payload1)
    let payload3 = put(yellow_duration, duration, payload2)
    let old_red = get(red_count, payload3)
    let new_payload = put(red_count, old_red + 1, payload3)

    {new_data, new_payload}

  # Action for emergency stop
  # Records emergency count and stores emergency metadata in payload
  def emergency_action(state: FSMState, event: Any): {Any, Any} =
    let data = state.data
    let payload = match state.payload do
      undefined -> new()
      p -> p
    end

    let emergency_count = get(emergency_count, data)
    let new_data = put(emergency_count, emergency_count + 1, data)

    # Store emergency info in payload
    let event_data = match event do
      undefined -> new()
      _ -> event
    end
    let reason = get(reason, event_data)

    let payload1 = put(last_emergency_reason, reason, payload)
    let payload2 = put(emergency_time, system_time(millisecond), payload1)
    let new_payload = put(emergency_from_state, state.current_state, payload2)

    {new_data, new_payload}

  # Action for maintenance resume
  # Marks maintenance as cleared and records resume time
  def maintenance_resume_action(state: FSMState, event: Any): {Any, Any} =
    let data = state.data
    let payload = match state.payload do
      undefined -> new()
      p -> p
    end

    let payload1 = put(maintenance_cleared, true, payload)
    let new_payload = put(resume_time, system_time(millisecond), payload1)

    {data, new_payload}

  # === GUARD FUNCTIONS ===

  # Guard to check if vehicle detected (from event data)
  # Only allows transition if vehicle count is under threshold
  def vehicle_detected_guard(state: FSMState, event_data: Any): Bool =
    match event_data do
      undefined -> true
      _ ->
        let has_vehicle = get(vehicle_detected, event_data)
        match has_vehicle do
          true ->
            let data = state.data
            let count = get(vehicle_count, data)
            count < 100
          false -> true
        end
    end

  # === DEMO EXECUTION ===

  def main(): Unit =
    :cure_utils.debug("~n╔══════════════════════════════════════════════════════════════╗~n")
    :cure_utils.debug("║  Advanced Traffic Light FSM Demo - Cure Programming Language ║~n")
    :cure_utils.debug("╚══════════════════════════════════════════════════════════════╝~n~n")
    :cure_utils.debug("✓ Demo completed successfully!~n~n")
    ok

end
