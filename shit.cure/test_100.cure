# Dependent Types Examples in Cure
# Demonstrates compile-time guarantees, length-indexed vectors, matrices, and type safety

module DependentTypes do
  export [demo_all/0, vector_operations/0, matrix_operations/0, safe_operations/0]

  # Import standard types
  import Std [List, Result]

  # === LENGTH-INDEXED VECTORS ===

  # Vector type parameterized by length and element type
  # Vector(T, n: Nat) ensures vectors always have exactly n elements

  # Create vectors with known lengths
  def make_vec3(x: Float, y: Float, z: Float): Vector(Float, 3) =
    [x, y, z]

  def make_vec4(x: Float, y: Float, z: Float, w: Float): Vector(Float, 4) =
    [x, y, z, w]

  # Safe vector operations - length checked at compile time
  def dot_product(v1: Vector(Float, n), v2: Vector(Float, n)): Float =
    # The type system guarantees v1 and v2 have the same length
    (zip_with(v1, v2, fn(x, y) -> x * y end)
    |> fold(0.0, fn(x, acc) -> acc + x end))

  def vector_add(v1: Vector(Float, n), v2: Vector(Float, n)): Vector(Float, n) =
    # Type system ensures result has the same length as inputs
    zip_with(v1, v2, fn(x, y) -> x + y end)

  def vector_scale(scalar: Float, v: Vector(Float, n)): Vector(Float, n) =
    map(v, fn(x) -> scalar * x end)

  # === LENGTH-INDEXED LISTS ===

  # Lists with compile-time known lengths
  def safe_head(list: List(T, n)) -> T when n > 0 =
    # Type system guarantees list is non-empty
    match list do
      [x | _] -> x
      # No need for empty case - type system prevents it
    end

  def safe_tail(list: List(T, n)) -> List(T, n-1) when n > 0 =
    match list do
      [_ | tail] -> tail
      # No need for empty case - type system prevents it
    end

  # Append with length tracking
  def append(xs: List(T, n), ys: List(T, m)): List(T, n + m) =
    match xs do
      [] -> ys
      [x | rest] -> [x | append(rest, ys)]
    end

  # Take with compile-time bounds checking
  def safe_take(list: List(T, n), k: Nat): List(T, k) when k <= n =
    # Type system ensures we can't take more elements than available
    take(list, k)

  # === MATRIX OPERATIONS WITH DIMENSION CHECKING ===

  # Matrix type with compile-time dimension checking
  record Matrix(rows: Nat, cols: Nat, T) do
    data: Vector(Vector(T, cols), rows)
  end

  # Create matrices with known dimensions
  def make_matrix_2x3(): Matrix(2, 3, Float) =
    Matrix{
      data: [
        [1.0, 2.0, 3.0],
        [4.0, 5.0, 6.0]
      ]
    }

  def make_identity_3x3(): Matrix(3, 3, Float) =
    Matrix{
      data: [
        [1.0, 0.0, 0.0],
        [0.0, 1.0, 0.0],
        [0.0, 0.0, 1.0]
      ]
    }

  # Matrix multiplication with dimension checking
  # Can only multiply m×n matrix by n×p matrix, result is m×p
  def matrix_multiply(
    a: Matrix(m, n, T), 
    b: Matrix(n, p, T)
  ): Matrix(m, p, T) = 
    # Type system ensures dimensions are compatible
    let result_rows = map_with_index(a.data, fn(row, i) ->
      map_with_index(transpose(b.data), fn(col, j) ->
        dot_product(row, col)
      end)
    end)
    Matrix{data: result_rows}
end
