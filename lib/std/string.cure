# String Standard Library Module
# Provides string manipulation and conversion functions for the Cure language.
#
# This module operates on three related types:
#   - String: UTF-8 encoded binary (default string type)
#   - Charlist: List of Unicode codepoints
#   - Binary: Raw bytes (may or may not be valid UTF-8)

module String do
  export [
    to_charlist/1, from_charlist/1, to_binary/1, from_binary/1, to_atom/1,
    concat/2, length/1, byte_size/1, is_empty/1,
    slice/3, at/2, first/1, last/1,
    split/2, split_at/2, join/2,
    trim/1, trim_left/1, trim_right/1,
    upcase/1, downcase/1, capitalize/1,
    starts_with/2, ends_with/2, contains/2,
    replace/3, replace_all/3,
    graphemes/1, codepoints/1, valid_utf8/1,
    reverse/1, duplicate/2, pad_left/3, pad_right/3,
    all_of/2, any_of/2, filter/2, map/2,
    lines/1, unlines/1, words/1, unwords/1
  ]

# ============================================================================
# Type Conversions
# ============================================================================

  # Convert a String to a Charlist
  curify to_charlist(s: String): Charlist = {cure_string_native, to_charlist, 1}

  # Convert a Charlist to a String
  curify from_charlist(chars: Charlist): String = {cure_string_native, from_charlist, 1}

  # Convert a String to a Binary (identity, but explicit)
  curify to_binary(s: String): Binary = {cure_string_native, to_binary, 1}

  # Convert a Binary to a String (validates UTF-8)
  # Returns: {ok, String} | {error, :invalid_utf8}
  curify from_binary(bin: Binary): Result(String, Atom) = {cure_string_native, from_binary, 1}

  # Convert a String to an Atom
  curify to_atom(s: String): Atom = {cure_string_native, to_atom, 1}

# ============================================================================
# Core String Operations
# ============================================================================

  # Concatenate two strings (alternative to <> operator)
  curify concat(s1: String, s2: String): String = {cure_string_native, concat, 2}

  # Get the length of a string in graphemes (Unicode-aware)
  curify length(s: String): Int = {cure_string_native, length, 1}

  # Get the byte size of a string
  curify byte_size(s: String): Int = {cure_string_native, byte_size, 1}

  # Check if a string is empty
  def is_empty(s: String): Bool do
    match s do
      "" -> true
      _ -> false
    end
  end

# ============================================================================
# String Manipulation
# ============================================================================

  # Extract a substring by grapheme position and length
  # slice("hello", 1, 3) => "ell"
  curify slice(s: String, start: Int, len: Int): String = {cure_string_native, slice, 3}

  # Get the grapheme at a specific index (0-based)
  # Returns: {ok, String} | {error, :out_of_bounds}
  curify at(s: String, index: Int): Result(String, Atom) = {cure_string_native, at, 2}

  # Get the first grapheme of a string
  # Returns: {ok, String} | {error, :empty_string}
  curify first(s: String): Result(String, Atom) = {cure_string_native, first, 1}

  # Get the last grapheme of a string
  # Returns: {ok, String} | {error, :empty_string}
  curify last(s: String): Result(String, Atom) = {cure_string_native, last, 1}

# ============================================================================
# Splitting and Joining
# ============================================================================

  # Split a string by a pattern
  # split("a,b,c", ",") => ["a", "b", "c"]
  curify split(s: String, pattern: String): List(String) = {cure_string_native, split, 2}

  # Split a string at a specific grapheme index
  # split_at("hello", 2) => {"he", "llo"}
  curify split_at(s: String, index: Int): Pair(String, String) = {cure_string_native, split_at, 2}

  # Join a list of strings with a separator
  # join(["a", "b", "c"], ",") => "a,b,c"
  curify join(strings: List(String), sep: String): String = {cure_string_native, join, 2}

# ============================================================================
# Trimming
# ============================================================================

  # Trim whitespace from both ends of a string
  curify trim(s: String): String = {cure_string_native, trim, 1}

  # Trim whitespace from the left side of a string
  curify trim_left(s: String): String = {cure_string_native, trim_left, 1}

  # Trim whitespace from the right side of a string
  curify trim_right(s: String): String = {cure_string_native, trim_right, 1}

# ============================================================================
# Case Transformations
# ============================================================================

  # Convert string to uppercase (Unicode-aware)
  curify upcase(s: String): String = {cure_string_native, upcase, 1}

  # Convert string to lowercase (Unicode-aware)
  curify downcase(s: String): String = {cure_string_native, downcase, 1}

  # Capitalize the first grapheme of a string
  curify capitalize(s: String): String = {cure_string_native, capitalize, 1}

# ============================================================================
# Predicates
# ============================================================================

  # Check if a string starts with a given prefix
  curify starts_with(s: String, prefix: String): Bool = {cure_string_native, starts_with, 2}

  # Check if a string ends with a given suffix
  curify ends_with(s: String, suffix: String): Bool = {cure_string_native, ends_with, 2}

  # Check if a string contains a substring
  curify contains(s: String, substring: String): Bool = {cure_string_native, contains, 2}

# ============================================================================
# Pattern Matching and Replacement
# ============================================================================

  # Replace the first occurrence of a pattern
  # replace("hello world", "world", "cure") => "hello cure"
  curify replace(s: String, pattern: String, replacement: String): String = {cure_string_native, replace, 3}

  # Replace all occurrences of a pattern
  # replace_all("aaa", "a", "b") => "bbb"
  curify replace_all(s: String, pattern: String, replacement: String): String = {cure_string_native, replace_all, 3}

# ============================================================================
# Unicode Operations
# ============================================================================

  # Split a string into a list of grapheme clusters
  # graphemes("hello") => ["h", "e", "l", "l", "o"]
  # graphemes("ðŸ‘¨â€ðŸ‘©â€ðŸ‘§â€ðŸ‘¦") => ["ðŸ‘¨â€ðŸ‘©â€ðŸ‘§â€ðŸ‘¦"] (single grapheme cluster)
  curify graphemes(s: String): List(String) = {cure_string_native, graphemes, 1}

  # Get a list of Unicode codepoints from a string
  # codepoints("hello") => [104, 101, 108, 108, 111]
  curify codepoints(s: String): List(Int) = {cure_string_native, codepoints, 1}

  # Check if a binary is valid UTF-8
  curify valid_utf8(bin: Binary): Bool = {cure_string_native, valid_utf8, 1}

# ============================================================================
# Utilities
# ============================================================================

  # Reverse a string (Unicode-aware, reverses graphemes)
  curify reverse(s: String): String = {cure_string_native, reverse, 1}

  # Duplicate a string n times
  # duplicate("ab", 3) => "ababab"
  curify duplicate(s: String, n: Int): String = {cure_string_native, duplicate, 2}

  # Pad a string on the left to a given width
  # pad_left("hi", 5, " ") => "   hi"
  curify pad_left(s: String, width: Int, padding: String): String = {cure_string_native, pad_left, 3}

  # Pad a string on the right to a given width
  # pad_right("hi", 5, " ") => "hi   "
  curify pad_right(s: String, width: Int, padding: String): String = {cure_string_native, pad_right, 3}

# ============================================================================
# Convenience Functions
# ============================================================================

  # Check if all strings match the condition
  # all_of(["test", "best"], fn(s) -> starts_with(s, "t") end) => false
  def all_of(strings: List(String), pred: String -> Bool): Bool do
    match strings do
      [] -> true
      [h | t] ->
        match pred(h) do
          true -> all_of(t, pred)
          false -> false
        end
    end
  end

  # Check if any string matches the condition
  # any_of(["test", "best"], fn(s) -> starts_with(s, "t") end) => true
  def any_of(strings: List(String), pred: String -> Bool): Bool do
    match strings do
      [] -> false
      [h | t] ->
        match pred(h) do
          true -> true
          false -> any_of(t, pred)
        end
    end
  end

  # Filter strings by a predicate
  def filter(strings: List(String), pred: String -> Bool): List(String) do
    match strings do
      [] -> []
      [h | t] ->
        let rest = filter(t, pred) in
        match pred(h) do
          true -> [h | rest]
          false -> rest
        end
    end
  end

  # Map a function over a list of strings
  def map(strings: List(String), f: String -> String): List(String) do
    match strings do
      [] -> []
      [h | t] -> [f(h) | map(t, f)]
    end
  end

# ============================================================================
# Helper Functions
# ============================================================================

  # Lines - split by newline
  def lines(s: String): List(String) do
    split(s, "\n")
  end

  # Unlines - join with newline
  def unlines(strings: List(String)): String do
    join(strings, "\n")
  end

  # Words - split by whitespace (simplified version)
  def words(s: String): List(String) do
    split(trim(s), " ")
  end

  # Unwords - join with space
  def unwords(strings: List(String)): String do
    join(strings, " ")
  end
end
