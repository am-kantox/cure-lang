module Std.List do
  export [
    # Basic operations
    length/1, is_empty/1, head/1, tail/1,
    # Construction
    cons/2, append/2, reverse/1,
    # Transformation
    map/2, filter/2, fold_left/3, fold_right/3,
    # Access
    nth/2, take/2, drop/2,
    # Predicates
    all/2, any/2, contains/2,
    # Safe operations
    safe_head/1, safe_tail/1, safe_nth/2
  ]

  # Basic operations (from working version)
  defp length_helper(list: List(T), acc: Int): Int =
    match list do
      [] -> acc
      [_ | t] -> length_helper(t, acc + 1)
    end

  def length(list: List(T)): Int =
    length_helper(list, 0)

  def is_empty(list: List(T)): Bool =
    match list do
      [] -> true
      _ -> false
    end

  def head(list: List(T)): T =
    match list do
      [h | _] -> h
    end

  def tail(list: List(T)): List(T) =
    match list do
      [_ | t] -> t
    end

  # Construction
  def cons(element: T, list: List(T)): List(T) =
    [element | list]

  def append(list1: List(T), list2: List(T)): List(T) =
    match list1 do
      [] -> list2
      [h | t] -> [h | append(t, list2)]
    end

  def reverse(list: List(T)): List(T) =
    reverse_helper(list, [])

  defp reverse_helper(list: List(T), acc: List(T)): List(T) =
    match list do
      [] -> acc
      [h | t] -> reverse_helper(t, [h | acc])
    end

  # Transformation
  def map(list: List(T), f: T -> U): List(U) =
    match list do
      [] -> []
      [h | t] -> [f(h) | map(t, f)]
    end

  def filter(list: List(T), predicate: T -> Bool): List(T) =
    match list do
      [] -> []
      [h | t] -> 
        let filtered_tail = filter(t, predicate)
        if predicate(h) then [h | filtered_tail]
        else filtered_tail
        end
    end

  def fold_left(list: List(T), acc: U, f: T -> U -> U): U =
    match list do
      [] -> acc
      [h | t] -> fold_left(t, f(h, acc), f)
    end

  def fold_right(list: List(T), acc: U, f: T -> U -> U): U =
    match list do
      [] -> acc
      [h | t] -> f(h, fold_right(t, acc, f))
    end

  # Access
  def nth(list: List(T), index: Int): T =
    if index == 0 then head(list)
    else nth(tail(list), index - 1)
    end

  def take(list: List(T), n: Int): List(T) =
    if n <= 0 then []
    else
      match list do
        [] -> []
        [h | t] -> [h | take(t, n - 1)]
      end
    end

  def drop(list: List(T), n: Int): List(T) =
    if n <= 0 then list
    else
      match list do
        [] -> []
        [_ | t] -> drop(t, n - 1)
      end
    end

  # Predicates
  def all(list: List(T), predicate: T -> Bool): Bool =
    match list do
      [] -> true
      [h | t] -> 
        if predicate(h) then all(t, predicate)
        else false
        end
    end

  def any(list: List(T), predicate: T -> Bool): Bool =
    match list do
      [] -> false
      [h | t] ->
        if predicate(h) then true
        else any(t, predicate)
        end
    end

  def contains(list: List(T), element: T): Bool =
    match list do
      [] -> false
      [h | t] ->
        if h == element then true
        else contains(t, element)
        end
    end

  # Safe operations (returning Options - simplified without Option import)
  def safe_head(list: List(T)): T =
    # Simplified - would return Option(T) in real implementation
    match list do
      [] -> get_default_value()
      [h | _] -> h
    end

  def safe_tail(list: List(T)): List(T) =
    # Simplified - would return Option(List(T)) in real implementation
    match list do
      [] -> []
      [_ | t] -> t
    end

  def safe_nth(list: List(T), index: Int): T =
    # Simplified - would return Option(T) in real implementation
    if index < 0 then get_default_value()
    else
      match list do
        [] -> get_default_value()
        [h | t] ->
          if index == 0 then h
          else safe_nth(t, index - 1)
          end
      end
    end

  # Helper for default values - simplified
  defp get_default_value(): T =
    0  # Placeholder - won't work for all types
end