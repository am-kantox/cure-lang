# Cure Standard Library - FSM Module
# High-level FSM utilities and first-class finite state machine support

module Std.FSM do
  import Std.Core [Option, Result, some, none, ok, error]
  import Std.List [map, foldl, filter]
  import Std.Process [Pid, spawn, send, receive]
  import Std.Time [current_time, timestamp]

  export [
    # Core FSM types
    FSMRef, FSMState, FSMEvent, FSMData, FSMInfo, FSMStats,
    FSMTransition, FSMDefinition, FSMTimeout,
    
    # FSM creation and management
    create/2, create/3, start/1, start_with_data/2, stop/1,
    spawn_fsm/1, spawn_fsm/2,
    
    # FSM state queries and manipulation
    current_state/1, get_data/1, set_data/2,
    get_all_states/1,
    
    # FSM event handling
    send_event/2, send_event/3, send_event_sync/2, send_event_sync/3,
    send_batch_events/2, send_events/2,
    
    # FSM monitoring and debugging
    get_info/1, get_history/1, get_stats/1, is_alive/1,
    get_performance_stats/1, reset_stats/1,
    
    # FSM coordination and supervision
    link_fsm/1, unlink_fsm/1, monitor_fsm/1,
    broadcast_event/2, multicast_event/2,
    
    # FSM timeout management
    set_timeout/3, clear_timeout/1, get_timeouts/1,
    
    # FSM validation and introspection
    validate_fsm_type/1, validate_event/2,
    list_registered_types/0, get_fsm_definition/1,
    
    # Common FSM patterns and utilities
    create_counter/1, create_counter/2,
    create_toggle/1, create_toggle/2,
    create_timer/2, create_timer/3,
    create_state_machine/3, create_workflow/2,
    
    # FSM composition and hierarchical FSMs
    create_composite_fsm/2, add_sub_fsm/3, remove_sub_fsm/2
  ]

  # =============================================================================
  # Core FSM Type Definitions
  # =============================================================================

  # Reference to an FSM process (wraps Erlang Pid)
  type FSMRef = Pid
  
  # FSM state identifier
  type FSMState = Atom
  
  # FSM events - can be simple atoms or structured data
  type FSMEvent = 
    | Atom                    # Simple event: :start, :stop, etc.
    | {Atom, Any}            # Event with data: {:data, payload}
    | {Atom, Atom, Any}      # Event with type and data: {:input, :key_press, 'a'}
  
  # FSM state data - arbitrary term
  type FSMData = Any
  
  # FSM transition specification
  type FSMTransition = {
    from: FSMState,           # Source state
    event: FSMEvent,          # Triggering event
    to: FSMState,            # Target state
    guard: Option(Function), # Optional guard condition
    action: Option(Function) # Optional action to execute
  }
  
  # FSM timeout specification
  type FSMTimeout = {
    state: FSMState,         # State where timeout applies
    duration: Int,           # Timeout duration in milliseconds
    event: FSMEvent         # Event to send when timeout occurs
  }
  
  # Compiled FSM definition
  type FSMDefinition = {
    name: Atom,              # FSM type name
    states: List(FSMState),  # All possible states
    initial_state: FSMState, # Initial state
    transitions: Map({FSMState, FSMEvent}, {FSMState, Option(Function), Option(Function)}),
    timeouts: Map(FSMState, {Int, FSMEvent})
  }
  
  # FSM runtime information
  type FSMInfo = {
    fsm_type: Atom,
    current_state: FSMState,
    data: FSMData,
    start_time: Int,
    uptime: Int,
    events_processed: Int,
    last_event: Option(FSMEvent),
    last_transition: Option({FSMState, FSMState, Int})
  }
  
  # FSM performance statistics
  type FSMStats = {
    events_processed: Int,
    avg_event_time: Float,
    max_event_time: Float,
    min_event_time: Float,
    state_distribution: Map(FSMState, Int),
    transition_count: Map({FSMState, FSMState}, Int),
    error_count: Int,
    last_reset: Int
  }

  # =============================================================================
  # FSM Creation and Management
  # =============================================================================

  def create(fsm_type: Atom, initial_data: FSMData): Result(FSMRef, String) =
    "Create FSM instance with specified type and initial data"
    match validate_fsm_type(fsm_type) do
      Ok(_) ->
        try
          let fsm_pid = fsm_spawn(fsm_type, initial_data)
          ok(fsm_pid)
        catch
          error -> error("Failed to create FSM: " ++ show(error))
        end
      Error(reason) -> error(reason)
    end

  def create(fsm_type: Atom, initial_data: FSMData, options: List(Any)): Result(FSMRef, String) =
    "Create FSM instance with specified type, initial data, and options"
    match validate_fsm_type(fsm_type) do
      Ok(_) ->
        try
          let fsm_pid = fsm_spawn_with_options(fsm_type, initial_data, options)
          ok(fsm_pid)
        catch
          error -> error("Failed to create FSM with options: " ++ show(error))
        end
      Error(reason) -> error(reason)
    end

  def start(fsm_type: Atom): Result(FSMRef, String) =
    "Start FSM instance with default initial data"
    create(fsm_type, {})

  def start_with_data(fsm_type: Atom, data: FSMData): Result(FSMRef, String) =
    "Start FSM instance with specified initial data"
    create(fsm_type, data)

  def spawn_fsm(fsm_type: Atom): Result(FSMRef, String) =
    "Spawn FSM instance (alias for start/1)"
    start(fsm_type)

  def spawn_fsm(fsm_type: Atom, initial_data: FSMData): Result(FSMRef, String) =
    "Spawn FSM instance with initial data (alias for create/2)"
    create(fsm_type, initial_data)

  def stop(fsm: FSMRef): Result(Unit, String) =
    "Stop FSM instance gracefully"
    try
      fsm_stop(fsm)
      ok(unit)
    catch
      error -> error("Failed to stop FSM: " ++ show(error))
    end

  # =============================================================================
  # FSM State Queries and Manipulation
  # =============================================================================

  def current_state(fsm: FSMRef): Result(FSMState, String) =
    "Get current state of FSM"
    try
      let state = fsm_state(fsm)
      ok(state)
    catch
      error -> error("Failed to get FSM state: " ++ show(error))
    end

  def get_data(fsm: FSMRef): Result(FSMData, String) =
    "Get current data of FSM"
    match get_info(fsm) do
      Ok(info) -> ok(info.data)
      Error(err) -> error(err)
    end

  def set_data(fsm: FSMRef, new_data: FSMData): Result(Unit, String) =
    "Set FSM data (if supported by FSM implementation)"
    try
      fsm_set_data(fsm, new_data)
      ok(unit)
    catch
      error -> error("Failed to set FSM data: " ++ show(error))
    end

  def get_all_states(fsm: FSMRef): Result(List(FSMState), String) =
    "Get all possible states for this FSM type"
    match get_info(fsm) do
      Ok(info) ->
        match get_fsm_definition(info.fsm_type) do
          Ok(definition) -> ok(definition.states)
          Error(err) -> error(err)
        end
      Error(err) -> error(err)
    end

  # =============================================================================
  # FSM Event Handling
  # =============================================================================

  def send_event(fsm: FSMRef, event: FSMEvent): Result(Unit, String) =
    "Send event to FSM asynchronously"
    try
      fsm_send(fsm, event)
      ok(unit)
    catch
      error -> error("Failed to send event: " ++ show(error))
    end

  def send_event(fsm: FSMRef, event: FSMEvent, data: Any): Result(Unit, String) =
    "Send event with data to FSM asynchronously"
    try
      fsm_send(fsm, event, data)
      ok(unit)
    catch
      error -> error("Failed to send event with data: " ++ show(error))
    end

  def send_event_sync(fsm: FSMRef, event: FSMEvent): Result(FSMState, String) =
    "Send event to FSM synchronously and wait for new state"
    match send_event(fsm, event) do
      Ok(_) ->
        # Wait briefly and get new state (simplified implementation)
        timer_sleep(10)
        current_state(fsm)
      Error(err) -> error(err)
    end

  def send_event_sync(fsm: FSMRef, event: FSMEvent, timeout: Int): Result(FSMState, String) =
    "Send event to FSM synchronously with timeout"
    let initial_state = match current_state(fsm) do
      Ok(state) -> some(state)
      Error(_) -> none()
    end
    
    match send_event(fsm, event) do
      Ok(_) ->
        wait_for_state_change(fsm, initial_state, timeout)
      Error(err) -> error(err)
    end

  def send_batch_events(fsm: FSMRef, events: List(FSMEvent)): Result(Unit, String) =
    "Send multiple events to FSM efficiently"
    try
      fsm_send_batch(fsm, events)
      ok(unit)
    catch
      error -> error("Failed to send batch events: " ++ show(error))
    end

  def send_events(fsm: FSMRef, events: List(FSMEvent)): Result(List(Result(Unit, String)), String) =
    "Send multiple events individually and collect results"
    let results = map(events, fn(event) -> send_event(fsm, event) end)
    ok(results)

  # =============================================================================
  # FSM Monitoring and Debugging
  # =============================================================================

  def get_info(fsm: FSMRef): Result(FSMInfo, String) =
    "Get comprehensive FSM information"
    try
      let info_result = fsm_info(fsm)
      match info_result do
        {ok, info_map} ->
          let fsm_info = {
            fsm_type: map_get(info_map, :fsm_type),
            current_state: map_get(info_map, :current_state),
            data: map_get(info_map, :data),
            start_time: map_get(info_map, :start_time, 0),
            uptime: map_get(info_map, :uptime, 0),
            events_processed: map_get(info_map, :events_processed, 0),
            last_event: some(map_get(info_map, :last_event)),
            last_transition: some(map_get(info_map, :last_transition))
          }
          ok(fsm_info)
        {error, reason} -> error("Failed to get FSM info: " ++ show(reason))
      end
    catch
      error -> error("Failed to get FSM info: " ++ show(error))
    end

  def get_history(fsm: FSMRef): Result(List(Any), String) =
    "Get FSM event history"
    match get_info(fsm) do
      Ok(_) ->
        try
          let history = fsm_history(fsm)
          ok(history)
        catch
          error -> error("Failed to get FSM history: " ++ show(error))
        end
      Error(err) -> error(err)
    end

  def get_stats(fsm: FSMRef): Result(Map(String, Any), String) =
    "Get basic FSM statistics"
    match get_info(fsm) do
      Ok(info) ->
        let stats = #{
          "events_processed" => info.events_processed,
          "uptime" => info.uptime,
          "current_state" => info.current_state,
          "fsm_type" => info.fsm_type
        }
        ok(stats)
      Error(err) -> error(err)
    end

  def get_performance_stats(fsm: FSMRef): Result(FSMStats, String) =
    "Get detailed performance statistics"
    try
      let perf_result = fsm_get_performance_stats(fsm)
      match perf_result do
        {ok, stats} -> ok(stats)
        {error, reason} -> error("Failed to get performance stats: " ++ show(reason))
      end
    catch
      error -> error("Failed to get performance stats: " ++ show(error))
    end

  def reset_stats(fsm: FSMRef): Result(Unit, String) =
    "Reset FSM performance statistics"
    try
      fsm_reset_stats(fsm)
      ok(unit)
    catch
      error -> error("Failed to reset FSM stats: " ++ show(error))
    end

  def is_alive(fsm: FSMRef): Bool =
    "Check if FSM process is alive"
    fsm_is_alive(fsm)

  # =============================================================================
  # FSM Coordination and Supervision
  # =============================================================================

  def link_fsm(fsm: FSMRef): Result(Unit, String) =
    "Link to FSM process for crash propagation"
    try
      fsm_link(fsm)
      ok(unit)
    catch
      error -> error("Failed to link FSM: " ++ show(error))
    end

  def unlink_fsm(fsm: FSMRef): Result(Unit, String) =
    "Unlink from FSM process"
    try
      fsm_unlink(fsm)
      ok(unit)
    catch
      error -> error("Failed to unlink FSM: " ++ show(error))
    end

  def monitor_fsm(fsm: FSMRef): Result(Reference, String) =
    "Monitor FSM process for termination"
    try
      let monitor_ref = fsm_monitor(fsm)
      ok(monitor_ref)
    catch
      error -> error("Failed to monitor FSM: " ++ show(error))
    end

  def broadcast_event(fsms: List(FSMRef), event: FSMEvent): Result(List(Result(Unit, String)), String) =
    "Send event to all FSMs in list"
    let results = map(fsms, fn(fsm) -> send_event(fsm, event) end)
    ok(results)

  def multicast_event(fsms: List(FSMRef), event: FSMEvent): Result(Int, String) =
    "Send event to all FSMs and count successes"
    let results = map(fsms, fn(fsm) -> send_event(fsm, event) end)
    let success_count = foldl(results, 0, fn(result, acc) ->
      match result do
        Ok(_) -> acc + 1
        Error(_) -> acc
      end
    end)
    ok(success_count)

  # =============================================================================
  # FSM Timeout Management
  # =============================================================================

  def set_timeout(fsm: FSMRef, duration: Int, event: FSMEvent): Result(Unit, String) =
    "Set timeout for FSM"
    try
      fsm_set_timeout(fsm, duration, event)
      ok(unit)
    catch
      error -> error("Failed to set FSM timeout: " ++ show(error))
    end

  def clear_timeout(fsm: FSMRef): Result(Unit, String) =
    "Clear any existing FSM timeout"
    try
      fsm_clear_timeout(fsm)
      ok(unit)
    catch
      error -> error("Failed to clear FSM timeout: " ++ show(error))
    end

  def get_timeouts(fsm: FSMRef): Result(Map(FSMState, {Int, FSMEvent}), String) =
    "Get timeout configuration for FSM"
    match get_info(fsm) do
      Ok(info) ->
        match get_fsm_definition(info.fsm_type) do
          Ok(definition) -> ok(definition.timeouts)
          Error(err) -> error(err)
        end
      Error(err) -> error(err)
    end

  # =============================================================================
  # FSM Validation and Introspection
  # =============================================================================

  def validate_fsm_type(fsm_type: Atom): Result(Unit, String) =
    "Validate that FSM type exists and is registered"
    try
      let result = fsm_validate_type(fsm_type)
      match result do
        ok -> ok(unit)
        {error, reason} -> error("FSM type validation failed: " ++ show(reason))
      end
    catch
      error -> error("FSM type validation error: " ++ show(error))
    end

  def validate_event(fsm: FSMRef, event: FSMEvent): Result(Unit, String) =
    "Validate that event is valid for FSM's current state"
    try
      let result = fsm_validate_event(fsm, event)
      match result do
        ok -> ok(unit)
        {warning, _} -> ok(unit)  # Warnings are acceptable
        {error, reason} -> error("Event validation failed: " ++ show(reason))
      end
    catch
      error -> error("Event validation error: " ++ show(error))
    end

  def list_registered_types(): List(Atom) =
    "List all registered FSM types"
    fsm_get_registered_types()

  def get_fsm_definition(fsm_type: Atom): Result(FSMDefinition, String) =
    "Get FSM definition by type name"
    try
      let result = fsm_lookup_definition(fsm_type)
      match result do
        {ok, definition} -> ok(definition)
        {error, not_found} -> error("FSM type not found: " ++ show(fsm_type))
        {error, reason} -> error("Failed to get FSM definition: " ++ show(reason))
      end
    catch
      error -> error("FSM definition lookup error: " ++ show(error))
    end

  # =============================================================================
  # Common FSM Patterns and Utilities
  # =============================================================================

  def create_counter(initial_value: Int): Result(FSMRef, String) =
    "Create a counter FSM with specified initial value"
    let counter_data = #{ value => initial_value }
    create('Counter', counter_data)

  def create_counter(initial_value: Int, max_value: Int): Result(FSMRef, String) =
    "Create a bounded counter FSM"
    let counter_data = #{ value => initial_value, max_value => max_value }
    create('BoundedCounter', counter_data)

  def create_toggle(initial_state: Bool): Result(FSMRef, String) =
    "Create a toggle FSM (on/off state)"
    let toggle_data = #{ state => initial_state }
    create('Toggle', toggle_data)

  def create_toggle(initial_state: Bool, labels: {Atom, Atom}): Result(FSMRef, String) =
    "Create a toggle FSM with custom state labels"
    let {on_label, off_label} = labels
    let toggle_data = #{ 
      state => initial_state,
      on_label => on_label,
      off_label => off_label 
    }
    create('LabeledToggle', toggle_data)

  def create_timer(duration_ms: Int, callback_event: FSMEvent): Result(FSMRef, String) =
    "Create a timer FSM that sends event after duration"
    let timer_data = #{
      duration => duration_ms,
      callback_event => callback_event,
      start_time => current_time()
    }
    create('Timer', timer_data)

  def create_timer(duration_ms: Int, callback_fsm: FSMRef, callback_event: FSMEvent): Result(FSMRef, String) =
    "Create a timer FSM that sends event to another FSM"
    let timer_data = #{
      duration => duration_ms,
      callback_fsm => callback_fsm,
      callback_event => callback_event,
      start_time => current_time()
    }
    create('CallbackTimer', timer_data)

  def create_state_machine(states: List(Atom), initial_state: Atom, transitions: Map({Atom, Atom}, Atom)): Result(FSMRef, String) =
    "Create a generic state machine with specified states and transitions"
    let sm_data = #{
      states => states,
      initial_state => initial_state,
      transitions => transitions,
      current => initial_state
    }
    create('StateMachine', sm_data)

  def create_workflow(steps: List(Atom), data: FSMData): Result(FSMRef, String) =
    "Create a workflow FSM that processes steps sequentially"
    let workflow_data = #{
      steps => steps,
      current_step => 0,
      total_steps => length(steps),
      data => data
    }
    create('Workflow', workflow_data)

  # =============================================================================
  # FSM Composition and Hierarchical FSMs
  # =============================================================================

  def create_composite_fsm(name: Atom, sub_fsms: List({Atom, Atom})): Result(FSMRef, String) =
    "Create a composite FSM that manages multiple sub-FSMs"
    let composite_data = #{
      name => name,
      sub_fsms => #{},
      sub_fsm_specs => sub_fsms
    }
    create('CompositeFSM', composite_data)

  def add_sub_fsm(composite: FSMRef, name: Atom, fsm_type: Atom): Result(Unit, String) =
    "Add a sub-FSM to a composite FSM"
    send_event(composite, {:add_sub_fsm, name, fsm_type})

  def remove_sub_fsm(composite: FSMRef, name: Atom): Result(Unit, String) =
    "Remove a sub-FSM from a composite FSM"
    send_event(composite, {:remove_sub_fsm, name})

  # =============================================================================
  # Internal Helper Functions
  # =============================================================================

  defp wait_for_state_change(fsm: FSMRef, initial_state: Option(FSMState), timeout: Int): Result(FSMState, String) =
    "Wait for FSM state to change within timeout"
    let start_time = current_time()
    wait_for_change_loop(fsm, initial_state, start_time, timeout)

  defp wait_for_change_loop(fsm: FSMRef, initial_state: Option(FSMState), start_time: Int, timeout: Int): Result(FSMState, String) =
    let current_time_val = current_time()
    
    if current_time_val - start_time >= timeout then
      error("timeout")
    else
      match current_state(fsm) do
        Ok(new_state) ->
          match initial_state do
            Some(old_state) ->
              if new_state != old_state then
                ok(new_state)
              else
                timer_sleep(10)
                wait_for_change_loop(fsm, initial_state, start_time, timeout)
              end
            None -> ok(new_state)
          end
        Error(reason) -> error(reason)
      end
    end

  defp map_get(map: Map(Any, Any), key: Any): Any =
    "Get value from map with default"
    map_get(map, key, undefined)

  defp map_get(map: Map(Any, Any), key: Any, default: Any): Any =
    "Get value from map with specified default"
    case maps_find(key, map) do
      {ok, value} -> value
      error -> default
    end

  defp timer_sleep(ms: Int): Unit =
    "Sleep for specified milliseconds"
    erlang_timer_sleep(ms)

  defp unit(): Unit = {}
  defp show(term: Any): String = erlang_term_to_string(term)
  defp length(list: List(Any)): Int = erlang_length(list)

  # =============================================================================
  # Erlang FFI Declarations
  # =============================================================================
  
  # These functions interface with the Erlang FSM runtime
  external fsm_spawn/2 :: (Atom, Any) -> Pid
  external fsm_spawn_with_options/3 :: (Atom, Any, List(Any)) -> Pid
  external fsm_stop/1 :: (Pid) -> Unit
  external fsm_send/2 :: (Pid, Any) -> Unit
  external fsm_send/3 :: (Pid, Any, Any) -> Unit
  external fsm_send_batch/2 :: (Pid, List(Any)) -> Unit
  external fsm_state/1 :: (Pid) -> Atom
  external fsm_info/1 :: (Pid) -> {Atom, Map(Atom, Any)}
  external fsm_history/1 :: (Pid) -> List(Any)
  external fsm_is_alive/1 :: (Pid) -> Bool
  external fsm_set_data/2 :: (Pid, Any) -> Unit
  external fsm_get_performance_stats/1 :: (Pid) -> {Atom, Any}
  external fsm_reset_stats/1 :: (Pid) -> Unit
  external fsm_link/1 :: (Pid) -> Unit
  external fsm_unlink/1 :: (Pid) -> Unit
  external fsm_monitor/1 :: (Pid) -> Reference
  external fsm_set_timeout/3 :: (Pid, Int, Any) -> Unit
  external fsm_clear_timeout/1 :: (Pid) -> Unit
  external fsm_validate_type/1 :: (Atom) -> Atom | {Atom, Any}
  external fsm_validate_event/2 :: (Pid, Any) -> Atom | {Atom, Any}
  external fsm_get_registered_types/0 :: () -> List(Atom)
  external fsm_lookup_definition/1 :: (Atom) -> {Atom, Any}
  
  # Erlang system functions
  external maps_find/2 :: (Any, Map(Any, Any)) -> {Atom, Any} | Atom
  external erlang_timer_sleep/1 :: (Int) -> Unit
  external erlang_term_to_string/1 :: (Any) -> String
  external erlang_length/1 :: (List(Any)) -> Int

end

# =============================================================================
# Common FSM Definitions
# =============================================================================

# Simple Counter FSM
fsm Counter do
  states: [Zero, Positive, Negative]
  initial: Zero

  state Zero do
    event(:increment) -> Positive
    event(:decrement) -> Negative
    event(:reset) -> Zero
  end

  state Positive do
    event(:increment) -> Positive
    event(:decrement) when value > 1 -> Positive
    event(:decrement) when value == 1 -> Zero
    event(:decrement) when value < 1 -> Negative
    event(:reset) -> Zero
  end

  state Negative do
    event(:increment) when value < -1 -> Negative  
    event(:increment) when value == -1 -> Zero
    event(:increment) when value > -1 -> Positive
    event(:decrement) -> Negative
    event(:reset) -> Zero
  end
end

# Simple Toggle FSM
fsm Toggle do
  states: [On, Off]
  initial: Off

  state On do
    event(:toggle) -> Off
    event(:turn_off) -> Off
    event(:turn_on) -> On
  end

  state Off do
    event(:toggle) -> On
    event(:turn_on) -> On
    event(:turn_off) -> Off
  end
end

# Timer FSM
fsm Timer do
  states: [Running, Expired, Stopped]
  initial: Running

  state Running do
    timeout(duration) -> Expired
    event(:stop) -> Stopped
    event(:reset) -> Running
  end

  state Expired do
    event(:reset) -> Running
    event(:stop) -> Stopped
  end

  state Stopped do
    event(:start) -> Running
    event(:reset) -> Running
  end
end

# Generic State Machine FSM
fsm StateMachine do
  states: [State1, State2, State3]  # Dynamic in real implementation
  initial: State1

  state State1 do
    event(:next) -> State2
    event(:jump) -> State3
  end

  state State2 do
    event(:next) -> State3
    event(:back) -> State1
  end

  state State3 do
    event(:back) -> State2
    event(:reset) -> State1
  end
end

# Workflow FSM
fsm Workflow do
  states: [NotStarted, InProgress, Completed, Failed]
  initial: NotStarted

  state NotStarted do
    event(:start) -> InProgress
  end

  state InProgress do
    event(:complete) -> Completed
    event(:fail) -> Failed
    event(:abort) -> NotStarted
  end

  state Completed do
    event(:restart) -> NotStarted
  end

  state Failed do
    event(:retry) -> InProgress
    event(:abort) -> NotStarted
  end
end