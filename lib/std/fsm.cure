# Cure Standard Library - FSM Module
# Provides operations for working with FSMs

module Std.Fsm do
  export [
    start_fsm/1,
    fsm_cast/2,
    fsm_advertise/2,
    fsm_state/1,
    fsm_stop/1,
    fsm_spawn/2,
    fsm_send/2,
    fsm_info/1,
    fsm_is_alive/1,
    fsm_whereis/1,
    fsm_history/1,
    fsm_send_batch/2
  ]

  # Core FSM types - these are type aliases
  type FsmName = Atom
  type FsmError = Atom  # Error types like :invalid_state, :invalid_transition, etc.
  type EventName = Atom
  type StateName = Atom
  type EventPayload = Int  # Simplified for now
  type Event = Int  # Simplified for now
  
  # State is a tuple of state name and payload
  # Payload can be any type (record, list, etc.) - determined by FSM definition
  # Note: This should ideally be a tuple type (StateName, Payload) but type aliases
  # don't support generics yet, so using Atom as a simplified placeholder
  type State = Atom
  
  # Transition handler signature:
  # (from_state, event, current_payload) => Result(new_state_with_payload, error)
  type TransitionHandler = Pair(Event, Pair(StateName, State)) => Result(Pair(StateName, State), FsmError)

  record FsmDefinition do
    initial_state: StateName
    initial_payload: Any
    transitions: List(Pair(Pair(StateName, EventName), TransitionHandler))
  end

  record FsmState do
    definition: FsmDefinition
    current_state: StateName
    current_payload: Any
  end

  # Start an FSM instance with the module's FSM definition
  # Returns a Pid for the FSM process
  # Calls cure_fsm_cure_api:start_fsm/1 which:
  # - Looks up the compiled FSM definition from the module
  # - Extracts initial state and payload
  # - Starts the FSM using cure_fsm_runtime
  curify start_fsm(mod: Atom): Any = {cure_fsm_cure_api, start_fsm, 1}

  # Send an event to an FSM (by Pid or registered name)
  # Asynchronous - fire and forget
  # Event should be a tuple {EventName, EventPayload} where:
  # - EventName is an atom
  # - EventPayload is a list of {key, value} pairs
  curify fsm_cast(target: Any, evt: Any): Any = {cure_fsm_cure_api, fsm_cast, 2}

  # Register a name for an FSM process
  # Registers the FSM process with the given name so it can be referenced
  # by name instead of PID
  curify fsm_advertise(pid: Any, name: Atom): Any = {cure_fsm_cure_api, fsm_advertise, 2}

  # Query the current state of an FSM
  # Returns {ok, {StateName, Payload}} or {error, Reason}
  curify fsm_state(target: Any): Any = {cure_fsm_cure_api, fsm_state, 1}

  # Stop an FSM instance
  # Gracefully terminates the FSM process
  curify fsm_stop(pid: Any): Any = {cure_fsm_builtins, fsm_stop, 1}

  # Spawn an FSM instance with initial data
  # Alternative to start_fsm that takes FSM type and initial data directly
  # Returns the Pid of the spawned FSM process
  curify fsm_spawn(fsm_type: Atom, initial_data: Any): Any = {cure_fsm_builtins, fsm_spawn, 2}

  # Send an event to an FSM (lower-level than fsm_cast)
  # Directly sends an event without tuple wrapping
  curify fsm_send(pid: Any, evt: Any): Any = {cure_fsm_builtins, fsm_send, 2}

  # Get detailed FSM information
  # Returns a map with current_state, data, event_history, and performance stats
  curify fsm_info(pid: Any): Any = {cure_fsm_builtins, fsm_info, 1}

  # Check if an FSM process is alive
  # Returns true if the FSM is still running, false otherwise
  curify fsm_is_alive(pid: Any): Any = {cure_fsm_builtins, fsm_is_alive, 1}

  # Look up an FSM process by registered name
  # Returns the Pid if found, undefined otherwise
  curify fsm_whereis(name: Atom): Any = {cure_fsm_cure_api, fsm_whereis, 1}

  # Get FSM event history
  # Returns a list of events that have been processed by the FSM
  curify fsm_history(pid: Any): Any = {cure_fsm_builtins, fsm_history, 1}

  # Send a batch of events to an FSM
  # More efficient than multiple fsm_cast calls for bulk operations
  # Events should be a list of event atoms or tuples
  curify fsm_send_batch(target: Any, events: List(Any)): Any = {cure_fsm_builtins, fsm_send_batch, 2}

end
