# Cure Standard Library - FSM Module
# Provides operations for working with FSMs

module Std.Fsm do
  export [
    start_fsm/1,
    fsm_cast/2,
    fsm_advertise/2,
    fsm_state/1
  ]

  # Core FSM types
  type FsmName = Atom
  type FsmError = Atom  # Error types like :invalid_state, :invalid_transition, etc.
  type EventName = Atom
  type StateName = Atom
  type EventPayload = List(Pair(Atom, Any))  # Event-specific data
  type Event = Pair(EventName, EventPayload)
  
  # State is a pair of state name and payload
  # Payload can be any type (record, list, etc.) - determined by FSM definition
  type State = Any
  
  # Transition handler signature:
  # (from_state, event, current_payload) -> Result(new_state_with_payload, error)
  type TransitionHandler = Pair(Event, Pair(StateName, State)) -> Result(Pair(StateName, State), FsmError)

  record FsmDefinition do
    initial_state: StateName
    initial_payload: Any
    transitions: List(Pair(Pair(StateName, EventName), TransitionHandler))
  end

  record FsmState do
    definition: FsmDefinition
    current_state: StateName
    current_payload: Any
  end

  # Start an FSM instance with the module's FSM definition
  # Returns a Pid for the FSM process
  # TODO: Implementation will spawn a process that maintains FSM state
  # and handles events via message passing
  # Placeholder implementation - returns any atom cast to Pid type
  def start_fsm(mod: Int): Int =
    0

  # Send an event to an FSM (by Pid or registered name)
  # Asynchronous - fire and forget
  # TODO: Send message to FSM process
  def fsm_cast(target: Pid | FsmName, evt: Event): Int =
    0

  # Register a name for an FSM process
  # TODO: Register the process with the given name
  def fsm_advertise(pid: Pid, name: FsmName): Int =
    0

  # Query the current state of an FSM
  # TODO: Query FSM process for current state and payload
  def fsm_state(target: Pid | FsmName): Int =
    0

end
