module Std.Vector do
  export [
    # Basic operations
    length/1, is_empty/1, reverse/2,
    
    # Simple transformations
    map/2, filter/2, fold/3, zip_with/3,
    
    # Simple predicates
    contains/2
  ]

  # Basic operations
  def length(v: Vector(T, n)): Int = n

  def is_empty(v: Vector(T, n)): Bool = n == 0

  def reverse(v: Vector(T, n), acc: Vector(T, m)): Vector(T, m + n) =
    match v do
      [] -> acc
      [h | t] -> reverse(t, [h | acc])
    end

  def map(v: Vector(T, n), f: T -> U): Vector(U, n) =
    match v do
      [] -> []
      [h | t] -> [f(h) | map(t, f)]
    end

  def filter(v: Vector(T, n), predicate: T -> Bool): List(T) =
    match v do
      [] -> []
      [h | t] -> 
        let filtered_tail = filter(t, predicate)
        match predicate(h) do
          true -> [h | filtered_tail]
          false -> filtered_tail
        end
    end

  def fold(v: Vector(T, n), init: U, func: T -> U -> U): U =
    match v do
      [] -> init
      [h | t] -> 
        let partial_func = func(h)
        partial_func(fold(t, init, func))
    end

  def zip_with(v1: Vector(T, n), v2: Vector(U, n), func: T -> U -> V): Vector(V, n) =
    match v1 do
      [] -> []
      [h1 | t1] -> 
        match v2 do
          [] -> []  # This should not happen with equal length vectors
          [h2 | t2] -> 
            let partial_func = func(h1)
            [partial_func(h2) | zip_with(t1, t2, func)]
        end
    end

  # Simple predicates
  def contains(v: Vector(T, n), element: T): Bool =
    match v do
      [] -> false
      [h | t] ->
        match h == element do
          true -> true
          false -> contains(t, element)
        end
    end

end
