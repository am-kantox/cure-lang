module Std.Option do
  export [
    some/1, none/0,
    is_some/1, is_none/1,
    map/2, flat_map/2, filter/2,
    get_or_else/2, or_else/2,
    to_list/1, from_nullable/1
  ]

  # Constructor functions
  def some(value: T): Option(T) = Some(value)
  def none(): Option(T) = None

  # Predicates
  def is_some(opt: Option(T)): Bool =
    match opt do
      Some(_) -> true
      None -> false
    end

  def is_none(opt: Option(T)): Bool =
    match opt do
      Some(_) -> false
      None -> true
    end

  # Transformations
  def map(opt: Option(T), f: T -> U): Option(U) =
    match opt do
      Some(value) -> Some(f(value))
      None -> None
    end

  def flat_map(opt: Option(T), f: T -> Option(U)): Option(U) =
    match opt do
      Some(value) -> f(value)
      None -> None
    end

  def filter(opt: Option(T), predicate: T -> Bool): Option(T) =
    match opt do
      Some(value) -> 
        if predicate(value) then Some(value) else None end
      None -> None
    end

  # Value extraction
  def get_or_else(opt: Option(T), default: T): T =
    match opt do
      Some(value) -> value
      None -> default
    end

  def or_else(opt: Option(T), alternative: Option(T)): Option(T) =
    match opt do
      Some(_) -> opt
      None -> alternative
    end

  # Conversions
  def to_list(opt: Option(T)): List(T) =
    match opt do
      Some(value) -> [value]
      None -> []
    end

  def from_nullable(value: T): Option(T) =
    # This would check for null/nil in real implementation
    Some(value)  # Simplified
end