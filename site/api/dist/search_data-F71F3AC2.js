searchData={"items":[{"type":"module","title":"cure_action_compiler","doc":null,"ref":"cure_action_compiler.html"},{"type":"function","title":"cure_action_compiler.analyze_action_safety/2","doc":null,"ref":"cure_action_compiler.html#analyze_action_safety/2"},{"type":"function","title":"cure_action_compiler.compile_action/2","doc":null,"ref":"cure_action_compiler.html#compile_action/2"},{"type":"function","title":"cure_action_compiler.compile_actions/2","doc":null,"ref":"cure_action_compiler.html#compile_actions/2"},{"type":"function","title":"cure_action_compiler.is_action_safe/1","doc":null,"ref":"cure_action_compiler.html#is_action_safe/1"},{"type":"function","title":"cure_action_compiler.optimize_action/1","doc":null,"ref":"cure_action_compiler.html#optimize_action/1"},{"type":"module","title":"cure_ast","doc":"# Cure Programming Language - AST Definitions\n\nThis module defines the Abstract Syntax Tree (AST) node types and structure for\nthe Cure programming language. It provides comprehensive type definitions and\nhelper functions for creating and manipulating AST nodes throughout the compilation\npipeline.","ref":"cure_ast.html"},{"type":"module","title":"Overview - cure_ast","doc":"The Cure AST represents the complete syntactic structure of Cure programs including:\n- **Programs**: Collections of top-level items\n- **Modules**: Module definitions with exports and items\n- **Functions**: Function definitions with parameters, return types, and bodies\n- **Types**: User-defined types, primitives, and complex type expressions\n- **FSMs**: Finite state machine definitions with states and transitions\n- **Expressions**: All forms of expressions (literals, function calls, control flow)\n- **Patterns**: Pattern matching constructs\n- **Location Information**: Source position tracking for error reporting","ref":"cure_ast.html#module-overview"},{"type":"module","title":"AST Structure - cure_ast","doc":"","ref":"cure_ast.html#module-ast-structure"},{"type":"module","title":"Top-Level Items - cure_ast","doc":"Programs consist of top-level items:\n- `module_def()` - Module definitions\n- `function_def()` - Regular function definitions\n- `erlang_function_def()` - Erlang interop functions\n- `type_def()` - User-defined type definitions\n- `fsm_def()` - Finite state machine definitions\n- `import_def()` - Import statements","ref":"cure_ast.html#module-top-level-items"},{"type":"module","title":"Expression Types - cure_ast","doc":"Expressions represent computations and values:\n- `literal_expr()` - Literals (numbers, strings, atoms)\n- `identifier_expr()` - Variable and function names\n- `function_call_expr()` - Function calls with arguments\n- `binary_op_expr()` - Binary operations (+, -, *, etc.)\n- `unary_op_expr()` - Unary operations (-, not)\n- `match_expr()` - Pattern matching expressions\n- `let_expr()` - Let bindings\n- `list_expr()` - List literals\n- `tuple_expr()` - Tuple literals\n- `record_expr()` - Record construction\n- `lambda_expr()` - Anonymous functions","ref":"cure_ast.html#module-expression-types"},{"type":"module","title":"Type System - cure_ast","doc":"Type expressions represent Cure's type system:\n- `primitive_type()` - Built-in types (Int, String, Bool, etc.)\n- `dependent_type()` - Parameterized types with dependencies\n- `function_type()` - Function type signatures\n- `union_type()` - Union types (T | U)\n- `list_type()` - List types\n- `tuple_type()` - Tuple types\n- `type_param()` - Type parameters for generics","ref":"cure_ast.html#module-type-system"},{"type":"module","title":"Pattern Matching - cure_ast","doc":"Patterns for destructuring and matching:\n- `wildcard_pattern()` - Wildcard patterns (_)\n- `literal_pattern()` - Literal value patterns\n- `identifier_pattern()` - Variable binding patterns\n- `list_pattern()` - List destructuring patterns\n- `tuple_pattern()` - Tuple destructuring patterns\n- `record_pattern()` - Record field patterns\n- `constructor_pattern()` - Constructor patterns (Ok(x), Error(e))","ref":"cure_ast.html#module-pattern-matching"},{"type":"module","title":"FSM Support - cure_ast","doc":"First-class finite state machine support:\n- `fsm_def()` - FSM type definitions\n- `state_def()` - Individual state definitions\n- `transition()` - State transitions with events, guards, and actions","ref":"cure_ast.html#module-fsm-support"},{"type":"module","title":"Location Tracking - cure_ast","doc":"All AST nodes include location information for:\n- **Error Reporting**: Precise source locations for compilation errors\n- **Debugging**: Source mapping for runtime errors\n- **IDE Support**: Language server integration\n- **Documentation**: API documentation generation","ref":"cure_ast.html#module-location-tracking"},{"type":"module","title":"Usage Example - cure_ast","doc":"```erlang\n%% Create a simple function definition\nParams = [#param{name = x, type = int_type(), location = Location}],\nBody = #literal_expr{value = 42, location = Location},\nFunction = cure_ast:new_function(identity, Params, int_type(), undefined, Body).\n\n%% Create an FSM definition\nStates = [idle, running, stopped],\nInitial = idle,\nStateDefs = [IdleState, RunningState, StoppedState],\nFSM = cure_ast:new_fsm(state_machine, States, Initial, StateDefs).\n```","ref":"cure_ast.html#module-usage-example"},{"type":"module","title":"Design Principles - cure_ast","doc":"","ref":"cure_ast.html#module-design-principles"},{"type":"module","title":"Immutability - cure_ast","doc":"AST nodes are immutable records that can be safely shared and transformed\nwithout side effects.","ref":"cure_ast.html#module-immutability"},{"type":"module","title":"Composability - cure_ast","doc":"Complex AST structures are built by composing simpler nodes, enabling\nmodular construction and transformation.","ref":"cure_ast.html#module-composability"},{"type":"module","title":"Location Preservation - cure_ast","doc":"Every AST node maintains source location information to support high-quality\nerror messages and debugging.","ref":"cure_ast.html#module-location-preservation"},{"type":"module","title":"Type Safety - cure_ast","doc":"Erlang type specifications ensure AST node integrity and enable static\nanalysis tools to verify AST manipulation code.","ref":"cure_ast.html#module-type-safety"},{"type":"module","title":"Integration - cure_ast","doc":"This module integrates with:\n- **Parser**: Produces AST nodes from token streams\n- **Type Checker**: Analyzes and annotates AST with type information\n- **Compiler**: Transforms AST through various compilation phases\n- **Error Reporter**: Uses location information for error messages","ref":"cure_ast.html#module-integration"},{"type":"module","title":"Performance Considerations - cure_ast","doc":"- **Memory Efficient**: Records are lightweight with minimal overhead\n- **Copy-on-Write**: Erlang's immutable data structures optimize memory usage\n- **Pattern Matching**: Efficient pattern matching on AST node types\n- **Location Sharing**: Location records can be shared between related nodes","ref":"cure_ast.html#module-performance-considerations"},{"type":"function","title":"cure_ast.new_expr/3","doc":"Creates a new expression AST node with location information.","ref":"cure_ast.html#new_expr/3"},{"type":"function","title":"Arguments - cure_ast.new_expr/3","doc":"- `Type` - Expression type (literal, identifier, etc.)\n- `Data` - Expression data appropriate for the type\n- `Location` - Source location information","ref":"cure_ast.html#new_expr/3-arguments"},{"type":"function","title":"Returns - cure_ast.new_expr/3","doc":"- `expr()` - Expression AST node\n- `error({unknown_expr_type, Type, Data, Location})` - Unknown expression type","ref":"cure_ast.html#new_expr/3-returns"},{"type":"function","title":"Supported Types - cure_ast.new_expr/3","doc":"- `literal` - Creates a literal expression from the value\n- `identifier` - Creates an identifier expression from the name","ref":"cure_ast.html#new_expr/3-supported-types"},{"type":"function","title":"Example - cure_ast.new_expr/3","doc":"```erlang\nLiteral = cure_ast:new_expr(literal, 42, Location),\nIdentifier = cure_ast:new_expr(identifier, variable_name, Location).\n```","ref":"cure_ast.html#new_expr/3-example"},{"type":"function","title":"Note - cure_ast.new_expr/3","doc":"This is a limited helper function that only supports basic expression types.\nFor complex expressions, construct the records directly.","ref":"cure_ast.html#new_expr/3-note"},{"type":"function","title":"cure_ast.new_fsm/5","doc":"Creates a new FSM definition AST node.","ref":"cure_ast.html#new_fsm/5"},{"type":"function","title":"Arguments - cure_ast.new_fsm/5","doc":"- `Name` - FSM name (atom)\n- `States` - List of state names\n- `Initial` - Initial state name\n- `StateDefs` - List of state definitions with transitions\n- `Location` - Source location information","ref":"cure_ast.html#new_fsm/5-arguments"},{"type":"function","title":"Returns - cure_ast.new_fsm/5","doc":"- `fsm_def()` - FSM definition AST node","ref":"cure_ast.html#new_fsm/5-returns"},{"type":"function","title":"Example - cure_ast.new_fsm/5","doc":"```erlang\nStates = [idle, running, stopped],\nStateDefs = [IdleState, RunningState, StoppedState],\nFSM = cure_ast:new_fsm(counter, States, idle, StateDefs, Location).\n```","ref":"cure_ast.html#new_fsm/5-example"},{"type":"function","title":"cure_ast.new_function/6","doc":"Creates a new function definition AST node.","ref":"cure_ast.html#new_function/6"},{"type":"function","title":"Arguments - cure_ast.new_function/6","doc":"- `Name` - Function name (atom)\n- `Params` - List of function parameters\n- `ReturnType` - Return type expression (undefined if not specified)\n- `Constraint` - Optional constraint expression for the function\n- `Body` - Function body expression\n- `Location` - Source location information","ref":"cure_ast.html#new_function/6-arguments"},{"type":"function","title":"Returns - cure_ast.new_function/6","doc":"- `function_def()` - Function definition AST node","ref":"cure_ast.html#new_function/6-returns"},{"type":"function","title":"Example - cure_ast.new_function/6","doc":"```erlang\nParams = [#param{name = x, type = IntType, location = Loc}],\nBody = #literal_expr{value = 42, location = Loc},\nFunction = cure_ast:new_function(identity, Params, IntType, undefined, Body, Location).\n```","ref":"cure_ast.html#new_function/6-example"},{"type":"function","title":"cure_ast.new_module/4","doc":"Creates a new module definition AST node.","ref":"cure_ast.html#new_module/4"},{"type":"function","title":"Arguments - cure_ast.new_module/4","doc":"- `Name` - Module name (atom)\n- `Exports` - List of export specifications\n- `Items` - List of top-level items in the module\n- `Location` - Source location information","ref":"cure_ast.html#new_module/4-arguments"},{"type":"function","title":"Returns - cure_ast.new_module/4","doc":"- `module_def()` - Module definition AST node","ref":"cure_ast.html#new_module/4-returns"},{"type":"function","title":"Example - cure_ast.new_module/4","doc":"```erlang\nExports = [#export_spec{name = hello, arity = 1, location = Loc}],\nItems = [FunctionDef],\nModule = cure_ast:new_module('MyModule', Exports, Items, Location).\n```","ref":"cure_ast.html#new_module/4-example"},{"type":"function","title":"cure_ast.new_type_def/4","doc":"Creates a new type definition AST node.","ref":"cure_ast.html#new_type_def/4"},{"type":"function","title":"Arguments - cure_ast.new_type_def/4","doc":"- `Name` - Type name (atom)\n- `Params` - List of type parameter names\n- `Definition` - Type expression defining the type\n- `Location` - Source location information","ref":"cure_ast.html#new_type_def/4-arguments"},{"type":"function","title":"Returns - cure_ast.new_type_def/4","doc":"- `type_def()` - Type definition AST node","ref":"cure_ast.html#new_type_def/4-returns"},{"type":"function","title":"Example - cure_ast.new_type_def/4","doc":"```erlang\nParams = [t],\nDefinition = #union_type{types = [IntType, StringType], location = Loc},\nTypeDef = cure_ast:new_type_def('Maybe', Params, Definition, Location).\n```","ref":"cure_ast.html#new_type_def/4-example"},{"type":"type","title":"cure_ast.binary_op_expr/0","doc":"","ref":"cure_ast.html#t:binary_op_expr/0"},{"type":"type","title":"cure_ast.binding/0","doc":"","ref":"cure_ast.html#t:binding/0"},{"type":"type","title":"cure_ast.dependent_type/0","doc":"","ref":"cure_ast.html#t:dependent_type/0"},{"type":"type","title":"cure_ast.erlang_function_def/0","doc":"","ref":"cure_ast.html#t:erlang_function_def/0"},{"type":"type","title":"cure_ast.export_spec/0","doc":"","ref":"cure_ast.html#t:export_spec/0"},{"type":"type","title":"cure_ast.expr/0","doc":"","ref":"cure_ast.html#t:expr/0"},{"type":"type","title":"cure_ast.field_expr/0","doc":"","ref":"cure_ast.html#t:field_expr/0"},{"type":"type","title":"cure_ast.field_pattern/0","doc":"","ref":"cure_ast.html#t:field_pattern/0"},{"type":"type","title":"cure_ast.fsm_def/0","doc":"","ref":"cure_ast.html#t:fsm_def/0"},{"type":"type","title":"cure_ast.function_call_expr/0","doc":"","ref":"cure_ast.html#t:function_call_expr/0"},{"type":"type","title":"cure_ast.function_def/0","doc":"","ref":"cure_ast.html#t:function_def/0"},{"type":"type","title":"cure_ast.function_type/0","doc":"","ref":"cure_ast.html#t:function_type/0"},{"type":"type","title":"cure_ast.identifier_expr/0","doc":"","ref":"cure_ast.html#t:identifier_expr/0"},{"type":"type","title":"cure_ast.identifier_pattern/0","doc":"","ref":"cure_ast.html#t:identifier_pattern/0"},{"type":"type","title":"cure_ast.import_def/0","doc":"","ref":"cure_ast.html#t:import_def/0"},{"type":"type","title":"cure_ast.item/0","doc":"","ref":"cure_ast.html#t:item/0"},{"type":"type","title":"cure_ast.lambda_expr/0","doc":"","ref":"cure_ast.html#t:lambda_expr/0"},{"type":"type","title":"cure_ast.let_expr/0","doc":"","ref":"cure_ast.html#t:let_expr/0"},{"type":"type","title":"cure_ast.list_expr/0","doc":"","ref":"cure_ast.html#t:list_expr/0"},{"type":"type","title":"cure_ast.list_pattern/0","doc":"","ref":"cure_ast.html#t:list_pattern/0"},{"type":"type","title":"cure_ast.list_type/0","doc":"","ref":"cure_ast.html#t:list_type/0"},{"type":"type","title":"cure_ast.literal_expr/0","doc":"","ref":"cure_ast.html#t:literal_expr/0"},{"type":"type","title":"cure_ast.literal_pattern/0","doc":"","ref":"cure_ast.html#t:literal_pattern/0"},{"type":"type","title":"cure_ast.location/0","doc":"","ref":"cure_ast.html#t:location/0"},{"type":"type","title":"cure_ast.match_clause/0","doc":"","ref":"cure_ast.html#t:match_clause/0"},{"type":"type","title":"cure_ast.match_expr/0","doc":"","ref":"cure_ast.html#t:match_expr/0"},{"type":"type","title":"cure_ast.module_def/0","doc":"","ref":"cure_ast.html#t:module_def/0"},{"type":"type","title":"cure_ast.param/0","doc":"","ref":"cure_ast.html#t:param/0"},{"type":"type","title":"cure_ast.pattern/0","doc":"","ref":"cure_ast.html#t:pattern/0"},{"type":"type","title":"cure_ast.primitive_type/0","doc":"","ref":"cure_ast.html#t:primitive_type/0"},{"type":"type","title":"cure_ast.program/0","doc":"","ref":"cure_ast.html#t:program/0"},{"type":"type","title":"cure_ast.record_expr/0","doc":"","ref":"cure_ast.html#t:record_expr/0"},{"type":"type","title":"cure_ast.record_pattern/0","doc":"","ref":"cure_ast.html#t:record_pattern/0"},{"type":"type","title":"cure_ast.state_def/0","doc":"","ref":"cure_ast.html#t:state_def/0"},{"type":"type","title":"cure_ast.transition/0","doc":"","ref":"cure_ast.html#t:transition/0"},{"type":"type","title":"cure_ast.tuple_expr/0","doc":"","ref":"cure_ast.html#t:tuple_expr/0"},{"type":"type","title":"cure_ast.tuple_pattern/0","doc":"","ref":"cure_ast.html#t:tuple_pattern/0"},{"type":"type","title":"cure_ast.tuple_type/0","doc":"","ref":"cure_ast.html#t:tuple_type/0"},{"type":"type","title":"cure_ast.type_def/0","doc":"","ref":"cure_ast.html#t:type_def/0"},{"type":"type","title":"cure_ast.type_expr/0","doc":"","ref":"cure_ast.html#t:type_expr/0"},{"type":"type","title":"cure_ast.type_param/0","doc":"","ref":"cure_ast.html#t:type_param/0"},{"type":"type","title":"cure_ast.unary_op_expr/0","doc":"","ref":"cure_ast.html#t:unary_op_expr/0"},{"type":"type","title":"cure_ast.union_type/0","doc":"","ref":"cure_ast.html#t:union_type/0"},{"type":"type","title":"cure_ast.wildcard_pattern/0","doc":"","ref":"cure_ast.html#t:wildcard_pattern/0"},{"type":"module","title":"cure_beam_compiler","doc":null,"ref":"cure_beam_compiler.html"},{"type":"function","title":"cure_beam_compiler.compile_function_to_erlang/2","doc":null,"ref":"cure_beam_compiler.html#compile_function_to_erlang/2"},{"type":"function","title":"cure_beam_compiler.compile_function_to_erlang/4","doc":null,"ref":"cure_beam_compiler.html#compile_function_to_erlang/4"},{"type":"function","title":"cure_beam_compiler.compile_function_to_erlang/5","doc":null,"ref":"cure_beam_compiler.html#compile_function_to_erlang/5"},{"type":"function","title":"cure_beam_compiler.compile_instructions_to_forms/2","doc":null,"ref":"cure_beam_compiler.html#compile_instructions_to_forms/2"},{"type":"function","title":"cure_beam_compiler.optimize_instructions/1","doc":null,"ref":"cure_beam_compiler.html#optimize_instructions/1"},{"type":"function","title":"cure_beam_compiler.validate_erlang_forms/1","doc":null,"ref":"cure_beam_compiler.html#validate_erlang_forms/1"},{"type":"module","title":"cure_cli","doc":"# Cure Programming Language - Command Line Interface\n\nThis module provides a comprehensive command-line interface for the Cure programming\nlanguage compiler. It handles argument parsing, file compilation, and the complete\ncompilation pipeline from Cure source code to BEAM bytecode.","ref":"cure_cli.html"},{"type":"module","title":"Features - cure_cli","doc":"- **Complete CLI Interface**: Argument parsing with support for all compiler options\n- **Full Compilation Pipeline**: Lexing → Parsing → Type Checking → Optimization → Code Generation\n- **Error Handling**: Comprehensive error reporting with optional debug information\n- **Multiple Output Formats**: Support for different output directories and file formats\n- **Integration Ready**: Designed for use with build systems and IDEs","ref":"cure_cli.html#module-features"},{"type":"module","title":"Usage - cure_cli","doc":"```bash\ncure input.cure                    # Compile with defaults\ncure input.cure -o output.beam     # Specify output file\ncure input.cure --verbose          # Enable verbose output\ncure input.cure --no-optimize      # Disable optimizations\n```","ref":"cure_cli.html#module-usage"},{"type":"module","title":"Command Line Options - cure_cli","doc":"- `-o, --output FILE` - Output .beam file path\n- `-d, --output-dir DIR` - Output directory (default: `_build/ebin`)\n- `--verbose` - Enable verbose compilation output\n- `--no-debug` - Disable debug information in output\n- `--no-warnings` - Suppress compiler warnings\n- `--no-type-check` - Skip type checking phase\n- `--no-optimize` - Disable type-directed optimizations\n- `--help, -h` - Show help information\n- `--version, -v` - Show version information","ref":"cure_cli.html#module-command-line-options"},{"type":"module","title":"Environment Variables - cure_cli","doc":"- `CURE_DEBUG=1` - Enable detailed debug output including stack traces","ref":"cure_cli.html#module-environment-variables"},{"type":"module","title":"Error Codes - cure_cli","doc":"- `0` - Success\n- `1` - Compilation or runtime error\n- `2` - Usage error (invalid arguments)","ref":"cure_cli.html#module-error-codes"},{"type":"function","title":"cure_cli.add_automatic_stdlib_imports/2","doc":"","ref":"cure_cli.html#add_automatic_stdlib_imports/2"},{"type":"function","title":"cure_cli.check_cure_installation/0","doc":"Verify that all required Cure compiler modules are available.\n\nThis function checks for the presence of core compiler modules\nto ensure the Cure installation is complete and functional.","ref":"cure_cli.html#check_cure_installation/0"},{"type":"function","title":"Required Modules - cure_cli.check_cure_installation/0","doc":"- `cure_lexer` - Tokenization engine\n- `cure_parser` - AST generation\n- `cure_typechecker` - Type checking system\n- `cure_codegen` - Code generation","ref":"cure_cli.html#check_cure_installation/0-required-modules"},{"type":"function","title":"Returns - cure_cli.check_cure_installation/0","doc":"- `ok` - All required modules are present\n- `{error, {missing_modules, List}}` - Some modules are missing","ref":"cure_cli.html#check_cure_installation/0-returns"},{"type":"function","title":"Side Effects - cure_cli.check_cure_installation/0","doc":"Prints warning messages if modules are missing, including\ninstructions to run `make all` to build the complete compiler.","ref":"cure_cli.html#check_cure_installation/0-side-effects"},{"type":"function","title":"Usage - cure_cli.check_cure_installation/0","doc":"This function is called internally to validate the compiler\nstate before attempting compilation operations.","ref":"cure_cli.html#check_cure_installation/0-usage"},{"type":"function","title":"cure_cli.compile_file/1","doc":"Compile a .cure file with default compilation options.","ref":"cure_cli.html#compile_file/1"},{"type":"function","title":"Arguments - cure_cli.compile_file/1","doc":"- `Filename` - Path to the .cure source file to compile","ref":"cure_cli.html#compile_file/1-arguments"},{"type":"function","title":"Returns - cure_cli.compile_file/1","doc":"- `{ok, OutputFile}` - Successful compilation with output file path\n- `{error, Reason}` - Compilation failed with error details","ref":"cure_cli.html#compile_file/1-returns"},{"type":"function","title":"Examples - cure_cli.compile_file/1","doc":"```erlang\ncompile_file(\"examples/hello.cure\").\n% => {ok, \"_build/ebin/hello.beam\"}\n```","ref":"cure_cli.html#compile_file/1-examples"},{"type":"function","title":"cure_cli.compile_file/2","doc":"Compile a .cure file with specified compilation options.\n\nThis is the main compilation entry point that supports all compiler\nfeatures including type checking, optimizations, and custom output options.","ref":"cure_cli.html#compile_file/2"},{"type":"function","title":"Arguments - cure_cli.compile_file/2","doc":"- `Filename` - Path to the .cure source file to compile\n- `Options` - Compilation options record with fields:\n  - `output_file` - Custom output file path (optional)\n  - `output_dir` - Output directory (default: \"_build/ebin\")\n  - `debug_info` - Include debug information (default: true)\n  - `warnings` - Show warnings (default: true)  \n  - `verbose` - Verbose output (default: false)\n  - `type_check` - Enable type checking (default: true)\n  - `optimize` - Enable optimizations (default: true)\n  - `fsm_runtime` - Include FSM runtime (default: true)","ref":"cure_cli.html#compile_file/2-arguments"},{"type":"function","title":"Returns - cure_cli.compile_file/2","doc":"- `{ok, OutputFile}` - Successful compilation\n- `{error, Reason}` - Compilation error with detailed reason","ref":"cure_cli.html#compile_file/2-returns"},{"type":"function","title":"Compilation Pipeline - cure_cli.compile_file/2","doc":"The function executes a complete 5-stage pipeline:\n\n1. **Lexical Analysis** - Tokenize source code\n2. **Parsing** - Build Abstract Syntax Tree\n3. **Type Checking** - Verify types and constraints (optional)\n4. **Optimization** - Type-directed optimizations (optional)\n5. **Code Generation** - Generate BEAM bytecode","ref":"cure_cli.html#compile_file/2-compilation-pipeline"},{"type":"function","title":"Examples - cure_cli.compile_file/2","doc":"```erlang\n% Compile with verbose output\nOptions = #compile_options{verbose = true},\ncompile_file(\"src/math.cure\", Options).\n\n% Compile without optimizations  \nOptions = #compile_options{optimize = false},\ncompile_file(\"debug.cure\", Options).\n\n% Custom output file\nOptions = #compile_options{output_file = \"custom.beam\"},\ncompile_file(\"input.cure\", Options).\n```","ref":"cure_cli.html#compile_file/2-examples"},{"type":"function","title":"cure_cli.compile_file_from_shell/1","doc":"","ref":"cure_cli.html#compile_file_from_shell/1"},{"type":"function","title":"cure_cli.compile_opts_to_codegen_opts/1","doc":"Convert CLI compilation options to code generation options.\n\nThis function transforms the user-facing compilation options into\nthe internal format expected by the code generation modules.","ref":"cure_cli.html#compile_opts_to_codegen_opts/1"},{"type":"function","title":"Arguments - cure_cli.compile_opts_to_codegen_opts/1","doc":"- `Options` - Compilation options record","ref":"cure_cli.html#compile_opts_to_codegen_opts/1-arguments"},{"type":"function","title":"Returns - cure_cli.compile_opts_to_codegen_opts/1","doc":"- List of `{Key, Value}` tuples for the code generator","ref":"cure_cli.html#compile_opts_to_codegen_opts/1-returns"},{"type":"function","title":"Option Mapping - cure_cli.compile_opts_to_codegen_opts/1","doc":"- `debug_info` → `{debug_info, true}`\n- `optimize` → `{optimize, 1}` \n- `warnings` → `{warnings, true}`\n- `fsm_runtime` → `{fsm_integration, true}`","ref":"cure_cli.html#compile_opts_to_codegen_opts/1-option-mapping"},{"type":"function","title":"cure_cli.convert_beam_to_source_path/1","doc":"","ref":"cure_cli.html#convert_beam_to_source_path/1"},{"type":"function","title":"cure_cli.ensure_stdlib_available/1","doc":"Ensure that the Cure standard library is available and compiled.\n\nThis function checks if the standard library BEAM files exist,\nand if not, attempts to compile them automatically.","ref":"cure_cli.html#ensure_stdlib_available/1"},{"type":"function","title":"Arguments - cure_cli.ensure_stdlib_available/1","doc":"- `Options` - Compilation options including verbosity settings","ref":"cure_cli.html#ensure_stdlib_available/1-arguments"},{"type":"function","title":"Returns - cure_cli.ensure_stdlib_available/1","doc":"- `ok` - Standard library is available\n- `{error, Reason}` - Standard library compilation failed","ref":"cure_cli.html#ensure_stdlib_available/1-returns"},{"type":"function","title":"Side Effects - cure_cli.ensure_stdlib_available/1","doc":"- May invoke `make stdlib` to compile missing standard library\n- Prints progress messages if verbose mode is enabled","ref":"cure_cli.html#ensure_stdlib_available/1-side-effects"},{"type":"function","title":"cure_cli.format_compilation_error/1","doc":"","ref":"cure_cli.html#format_compilation_error/1"},{"type":"function","title":"cure_cli.format_error/1","doc":"","ref":"cure_cli.html#format_error/1"},{"type":"function","title":"cure_cli.get_module_info/1","doc":"Extract module information from an Abstract Syntax Tree.\n\nExtracts comprehensive metadata from compiled modules including:\n- Module name\n- Exported functions with arities\n- Imported modules\n- Type definitions\n- FSM definitions\n- Function count","ref":"cure_cli.html#get_module_info/1"},{"type":"function","title":"Arguments - cure_cli.get_module_info/1","doc":"- `AST` - Abstract Syntax Tree from the parser (list of items or single module_def)","ref":"cure_cli.html#get_module_info/1-arguments"},{"type":"function","title":"Returns - cure_cli.get_module_info/1","doc":"- Map with module information:\n  - `name` - Module name (atom or 'unknown')\n  - `exports` - List of exported function specs with name/arity\n  - `imports` - List of imported module names\n  - `functions` - List of function names defined in module\n  - `types` - List of type definition names\n  - `fsms` - List of FSM definition names\n  - `function_count` - Total number of functions\n  - `type_count` - Total number of types\n  - `fsm_count` - Total number of FSMs\n  - `type` - Module type ('module' or 'unknown')","ref":"cure_cli.html#get_module_info/1-returns"},{"type":"function","title":"Example - cure_cli.get_module_info/1","doc":"```erlang\nAST = cure_parser:parse_file(\"MyModule.cure\"),\nInfo = get_module_info(AST),\n% => #{name => 'MyModule', exports => [{hello, 1}], ...}\n```","ref":"cure_cli.html#get_module_info/1-example"},{"type":"function","title":"cure_cli.has_explicit_module_or_imports/1","doc":"","ref":"cure_cli.html#has_explicit_module_or_imports/1"},{"type":"function","title":"cure_cli.help/0","doc":"Display comprehensive help information for the Cure compiler.\n\nOutputs usage instructions, command-line options, examples, and\nenvironment variables to assist users in using the compiler effectively.","ref":"cure_cli.html#help/0"},{"type":"function","title":"Output Format - cure_cli.help/0","doc":"- **Usage**: Basic command syntax\n- **Arguments**: Required input file specification\n- **Options**: All available command-line flags with descriptions\n- **Examples**: Common usage patterns\n- **Environment**: Relevant environment variables","ref":"cure_cli.html#help/0-output-format"},{"type":"function","title":"cure_cli.main/1","doc":"Main entry point for the Cure compiler when used as an escript.\n\nThis function processes command line arguments and orchestrates the entire\ncompilation process. It handles all user-facing errors and exits with\nappropriate status codes.","ref":"cure_cli.html#main/1"},{"type":"function","title":"Arguments - cure_cli.main/1","doc":"- `Args` - List of command line arguments as strings","ref":"cure_cli.html#main/1-arguments"},{"type":"function","title":"Exit Codes - cure_cli.main/1","doc":"- `0` - Successful compilation\n- `1` - Compilation error or internal error\n- `2` - Usage error (invalid arguments)","ref":"cure_cli.html#main/1-exit-codes"},{"type":"function","title":"Examples - cure_cli.main/1","doc":"```erlang\n% These calls happen automatically when using the CLI:\nmain([\"input.cure\"]).\nmain([\"input.cure\", \"-o\", \"output.beam\"]).\nmain([\"--help\"]).\n```","ref":"cure_cli.html#main/1-examples"},{"type":"function","title":"Error Handling - cure_cli.main/1","doc":"All exceptions are caught and converted to user-friendly error messages.\nWhen `CURE_DEBUG=1` is set, full stack traces are displayed for debugging.","ref":"cure_cli.html#main/1-error-handling"},{"type":"function","title":"cure_cli.version/0","doc":"Display version and system information for the Cure compiler.\n\nShows the current Cure compiler version, Erlang/OTP version,\nand a brief description of the Cure programming language.","ref":"cure_cli.html#version/0"},{"type":"function","title":"Output Information - cure_cli.version/0","doc":"- **Cure Version**: Current compiler version (from `?CURE_VERSION`)\n- **Erlang/OTP Version**: Version of the runtime platform\n- **Description**: Brief overview of Cure language features","ref":"cure_cli.html#version/0-output-information"},{"type":"function","title":"Example Output - cure_cli.version/0","doc":"```\nCure Programming Language Compiler v0.1.0\n\nBuilt with Erlang/OTP 25\n\nCure is a dependently-typed functional programming language\nfor the BEAM virtual machine with built-in finite state machines.\n```","ref":"cure_cli.html#version/0-example-output"},{"type":"module","title":"cure_codegen","doc":"# Cure Programming Language - BEAM Code Generator\n\nThe code generator transforms typed Cure AST into BEAM bytecode, enabling Cure\nprograms to run on the Erlang Virtual Machine. It handles all Cure language\nfeatures including dependent types, finite state machines, pattern matching,\nand integration with Erlang/OTP.","ref":"cure_codegen.html"},{"type":"module","title":"Features - cure_codegen","doc":"","ref":"cure_codegen.html#module-features"},{"type":"module","title":"Complete Language Support - cure_codegen","doc":"- **Module Compilation**: Full module support with imports/exports\n- **Function Compilation**: Regular and dependent function types\n- **Expression Compilation**: All Cure expressions to BEAM instructions\n- **Pattern Matching**: Efficient pattern compilation with optimization\n- **Type Integration**: Uses type information for optimizations","ref":"cure_codegen.html#module-complete-language-support"},{"type":"module","title":"FSM Code Generation - cure_codegen","doc":"- **Native FSM Support**: Compiles FSMs to gen_statem behaviors\n- **State Optimization**: Optimizes state transitions and data access\n- **Guard Compilation**: Efficient guard expression compilation\n- **Action Compilation**: Action sequences to BEAM instructions","ref":"cure_codegen.html#module-fsm-code-generation"},{"type":"module","title":"BEAM Integration - cure_codegen","doc":"- **Bytecode Generation**: Direct BEAM bytecode emission\n- **Module Attributes**: Proper module metadata generation\n- **Export Lists**: Correct function export handling\n- **Debug Information**: Optional debug info generation","ref":"cure_codegen.html#module-beam-integration"},{"type":"module","title":"Optimization Features - cure_codegen","doc":"- **Configurable Levels**: Multiple optimization levels (0-3)\n- **Type-directed**: Uses type information for better code\n- **Dead Code Elimination**: Removes unused code paths\n- **Instruction Optimization**: BEAM instruction-level optimizations","ref":"cure_codegen.html#module-optimization-features"},{"type":"module","title":"Compilation Pipeline - cure_codegen","doc":"","ref":"cure_codegen.html#module-compilation-pipeline"},{"type":"module","title":"1. Program Compilation - cure_codegen","doc":"```erlang\n%% Compile entire program\n{ok, Modules} = cure_codegen:compile_program(AST),\n\n%% With custom options\nOptions = [{optimize, 2}, {debug_info, true}],\n{ok, Modules} = cure_codegen:compile_program(AST, Options).\n```","ref":"cure_codegen.html#module-1-program-compilation"},{"type":"module","title":"2. Module Compilation - cure_codegen","doc":"```erlang\n%% Compile single module\nModule = #module_def{name = 'MyModule', exports = Exports, items = Items},\n{ok, CompiledModule} = cure_codegen:compile_module(Module),\n\n%% Generate BEAM file\ncure_codegen:write_beam_module(CompiledModule, \"MyModule.beam\").\n```","ref":"cure_codegen.html#module-2-module-compilation"},{"type":"module","title":"3. Function Compilation - cure_codegen","doc":"```erlang\n%% Compile individual function\nFunc = #function_def{name = add, params = Params, body = Body},\n{ok, CompiledFunc, State} = cure_codegen:compile_function(Func).\n```","ref":"cure_codegen.html#module-3-function-compilation"},{"type":"module","title":"Code Generation Process - cure_codegen","doc":"","ref":"cure_codegen.html#module-code-generation-process"},{"type":"module","title":"Phase 1: AST Analysis - cure_codegen","doc":"- **Type Information**: Extract and validate type annotations\n- **Import Resolution**: Process module imports and dependencies\n- **Export Analysis**: Validate and process export specifications\n- **Dependency Analysis**: Build function dependency graph","ref":"cure_codegen.html#module-phase-1-ast-analysis"},{"type":"module","title":"Phase 2: Instruction Generation - cure_codegen","doc":"- **Expression Compilation**: Convert expressions to BEAM instructions\n- **Pattern Compilation**: Generate efficient pattern matching code\n- **Guard Compilation**: Compile guard expressions\n- **Control Flow**: Generate conditionals, loops, and jumps","ref":"cure_codegen.html#module-phase-2-instruction-generation"},{"type":"module","title":"Phase 3: Optimization - cure_codegen","doc":"- **Instruction Optimization**: Peephole optimizations\n- **Register Allocation**: Efficient register usage\n- **Jump Optimization**: Minimize jumps and labels\n- **Constant Folding**: Compile-time constant evaluation","ref":"cure_codegen.html#module-phase-3-optimization"},{"type":"module","title":"Phase 4: Module Assembly - cure_codegen","doc":"- **Function Assembly**: Combine compiled functions\n- **Attribute Generation**: Create module attributes\n- **Export List**: Generate proper export specifications\n- **BEAM File**: Produce final BEAM bytecode file","ref":"cure_codegen.html#module-phase-4-module-assembly"},{"type":"module","title":"Compilation Options - cure_codegen","doc":"","ref":"cure_codegen.html#module-compilation-options"},{"type":"module","title":"Standard Options - cure_codegen","doc":"```erlang\nOptions = [\n    {debug_info, true},      % Include debug information\n    {optimize, 2},           % Optimization level 0-3\n    {warnings, true},        % Enable compilation warnings\n    {strict_types, true},    % Strict type checking\n    {fsm_integration, true}  % Enable FSM features\n].\n```","ref":"cure_codegen.html#module-standard-options"},{"type":"module","title":"Optimization Levels - cure_codegen","doc":"- **Level 0**: No optimizations (fastest compile, debugging)\n- **Level 1**: Basic optimizations (safe, minimal impact)\n- **Level 2**: Standard optimizations (default, balanced)\n- **Level 3**: Aggressive optimizations (maximum performance)","ref":"cure_codegen.html#module-optimization-levels"},{"type":"module","title":"Expression Compilation - cure_codegen","doc":"","ref":"cure_codegen.html#module-expression-compilation"},{"type":"module","title":"Literals - cure_codegen","doc":"```cure\n42          → {integer, 42}\n\"hello\"     → {string, \"hello\"}\ntrue        → {atom, true}\n[1,2,3]     → {cons, {integer,1}, {cons, {integer,2}, ...}}\n```","ref":"cure_codegen.html#module-literals"},{"type":"module","title":"Function Calls - cure_codegen","doc":"```cure\nfoo(x, y)   → {call, {atom, foo}, [VarX, VarY]}\nMod.func(x) → {call, {remote, {atom, 'Mod'}, {atom, func}}, [VarX]}\n```","ref":"cure_codegen.html#module-function-calls"},{"type":"module","title":"Pattern Matching - cure_codegen","doc":"```cure\nmatch value do\n    {ok, x} -> x\n    error -> 0\nend\n```\nCompiles to efficient jump table with pattern tests.","ref":"cure_codegen.html#module-pattern-matching"},{"type":"module","title":"FSM Compilation - cure_codegen","doc":"Finite state machines compile to standard Erlang gen_statem:\n\n```cure\nfsm Counter do\n    states: [idle, counting]\n    initial: idle\n    \n    state idle do\n        event start -> counting\n    end\nend\n```\n\nGenerates:\n- `init/1` callback for initialization\n- State callback functions for each state\n- Event handling with pattern matching\n- State data management","ref":"cure_codegen.html#module-fsm-compilation"},{"type":"module","title":"Error Handling - cure_codegen","doc":"The code generator provides detailed error information:\n- **Compilation Errors**: Unsupported constructs, type mismatches\n- **Generation Errors**: BEAM instruction generation failures\n- **Optimization Errors**: Failed optimizations (non-fatal)\n- **File I/O Errors**: BEAM file writing errors","ref":"cure_codegen.html#module-error-handling"},{"type":"module","title":"Integration with Type System - cure_codegen","doc":"Uses type information for:\n- **Type Erasure**: Remove type annotations while preserving semantics\n- **Optimization**: Type-directed optimizations and specializations\n- **Error Prevention**: Catch type-related errors during compilation\n- **Runtime Checks**: Generate minimal runtime type checks where needed","ref":"cure_codegen.html#module-integration-with-type-system"},{"type":"module","title":"BEAM Compatibility - cure_codegen","doc":"Generates standard BEAM bytecode compatible with:\n- **Erlang/OTP**: Full compatibility with Erlang runtime\n- **Elixir**: Can be called from Elixir code\n- **LFE/Gleam**: Compatible with other BEAM languages\n- **Standard Tools**: Works with standard BEAM tools (debugger, profiler)","ref":"cure_codegen.html#module-beam-compatibility"},{"type":"module","title":"Performance Characteristics - cure_codegen","doc":"- **Compilation Speed**: Linear in program size for most constructs\n- **Generated Code**: Comparable performance to hand-written Erlang\n- **Memory Usage**: Efficient memory usage during compilation\n- **Optimization Impact**: 10-40% performance improvement at higher levels","ref":"cure_codegen.html#module-performance-characteristics"},{"type":"module","title":"Thread Safety - cure_codegen","doc":"The code generator is stateless at the module level and can safely compile\nmultiple modules concurrently. Individual function compilation maintains\nlocal state that is not shared between threads.","ref":"cure_codegen.html#module-thread-safety"},{"type":"function","title":"cure_codegen.compile_expression/1","doc":"Compiles a Cure expression to BEAM instructions using default state.\n\nThis is the main expression compilation entry point that handles conversion\nof all Cure expression types to equivalent BEAM bytecode instructions.","ref":"cure_codegen.html#compile_expression/1"},{"type":"function","title":"Arguments - cure_codegen.compile_expression/1","doc":"- `Expr` - Expression AST node (various expr record types)","ref":"cure_codegen.html#compile_expression/1-arguments"},{"type":"function","title":"Returns - cure_codegen.compile_expression/1","doc":"- `{Instructions, State}` - BEAM instructions and updated compilation state\n- `{error, Reason}` - Compilation error details","ref":"cure_codegen.html#compile_expression/1-returns"},{"type":"function","title":"Example - cure_codegen.compile_expression/1","doc":"```erlang\nExpr = #binary_op_expr{op = '+', left = {literal, 5}, right = {literal, 3}},\n{Instructions, _State} = cure_codegen:compile_expression(Expr).\n```","ref":"cure_codegen.html#compile_expression/1-example"},{"type":"function","title":"Supported Expression Types - cure_codegen.compile_expression/1","doc":"- Literals (integers, atoms, strings, booleans)\n- Identifiers (variables, function references)\n- Binary operations (arithmetic, logical, comparison)\n- Function calls (local and remote)\n- Control flow (if/else, pattern matching)\n- Data structures (lists, tuples, records)\n- Lambda expressions and blocks\n- String interpolation\n- Type annotations","ref":"cure_codegen.html#compile_expression/1-supported-expression-types"},{"type":"function","title":"Error Handling - cure_codegen.compile_expression/1","doc":"Returns detailed error information for unsupported expressions,\ntype mismatches, and compilation failures.","ref":"cure_codegen.html#compile_expression/1-error-handling"},{"type":"function","title":"cure_codegen.compile_expression/2","doc":"","ref":"cure_codegen.html#compile_expression/2"},{"type":"function","title":"cure_codegen.compile_fsm_impl/2","doc":"Compiles a finite state machine definition to BEAM runtime functions.\n\nThis function transforms a Cure FSM definition into executable BEAM code\nthat integrates with the FSM runtime system. It generates helper functions\nfor spawning, controlling, and querying FSM instances.","ref":"cure_codegen.html#compile_fsm_impl/2"},{"type":"function","title":"Arguments - cure_codegen.compile_fsm_impl/2","doc":"- `FSMDef` - FSM definition AST node (#fsm_def{})\n- `State` - Current compilation state","ref":"cure_codegen.html#compile_fsm_impl/2-arguments"},{"type":"function","title":"Returns - cure_codegen.compile_fsm_impl/2","doc":"- `{ok, {fsm, CompiledFSM}, NewState}` - Successfully compiled FSM\n- `{error, Reason}` - Compilation error details","ref":"cure_codegen.html#compile_fsm_impl/2-returns"},{"type":"function","title":"Generated Functions - cure_codegen.compile_fsm_impl/2","doc":"For an FSM named `Counter`, generates:\n- `Counter_spawn/0` - Spawn FSM with default initial state\n- `Counter_spawn/1` - Spawn FSM with custom initial data\n- `Counter_send/2` - Send event to FSM instance\n- `Counter_state/1` - Get current state of FSM instance\n- `Counter_stop/1` - Stop FSM instance gracefully\n- `Counter_definition/0` - Get compiled FSM definition","ref":"cure_codegen.html#compile_fsm_impl/2-generated-functions"},{"type":"function","title":"Example - cure_codegen.compile_fsm_impl/2","doc":"```erlang\nFSM = #fsm_def{\n    name = 'Counter',\n    states = [idle, counting],\n    initial = idle,\n    state_defs = [IdleState, CountingState]\n},\n{ok, {fsm, CompiledFSM}, NewState} = compile_fsm_impl(FSM, State).\n```","ref":"cure_codegen.html#compile_fsm_impl/2-example"},{"type":"function","title":"FSM Runtime Integration - cure_codegen.compile_fsm_impl/2","doc":"- Compiles FSM to cure_fsm_runtime format\n- Generates proper BEAM bytecode for FSM operations\n- Integrates with gen_statem behavior patterns\n- Handles state transitions, events, and timeouts\n- Provides type-safe FSM interface functions","ref":"cure_codegen.html#compile_fsm_impl/2-fsm-runtime-integration"},{"type":"function","title":"State Management - cure_codegen.compile_fsm_impl/2","doc":"FSMs maintain state data through:\n- Initial state setup from spawn parameters\n- State data transformation during transitions\n- Event payload integration with state data\n- Timeout handling with state persistence","ref":"cure_codegen.html#compile_fsm_impl/2-state-management"},{"type":"function","title":"cure_codegen.compile_function/1","doc":"Compiles a single Cure function to BEAM bytecode using default options.\n\nThis function handles standalone function compilation, primarily used for\ntesting and development. In normal compilation, functions are compiled as\npart of module compilation.","ref":"cure_codegen.html#compile_function/1"},{"type":"function","title":"Arguments - cure_codegen.compile_function/1","doc":"- `FunctionAST` - Function AST node (function_def record or tuple format)","ref":"cure_codegen.html#compile_function/1-arguments"},{"type":"function","title":"Returns - cure_codegen.compile_function/1","doc":"- `{ok, CompiledFunction, State}` - Successfully compiled function with state\n- `{error, Reason}` - Compilation error details","ref":"cure_codegen.html#compile_function/1-returns"},{"type":"function","title":"Example - cure_codegen.compile_function/1","doc":"```erlang\nFuncAST = #function_def{\n    name = add,\n    params = [x, y],\n    body = {binary_op, '+', {var, x}, {var, y}}\n},\n{ok, CompiledFunc, _State} = cure_codegen:compile_function(FuncAST).\n```","ref":"cure_codegen.html#compile_function/1-example"},{"type":"function","title":"Function Processing - cure_codegen.compile_function/1","doc":"- Converts function parameters to BEAM registers\n- Compiles function body expressions to BEAM instructions\n- Handles pattern matching in parameters\n- Generates proper function entry and exit code\n- Applies function-level optimizations","ref":"cure_codegen.html#compile_function/1-function-processing"},{"type":"function","title":"Limitations - cure_codegen.compile_function/1","doc":"- Creates minimal compilation state for standalone compilation\n- May not have access to full module context for imports/types\n- Primarily intended for testing individual functions","ref":"cure_codegen.html#compile_function/1-limitations"},{"type":"function","title":"cure_codegen.compile_function/2","doc":"","ref":"cure_codegen.html#compile_function/2"},{"type":"function","title":"cure_codegen.compile_module/1","doc":"Compiles a single Cure module to BEAM bytecode using default options.\n\nThis function handles compilation of complete module definitions including\nexports, imports, function definitions, FSM definitions, and type definitions.\nIt converts Cure module AST to BEAM-compatible Erlang forms.","ref":"cure_codegen.html#compile_module/1"},{"type":"function","title":"Arguments - cure_codegen.compile_module/1","doc":"- `ModuleAST` - Module AST node (module_def record or tuple format)","ref":"cure_codegen.html#compile_module/1-arguments"},{"type":"function","title":"Returns - cure_codegen.compile_module/1","doc":"- `{ok, CompiledModule}` - Successfully compiled module ready for BEAM\n- `{error, Reason}` - Compilation error with details","ref":"cure_codegen.html#compile_module/1-returns"},{"type":"function","title":"Example - cure_codegen.compile_module/1","doc":"```erlang\nModuleAST = #module_def{\n    name = 'MyModule',\n    exports = [{foo, 2}, {bar, 1}],\n    items = [FuncDef1, FuncDef2]\n},\n{ok, BeamModule} = cure_codegen:compile_module(ModuleAST),\ncure_codegen:write_beam_module(BeamModule, \"MyModule.beam\").\n```","ref":"cure_codegen.html#compile_module/1-example"},{"type":"function","title":"Module Processing - cure_codegen.compile_module/1","doc":"- Processes imports and builds import environment\n- Validates and converts export specifications\n- Compiles all module items (functions, FSMs, types)\n- Generates proper BEAM module structure with attributes\n- Handles both old and new AST formats for compatibility","ref":"cure_codegen.html#compile_module/1-module-processing"},{"type":"function","title":"Supported Module Items - cure_codegen.compile_module/1","doc":"- Function definitions (regular and Erlang functions)\n- FSM definitions (compiled to gen_statem)\n- Record and type definitions\n- Import and export declarations","ref":"cure_codegen.html#compile_module/1-supported-module-items"},{"type":"function","title":"cure_codegen.compile_module/2","doc":"","ref":"cure_codegen.html#compile_module/2"},{"type":"function","title":"cure_codegen.compile_patterns_to_case_clauses/2","doc":"","ref":"cure_codegen.html#compile_patterns_to_case_clauses/2"},{"type":"function","title":"cure_codegen.compile_program/1","doc":"Compiles a complete Cure program to BEAM bytecode using default options.\n\nThis is a convenience function that calls compile_program/2 with default\ncompilation options.","ref":"cure_codegen.html#compile_program/1"},{"type":"function","title":"Arguments - cure_codegen.compile_program/1","doc":"- `AST` - List of top-level AST items (modules, functions, etc.)","ref":"cure_codegen.html#compile_program/1-arguments"},{"type":"function","title":"Returns - cure_codegen.compile_program/1","doc":"- `{ok, Modules}` - Successfully compiled modules\n- `{error, {compilation_failed, Errors}}` - Compilation failures","ref":"cure_codegen.html#compile_program/1-returns"},{"type":"function","title":"Example - cure_codegen.compile_program/1","doc":"```erlang\nAST = cure_parser:parse_file(\"program.cure\"),\n{ok, Modules} = cure_codegen:compile_program(AST),\nlists:foreach(fun(Module) ->\n    cure_codegen:write_beam_module(Module, filename(Module))\nend, Modules).\n```","ref":"cure_codegen.html#compile_program/1-example"},{"type":"function","title":"Default Options - cure_codegen.compile_program/1","doc":"Uses standard compilation options: debug_info, optimization level 1,\nwarnings enabled, strict types, and FSM integration.","ref":"cure_codegen.html#compile_program/1-default-options"},{"type":"function","title":"cure_codegen.compile_program/2","doc":"","ref":"cure_codegen.html#compile_program/2"},{"type":"function","title":"cure_codegen.compile_value_to_erlang_form/2","doc":"","ref":"cure_codegen.html#compile_value_to_erlang_form/2"},{"type":"function","title":"cure_codegen.convert_body_expression_to_erlang/2","doc":"","ref":"cure_codegen.html#convert_body_expression_to_erlang/2"},{"type":"function","title":"cure_codegen.convert_list_pattern_to_erlang_form/3","doc":"","ref":"cure_codegen.html#convert_list_pattern_to_erlang_form/3"},{"type":"function","title":"cure_codegen.convert_pattern_to_erlang_form/2","doc":"","ref":"cure_codegen.html#convert_pattern_to_erlang_form/2"},{"type":"function","title":"cure_codegen.convert_to_erlang_forms/1","doc":"","ref":"cure_codegen.html#convert_to_erlang_forms/1"},{"type":"function","title":"cure_codegen.default_options/0","doc":"","ref":"cure_codegen.html#default_options/0"},{"type":"function","title":"cure_codegen.generate_beam_file/2","doc":"Generates a BEAM bytecode file from a compiled Cure module.\n\nThis function converts the internal compiled module representation to\nstandard Erlang abstract forms, then uses the Erlang compiler to produce\na BEAM bytecode file compatible with the Erlang Virtual Machine.","ref":"cure_codegen.html#generate_beam_file/2"},{"type":"function","title":"Arguments - cure_codegen.generate_beam_file/2","doc":"- `Module` - Compiled module data (map with functions, exports, etc.)\n- `OutputPath` - File path where BEAM file should be written","ref":"cure_codegen.html#generate_beam_file/2-arguments"},{"type":"function","title":"Returns - cure_codegen.generate_beam_file/2","doc":"- `{ok, {ModuleName, OutputPath}}` - Successfully generated BEAM file\n- `{error, Reason}` - Generation error details","ref":"cure_codegen.html#generate_beam_file/2-returns"},{"type":"function","title":"Example - cure_codegen.generate_beam_file/2","doc":"```erlang\n{ok, CompiledModule} = cure_codegen:compile_module(ModuleAST),\n{ok, {MyModule, \"MyModule.beam\"}} = \n    cure_codegen:generate_beam_file(CompiledModule, \"MyModule.beam\").\n```","ref":"cure_codegen.html#generate_beam_file/2-example"},{"type":"function","title":"Process Steps - cure_codegen.generate_beam_file/2","doc":"1. **Form Conversion**: Convert internal representation to Erlang forms\n2. **Erlang Compilation**: Use Erlang compiler to generate bytecode\n3. **File Writing**: Write binary BEAM data to specified path\n4. **Error Handling**: Provide detailed errors at each step","ref":"cure_codegen.html#generate_beam_file/2-process-steps"},{"type":"function","title":"BEAM Compatibility - cure_codegen.generate_beam_file/2","doc":"Generated BEAM files are fully compatible with:\n- Standard Erlang/OTP runtime\n- Elixir and other BEAM languages\n- BEAM development and debugging tools\n- Hot code reloading and distribution","ref":"cure_codegen.html#generate_beam_file/2-beam-compatibility"},{"type":"function","title":"Error Types - cure_codegen.generate_beam_file/2","doc":"- `{write_failed, Reason}` - File system errors\n- `{compile_failed, Errors, Warnings}` - Erlang compiler errors\n- Form conversion errors from convert_to_erlang_forms/1","ref":"cure_codegen.html#generate_beam_file/2-error-types"},{"type":"function","title":"cure_codegen.generate_fsm_functions/3","doc":"","ref":"cure_codegen.html#generate_fsm_functions/3"},{"type":"function","title":"cure_codegen.generate_module_attributes/1","doc":"","ref":"cure_codegen.html#generate_module_attributes/1"},{"type":"function","title":"cure_codegen.new_state/0","doc":"","ref":"cure_codegen.html#new_state/0"},{"type":"function","title":"cure_codegen.validate_options/1","doc":"","ref":"cure_codegen.html#validate_options/1"},{"type":"function","title":"cure_codegen.write_beam_module/2","doc":"Writes a compiled Cure module to a BEAM file.\n\nThis is a convenience function that calls generate_beam_file/2 to convert\na compiled module to BEAM bytecode and write it to the specified path.","ref":"cure_codegen.html#write_beam_module/2"},{"type":"function","title":"Arguments - cure_codegen.write_beam_module/2","doc":"- `Module` - Compiled module data from compile_module/1,2\n- `OutputPath` - File path where BEAM file should be written","ref":"cure_codegen.html#write_beam_module/2-arguments"},{"type":"function","title":"Returns - cure_codegen.write_beam_module/2","doc":"- `{ok, {ModuleName, OutputPath}}` - Successfully written BEAM file\n- `{error, Reason}` - File writing or compilation error","ref":"cure_codegen.html#write_beam_module/2-returns"},{"type":"function","title":"Example - cure_codegen.write_beam_module/2","doc":"```erlang\n{ok, CompiledModule} = cure_codegen:compile_module(AST),\n{ok, {MyModule, \"MyModule.beam\"}} = \n    cure_codegen:write_beam_module(CompiledModule, \"MyModule.beam\"),\n\n%% Load and test the module\ncode:load_file(MyModule),\nMyModule:function_name(args).\n```","ref":"cure_codegen.html#write_beam_module/2-example"},{"type":"function","title":"Use Cases - cure_codegen.write_beam_module/2","doc":"- Final step in Cure compilation pipeline\n- Integration with build systems and tools\n- Deployment of Cure modules to BEAM environments\n- Testing and development workflows","ref":"cure_codegen.html#write_beam_module/2-use-cases"},{"type":"module","title":"cure_compile_wrapper","doc":null,"ref":"cure_compile_wrapper.html"},{"type":"function","title":"cure_compile_wrapper.compile_source_file/1","doc":null,"ref":"cure_compile_wrapper.html#compile_source_file/1"},{"type":"function","title":"cure_compile_wrapper.compile_source_file/2","doc":null,"ref":"cure_compile_wrapper.html#compile_source_file/2"},{"type":"function","title":"cure_compile_wrapper.format_error/1","doc":null,"ref":"cure_compile_wrapper.html#format_error/1"},{"type":"function","title":"cure_compile_wrapper.get_error_suggestions/1","doc":null,"ref":"cure_compile_wrapper.html#get_error_suggestions/1"},{"type":"module","title":"cure_error_reporter","doc":"# Cure Error Reporter\n\nEnhanced error reporting module with precise location tracking and\nuser-friendly diagnostic messages. This module provides rich error\nformatting for parser, lexer, and semantic analysis errors.","ref":"cure_error_reporter.html"},{"type":"module","title":"Features - cure_error_reporter","doc":"- **Rich Location Info**: Line, column, and file context\n- **Snippet Display**: Show source code around errors\n- **Suggestions**: Provide helpful hints for common mistakes\n- **Color Formatting**: Terminal color support for better readability\n- **Multi-error Support**: Report multiple errors in batch","ref":"cure_error_reporter.html#module-features"},{"type":"function","title":"cure_error_reporter.create_diagnostic/4","doc":"","ref":"cure_error_reporter.html#create_diagnostic/4"},{"type":"function","title":"cure_error_reporter.format_error/2","doc":"","ref":"cure_error_reporter.html#format_error/2"},{"type":"function","title":"cure_error_reporter.format_error/3","doc":"","ref":"cure_error_reporter.html#format_error/3"},{"type":"function","title":"cure_error_reporter.format_parse_error/4","doc":"","ref":"cure_error_reporter.html#format_parse_error/4"},{"type":"function","title":"cure_error_reporter.format_type_error/4","doc":"","ref":"cure_error_reporter.html#format_type_error/4"},{"type":"function","title":"cure_error_reporter.format_with_snippet/3","doc":"","ref":"cure_error_reporter.html#format_with_snippet/3"},{"type":"module","title":"cure_fsm_builtins","doc":"# Cure Programming Language - FSM Built-in Functions\n\nThis module provides built-in FSM functions that interface directly with the\ncure_fsm_runtime module. These functions are called from Cure programs via\nthe FFI (Foreign Function Interface) to provide FSM functionality.","ref":"cure_fsm_builtins.html"},{"type":"module","title":"Features - cure_fsm_builtins","doc":"","ref":"cure_fsm_builtins.html#module-features"},{"type":"module","title":"FSM Lifecycle Management - cure_fsm_builtins","doc":"- **FSM Spawning**: Create new FSM instances with type validation\n- **FSM Termination**: Graceful shutdown of FSM processes","ref":"cure_fsm_builtins.html#module-fsm-lifecycle-management"},{"type":"module","title":"FSM Operations - cure_fsm_builtins","doc":"- **Event Sending**: Asynchronous event dispatch to FSMs\n- **State Inspection**: Query current FSM state and information\n- **Batch Operations**: Efficient batch event processing","ref":"cure_fsm_builtins.html#module-fsm-operations"},{"type":"module","title":"FSM Utilities - cure_fsm_builtins","doc":"- **Process Monitoring**: Monitor FSM processes for termination\n- **Process Linking**: Bidirectional crash propagation\n- **Timeout Management**: Set and clear FSM timeouts","ref":"cure_fsm_builtins.html#module-fsm-utilities"},{"type":"module","title":"API Design - cure_fsm_builtins","doc":"All functions are designed to be called from Cure programs via FFI.\nThey provide a clean interface to the underlying Erlang FSM runtime.","ref":"cure_fsm_builtins.html#module-api-design"},{"type":"function","title":"cure_fsm_builtins.fsm_clear_timeout/1","doc":"","ref":"cure_fsm_builtins.html#fsm_clear_timeout/1"},{"type":"function","title":"cure_fsm_builtins.fsm_get_performance_stats/1","doc":"","ref":"cure_fsm_builtins.html#fsm_get_performance_stats/1"},{"type":"function","title":"cure_fsm_builtins.fsm_get_registered_types/0","doc":"","ref":"cure_fsm_builtins.html#fsm_get_registered_types/0"},{"type":"function","title":"cure_fsm_builtins.fsm_history/1","doc":"","ref":"cure_fsm_builtins.html#fsm_history/1"},{"type":"function","title":"cure_fsm_builtins.fsm_info/1","doc":"","ref":"cure_fsm_builtins.html#fsm_info/1"},{"type":"function","title":"cure_fsm_builtins.fsm_is_alive/1","doc":"","ref":"cure_fsm_builtins.html#fsm_is_alive/1"},{"type":"function","title":"cure_fsm_builtins.fsm_link/1","doc":"","ref":"cure_fsm_builtins.html#fsm_link/1"},{"type":"function","title":"cure_fsm_builtins.fsm_lookup_definition/1","doc":"","ref":"cure_fsm_builtins.html#fsm_lookup_definition/1"},{"type":"function","title":"cure_fsm_builtins.fsm_monitor/1","doc":"","ref":"cure_fsm_builtins.html#fsm_monitor/1"},{"type":"function","title":"cure_fsm_builtins.fsm_reset_stats/1","doc":"","ref":"cure_fsm_builtins.html#fsm_reset_stats/1"},{"type":"function","title":"cure_fsm_builtins.fsm_send/2","doc":"","ref":"cure_fsm_builtins.html#fsm_send/2"},{"type":"function","title":"cure_fsm_builtins.fsm_send/3","doc":"","ref":"cure_fsm_builtins.html#fsm_send/3"},{"type":"function","title":"cure_fsm_builtins.fsm_send_batch/2","doc":"","ref":"cure_fsm_builtins.html#fsm_send_batch/2"},{"type":"function","title":"cure_fsm_builtins.fsm_set_data/2","doc":"","ref":"cure_fsm_builtins.html#fsm_set_data/2"},{"type":"function","title":"cure_fsm_builtins.fsm_set_timeout/3","doc":"","ref":"cure_fsm_builtins.html#fsm_set_timeout/3"},{"type":"function","title":"cure_fsm_builtins.fsm_spawn/2","doc":"","ref":"cure_fsm_builtins.html#fsm_spawn/2"},{"type":"function","title":"cure_fsm_builtins.fsm_spawn_with_options/3","doc":"","ref":"cure_fsm_builtins.html#fsm_spawn_with_options/3"},{"type":"function","title":"cure_fsm_builtins.fsm_state/1","doc":"","ref":"cure_fsm_builtins.html#fsm_state/1"},{"type":"function","title":"cure_fsm_builtins.fsm_stop/1","doc":"","ref":"cure_fsm_builtins.html#fsm_stop/1"},{"type":"function","title":"cure_fsm_builtins.fsm_unlink/1","doc":"","ref":"cure_fsm_builtins.html#fsm_unlink/1"},{"type":"function","title":"cure_fsm_builtins.fsm_validate_event/2","doc":"","ref":"cure_fsm_builtins.html#fsm_validate_event/2"},{"type":"function","title":"cure_fsm_builtins.fsm_validate_type/1","doc":"","ref":"cure_fsm_builtins.html#fsm_validate_type/1"},{"type":"function","title":"cure_fsm_builtins.register_fsm_builtins/1","doc":"","ref":"cure_fsm_builtins.html#register_fsm_builtins/1"},{"type":"function","title":"cure_fsm_builtins.validate_fsm_event/2","doc":"","ref":"cure_fsm_builtins.html#validate_fsm_event/2"},{"type":"function","title":"cure_fsm_builtins.validate_fsm_type/1","doc":"","ref":"cure_fsm_builtins.html#validate_fsm_type/1"},{"type":"module","title":"cure_fsm_cure_api","doc":"# Cure FSM API Wrapper\n\nThis module provides the Cure-level FSM API that matches the design in lib/std/fsm.cure.\nIt wraps the underlying cure_fsm_runtime gen_server to provide:\n\n- start_fsm/1: Start an FSM instance from a module\n- fsm_cast/2: Send events asynchronously  \n- fsm_advertise/2: Register a name for an FSM\n- fsm_state/1: Query current state and payload\n\nThe FSM definitions in Cure modules are compiled to:\n1. A record type for the payload\n2. A list of transitions with handler functions\n3. An initial state and initial payload\n\nThis module bridges the gap between Cure's high-level FSM syntax and the\nErlang gen_server runtime.","ref":"cure_fsm_cure_api.html"},{"type":"function","title":"cure_fsm_cure_api.fsm_advertise/2","doc":"","ref":"cure_fsm_cure_api.html#fsm_advertise/2"},{"type":"function","title":"cure_fsm_cure_api.fsm_cast/2","doc":"","ref":"cure_fsm_cure_api.html#fsm_cast/2"},{"type":"function","title":"cure_fsm_cure_api.fsm_state/1","doc":"","ref":"cure_fsm_cure_api.html#fsm_state/1"},{"type":"function","title":"cure_fsm_cure_api.start_fsm/1","doc":"","ref":"cure_fsm_cure_api.html#start_fsm/1"},{"type":"module","title":"cure_fsm_runtime","doc":"# Cure Programming Language - FSM Runtime System\n\nThe FSM runtime system provides a comprehensive execution environment for \nfinite state machines in the Cure programming language. It implements a complete\nFSM execution model with state transitions, guard evaluation, action execution,\nand performance optimizations, all built on top of the BEAM virtual machine.","ref":"cure_fsm_runtime.html"},{"type":"module","title":"Core Features - cure_fsm_runtime","doc":"","ref":"cure_fsm_runtime.html#module-core-features"},{"type":"module","title":"FSM Process Management - cure_fsm_runtime","doc":"- **FSM Lifecycle**: Complete process management with start/stop operations\n- **Event Processing**: Synchronous and asynchronous event handling\n- **Batch Operations**: Optimized batch event processing for performance\n- **State Inspection**: Runtime state introspection and debugging support","ref":"cure_fsm_runtime.html#module-fsm-process-management"},{"type":"module","title":"Execution Engine - cure_fsm_runtime","doc":"- **Guard Compilation**: Compiled guard expressions with instruction-based evaluation\n- **Action System**: Compiled action execution with state mutation support\n- **Transition Engine**: Optimized state transition processing with O(1) lookup\n- **Timeout Support**: Built-in timeout handling with automatic state transitions","ref":"cure_fsm_runtime.html#module-execution-engine"},{"type":"module","title":"Performance Optimizations - cure_fsm_runtime","doc":"- **Compiled Guards/Actions**: Pre-compiled instruction sequences for efficiency\n- **Flat Transition Maps**: O(1) transition lookup using optimized data structures\n- **Memory Management**: Automatic event history trimming to prevent memory leaks\n- **Performance Statistics**: Real-time performance monitoring and metrics","ref":"cure_fsm_runtime.html#module-performance-optimizations"},{"type":"module","title":"Registry System - cure_fsm_runtime","doc":"- **FSM Type Registration**: Global registry for FSM type definitions\n- **Dynamic Lookup**: Runtime FSM definition resolution\n- **Type Management**: Registration, unregistration, and type enumeration","ref":"cure_fsm_runtime.html#module-registry-system"},{"type":"module","title":"Architecture - cure_fsm_runtime","doc":"The FSM runtime is built as a gen_server behavior that manages individual FSM\ninstances. Each FSM process maintains its own state, transition table, timeout\nhandlers, and performance statistics.\n\n```erlang\n%% Start a traffic light FSM\n{ok, FSM} = cure_fsm_runtime:start_fsm(traffic_light, #{}).\n\n%% Send events to the FSM\ncure_fsm_runtime:send_event(FSM, timer_expired),\ncure_fsm_runtime:send_event(FSM, emergency_stop).\n\n%% Get current state\n{ok, State} = cure_fsm_runtime:get_state(FSM).\n```","ref":"cure_fsm_runtime.html#module-architecture"},{"type":"module","title":"Event Processing Model - cure_fsm_runtime","doc":"Events are processed through a multi-stage pipeline:\n1. **Event Reception**: Events arrive via gen_server casts/calls\n2. **Transition Lookup**: O(1) lookup in flat transition map\n3. **Guard Evaluation**: Compiled guard instruction execution\n4. **Action Execution**: Compiled action instruction execution with state updates\n5. **State Transition**: Atomic state change with history tracking\n6. **Timeout Management**: Automatic timeout setting/clearing","ref":"cure_fsm_runtime.html#module-event-processing-model"},{"type":"module","title":"Compilation Pipeline - cure_fsm_runtime","doc":"FSM definitions undergo compilation from AST to optimized runtime format:\n- **Transition Compilation**: Nested AST transitions → flat lookup maps\n- **Guard Compilation**: AST expressions → instruction sequences\n- **Action Compilation**: AST actions → stack-based instructions\n- **Timeout Compilation**: Timeout definitions → runtime timeout handlers","ref":"cure_fsm_runtime.html#module-compilation-pipeline"},{"type":"module","title":"Performance Characteristics - cure_fsm_runtime","doc":"- **Event Processing**: < 10μs per event (compiled guards/actions)\n- **State Transitions**: O(1) lookup time\n- **Memory Usage**: Bounded with automatic history trimming\n- **Throughput**: > 100K events/second per FSM instance\n- **Batch Processing**: Up to 10x improvement for bulk operations","ref":"cure_fsm_runtime.html#module-performance-characteristics"},{"type":"module","title":"Error Handling - cure_fsm_runtime","doc":"The runtime provides comprehensive error handling:\n- **Guard Failures**: Safe evaluation with automatic fallback to false\n- **Action Errors**: Safe execution with state preservation on failure  \n- **Timeout Handling**: Robust timeout management with cleanup\n- **Type Safety**: Runtime type checking and validation","ref":"cure_fsm_runtime.html#module-error-handling"},{"type":"module","title":"Integration - cure_fsm_runtime","doc":"The FSM runtime integrates with:\n- **Cure Compiler**: Receives compiled FSM definitions from type checker\n- **Guard Compiler**: Uses compiled guard expressions for efficiency\n- **Action Compiler**: Executes compiled action instruction sequences\n- **BEAM Runtime**: Built on standard OTP gen_server behavior","ref":"cure_fsm_runtime.html#module-integration"},{"type":"function","title":"cure_fsm_runtime.clear_fsm_registry/0","doc":"Clears all FSM type definitions from the global registry.","ref":"cure_fsm_runtime.html#clear_fsm_registry/0"},{"type":"function","title":"Returns - cure_fsm_runtime.clear_fsm_registry/0","doc":"- `ok` - Registry cleared successfully","ref":"cure_fsm_runtime.html#clear_fsm_registry/0-returns"},{"type":"function","title":"Warning - cure_fsm_runtime.clear_fsm_registry/0","doc":"This function removes ALL registered FSM types. Use with caution.","ref":"cure_fsm_runtime.html#clear_fsm_registry/0-warning"},{"type":"function","title":"Example - cure_fsm_runtime.clear_fsm_registry/0","doc":"```erlang\ncure_fsm_runtime:clear_fsm_registry().\n```","ref":"cure_fsm_runtime.html#clear_fsm_registry/0-example"},{"type":"function","title":"cure_fsm_runtime.clear_timeout/1","doc":"Clears any existing timeout for the FSM.","ref":"cure_fsm_runtime.html#clear_timeout/1"},{"type":"function","title":"Arguments - cure_fsm_runtime.clear_timeout/1","doc":"- `FSMPid` - The PID of the FSM process","ref":"cure_fsm_runtime.html#clear_timeout/1-arguments"},{"type":"function","title":"Returns - cure_fsm_runtime.clear_timeout/1","doc":"- `ok` - Timeout cleared successfully (asynchronous)","ref":"cure_fsm_runtime.html#clear_timeout/1-returns"},{"type":"function","title":"Example - cure_fsm_runtime.clear_timeout/1","doc":"```erlang\ncure_fsm_runtime:clear_timeout(FSMPid).\n```","ref":"cure_fsm_runtime.html#clear_timeout/1-example"},{"type":"function","title":"cure_fsm_runtime.code_change/3","doc":"","ref":"cure_fsm_runtime.html#code_change/3"},{"type":"function","title":"cure_fsm_runtime.compile_fsm_definition/1","doc":"Compiles an FSM definition from AST format to optimized runtime format.\n\nThis function transforms a parsed FSM definition into an efficient runtime\nrepresentation with pre-compiled guards, actions, and optimized transition lookups.","ref":"cure_fsm_runtime.html#compile_fsm_definition/1"},{"type":"function","title":"Arguments - cure_fsm_runtime.compile_fsm_definition/1","doc":"- `FSMDef` - FSM definition record from the parser containing:\n  - `name` - FSM type name\n  - `states` - List of state names\n  - `initial` - Initial state name\n  - `state_defs` - List of state definition records","ref":"cure_fsm_runtime.html#compile_fsm_definition/1-arguments"},{"type":"function","title":"Returns - cure_fsm_runtime.compile_fsm_definition/1","doc":"- `#fsm_definition{}` - Compiled FSM definition ready for runtime execution","ref":"cure_fsm_runtime.html#compile_fsm_definition/1-returns"},{"type":"function","title":"Compilation Process - cure_fsm_runtime.compile_fsm_definition/1","doc":"1. **Transition Compilation**: Creates flat lookup maps from nested AST\n2. **Guard Compilation**: Compiles guard expressions to instruction sequences\n3. **Action Compilation**: Compiles action expressions to stack-based instructions\n4. **Timeout Compilation**: Extracts and organizes timeout definitions","ref":"cure_fsm_runtime.html#compile_fsm_definition/1-compilation-process"},{"type":"function","title":"Example - cure_fsm_runtime.compile_fsm_definition/1","doc":"```erlang\nCompiledDef = cure_fsm_runtime:compile_fsm_definition(ParsedFSM),\ncure_fsm_runtime:register_fsm_type(my_fsm, CompiledDef).\n```","ref":"cure_fsm_runtime.html#compile_fsm_definition/1-example"},{"type":"function","title":"cure_fsm_runtime.get_current_state/1","doc":"","ref":"cure_fsm_runtime.html#get_current_state/1"},{"type":"function","title":"cure_fsm_runtime.get_fsm_info/1","doc":"Retrieves comprehensive FSM information for debugging and introspection.","ref":"cure_fsm_runtime.html#get_fsm_info/1"},{"type":"function","title":"Arguments - cure_fsm_runtime.get_fsm_info/1","doc":"- `FSMPid` - The PID of the FSM process","ref":"cure_fsm_runtime.html#get_fsm_info/1-arguments"},{"type":"function","title":"Returns - cure_fsm_runtime.get_fsm_info/1","doc":"- `{ok, Info}` - Map containing FSM information:\n  - `fsm_type` - The FSM type name\n  - `current_state` - Current state name\n  - `data` - Current state data\n  - `event_history` - List of recent events (newest first)\n- `{error, Reason}` - Error retrieving information","ref":"cure_fsm_runtime.html#get_fsm_info/1-returns"},{"type":"function","title":"Example - cure_fsm_runtime.get_fsm_info/1","doc":"```erlang\n{ok, #{fsm_type := Type, current_state := State}} = \n    cure_fsm_runtime:get_fsm_info(FSMPid).\n```","ref":"cure_fsm_runtime.html#get_fsm_info/1-example"},{"type":"function","title":"cure_fsm_runtime.get_performance_stats/1","doc":"Retrieves performance statistics for an FSM instance.","ref":"cure_fsm_runtime.html#get_performance_stats/1"},{"type":"function","title":"Arguments - cure_fsm_runtime.get_performance_stats/1","doc":"- `FSMPid` - The PID of the FSM process","ref":"cure_fsm_runtime.html#get_performance_stats/1-arguments"},{"type":"function","title":"Returns - cure_fsm_runtime.get_performance_stats/1","doc":"- `{ok, Stats}` - Performance statistics record containing:\n  - `events_processed` - Total number of events processed\n  - `avg_event_time` - Average event processing time (microseconds)\n  - `max_event_time` - Maximum event processing time (microseconds)\n  - `memory_usage` - Current memory usage (bytes)\n  - `last_updated` - Timestamp of last update\n- `{error, Reason}` - Error retrieving statistics","ref":"cure_fsm_runtime.html#get_performance_stats/1-returns"},{"type":"function","title":"Example - cure_fsm_runtime.get_performance_stats/1","doc":"```erlang\n{ok, Stats} = cure_fsm_runtime:get_performance_stats(FSMPid),\nAvgTime = Stats#fsm_perf_stats.avg_event_time.\n```","ref":"cure_fsm_runtime.html#get_performance_stats/1-example"},{"type":"function","title":"cure_fsm_runtime.get_registered_fsm_types/0","doc":"Returns a list of all registered FSM type names.","ref":"cure_fsm_runtime.html#get_registered_fsm_types/0"},{"type":"function","title":"Returns - cure_fsm_runtime.get_registered_fsm_types/0","doc":"- List of FSM type names (atoms)","ref":"cure_fsm_runtime.html#get_registered_fsm_types/0-returns"},{"type":"function","title":"Example - cure_fsm_runtime.get_registered_fsm_types/0","doc":"```erlang\nTypes = cure_fsm_runtime:get_registered_fsm_types(),\n%% Types might be [counter, traffic_light, state_machine]\n```","ref":"cure_fsm_runtime.html#get_registered_fsm_types/0-example"},{"type":"function","title":"cure_fsm_runtime.get_state/1","doc":"Retrieves the current state of an FSM instance.","ref":"cure_fsm_runtime.html#get_state/1"},{"type":"function","title":"Arguments - cure_fsm_runtime.get_state/1","doc":"- `FSMPid` - The PID of the FSM process","ref":"cure_fsm_runtime.html#get_state/1-arguments"},{"type":"function","title":"Returns - cure_fsm_runtime.get_state/1","doc":"- `{ok, State}` - The current state name (atom)\n- `{error, Reason}` - Error retrieving state","ref":"cure_fsm_runtime.html#get_state/1-returns"},{"type":"function","title":"Example - cure_fsm_runtime.get_state/1","doc":"```erlang\n{ok, CurrentState} = cure_fsm_runtime:get_state(FSMPid).\n```","ref":"cure_fsm_runtime.html#get_state/1-example"},{"type":"function","title":"cure_fsm_runtime.handle_call/3","doc":"","ref":"cure_fsm_runtime.html#handle_call/3"},{"type":"function","title":"cure_fsm_runtime.handle_cast/2","doc":"","ref":"cure_fsm_runtime.html#handle_cast/2"},{"type":"function","title":"cure_fsm_runtime.handle_info/2","doc":"","ref":"cure_fsm_runtime.html#handle_info/2"},{"type":"function","title":"cure_fsm_runtime.init/1","doc":"","ref":"cure_fsm_runtime.html#init/1"},{"type":"function","title":"cure_fsm_runtime.list_running_fsms/0","doc":"","ref":"cure_fsm_runtime.html#list_running_fsms/0"},{"type":"function","title":"cure_fsm_runtime.lookup_fsm/1","doc":"","ref":"cure_fsm_runtime.html#lookup_fsm/1"},{"type":"function","title":"cure_fsm_runtime.lookup_fsm_definition/1","doc":"Looks up an FSM definition by type name in the global registry.","ref":"cure_fsm_runtime.html#lookup_fsm_definition/1"},{"type":"function","title":"Arguments - cure_fsm_runtime.lookup_fsm_definition/1","doc":"- `FSMType` - The FSM type name to look up (atom)","ref":"cure_fsm_runtime.html#lookup_fsm_definition/1-arguments"},{"type":"function","title":"Returns - cure_fsm_runtime.lookup_fsm_definition/1","doc":"- `{ok, Definition}` - FSM definition found\n- `{error, not_found}` - FSM type not registered","ref":"cure_fsm_runtime.html#lookup_fsm_definition/1-returns"},{"type":"function","title":"Example - cure_fsm_runtime.lookup_fsm_definition/1","doc":"```erlang\ncase cure_fsm_runtime:lookup_fsm_definition(counter) of\n    {ok, Definition} -> cure_utils:debug(\"Found FSM definition~n\");\n    {error, not_found} -> cure_utils:debug(\"FSM type not registered~n\")\nend.\n```","ref":"cure_fsm_runtime.html#lookup_fsm_definition/1-example"},{"type":"function","title":"cure_fsm_runtime.receive_message/1","doc":"","ref":"cure_fsm_runtime.html#receive_message/1"},{"type":"function","title":"cure_fsm_runtime.receive_message/2","doc":"","ref":"cure_fsm_runtime.html#receive_message/2"},{"type":"function","title":"cure_fsm_runtime.register_fsm_type/2","doc":"Registers a new FSM type definition in the global registry.","ref":"cure_fsm_runtime.html#register_fsm_type/2"},{"type":"function","title":"Arguments - cure_fsm_runtime.register_fsm_type/2","doc":"- `FSMType` - The FSM type name (atom)\n- `Definition` - Compiled FSM definition record","ref":"cure_fsm_runtime.html#register_fsm_type/2-arguments"},{"type":"function","title":"Returns - cure_fsm_runtime.register_fsm_type/2","doc":"- `ok` - FSM type registered successfully","ref":"cure_fsm_runtime.html#register_fsm_type/2-returns"},{"type":"function","title":"Example - cure_fsm_runtime.register_fsm_type/2","doc":"```erlang\nDefinition = #fsm_definition{name = counter, ...},\nok = cure_fsm_runtime:register_fsm_type(counter, Definition).\n```","ref":"cure_fsm_runtime.html#register_fsm_type/2-example"},{"type":"function","title":"cure_fsm_runtime.register_fsm_type/4","doc":"","ref":"cure_fsm_runtime.html#register_fsm_type/4"},{"type":"function","title":"cure_fsm_runtime.send_batch_events/2","doc":"Sends multiple events to an FSM in a single operation for improved performance.","ref":"cure_fsm_runtime.html#send_batch_events/2"},{"type":"function","title":"Arguments - cure_fsm_runtime.send_batch_events/2","doc":"- `FSMPid` - The PID of the FSM process\n- `Events` - List of events to send. Each event can be:\n  - An atom (event without data)\n  - A tuple `{Event, Data}` (event with data)","ref":"cure_fsm_runtime.html#send_batch_events/2-arguments"},{"type":"function","title":"Returns - cure_fsm_runtime.send_batch_events/2","doc":"- `ok` - Batch sent successfully (asynchronous)","ref":"cure_fsm_runtime.html#send_batch_events/2-returns"},{"type":"function","title":"Performance - cure_fsm_runtime.send_batch_events/2","doc":"Batch processing can provide 5-10x performance improvement over individual\nevent sends when processing large numbers of events.","ref":"cure_fsm_runtime.html#send_batch_events/2-performance"},{"type":"function","title":"Example - cure_fsm_runtime.send_batch_events/2","doc":"```erlang\nEvents = [start, {increment, 5}, stop],\ncure_fsm_runtime:send_batch_events(FSMPid, Events).\n```","ref":"cure_fsm_runtime.html#send_batch_events/2-example"},{"type":"function","title":"cure_fsm_runtime.send_event/2","doc":"Sends an event to an FSM instance without event data.\n\nThis is a convenience function that calls send_event/3 with undefined event data.","ref":"cure_fsm_runtime.html#send_event/2"},{"type":"function","title":"Arguments - cure_fsm_runtime.send_event/2","doc":"- `FSMPid` - The PID of the target FSM process\n- `Event` - The event to send (atom)","ref":"cure_fsm_runtime.html#send_event/2-arguments"},{"type":"function","title":"Returns - cure_fsm_runtime.send_event/2","doc":"- `ok` - Event sent successfully (asynchronous)","ref":"cure_fsm_runtime.html#send_event/2-returns"},{"type":"function","title":"Example - cure_fsm_runtime.send_event/2","doc":"```erlang\ncure_fsm_runtime:send_event(FSMPid, start).\n```","ref":"cure_fsm_runtime.html#send_event/2-example"},{"type":"function","title":"cure_fsm_runtime.send_event/3","doc":"Sends an event with associated data to an FSM instance.","ref":"cure_fsm_runtime.html#send_event/3"},{"type":"function","title":"Arguments - cure_fsm_runtime.send_event/3","doc":"- `FSMPid` - The PID of the target FSM process\n- `Event` - The event to send (atom)\n- `Data` - Event data to accompany the event","ref":"cure_fsm_runtime.html#send_event/3-arguments"},{"type":"function","title":"Returns - cure_fsm_runtime.send_event/3","doc":"- `ok` - Event sent successfully (asynchronous)","ref":"cure_fsm_runtime.html#send_event/3-returns"},{"type":"function","title":"Example - cure_fsm_runtime.send_event/3","doc":"```erlang\ncure_fsm_runtime:send_event(FSMPid, button_pressed, #{button => ok}).\n```","ref":"cure_fsm_runtime.html#send_event/3-example"},{"type":"function","title":"cure_fsm_runtime.send_message/2","doc":"","ref":"cure_fsm_runtime.html#send_message/2"},{"type":"function","title":"cure_fsm_runtime.send_message/3","doc":"","ref":"cure_fsm_runtime.html#send_message/3"},{"type":"function","title":"cure_fsm_runtime.set_timeout/3","doc":"Sets a timeout for the FSM that will trigger the specified event after the given time.","ref":"cure_fsm_runtime.html#set_timeout/3"},{"type":"function","title":"Arguments - cure_fsm_runtime.set_timeout/3","doc":"- `FSMPid` - The PID of the FSM process\n- `Timeout` - Timeout in milliseconds\n- `Event` - Event to trigger when timeout occurs","ref":"cure_fsm_runtime.html#set_timeout/3-arguments"},{"type":"function","title":"Returns - cure_fsm_runtime.set_timeout/3","doc":"- `ok` - Timeout set successfully (asynchronous)","ref":"cure_fsm_runtime.html#set_timeout/3-returns"},{"type":"function","title":"Example - cure_fsm_runtime.set_timeout/3","doc":"```erlang\ncure_fsm_runtime:set_timeout(FSMPid, 5000, timeout_expired).\n```","ref":"cure_fsm_runtime.html#set_timeout/3-example"},{"type":"function","title":"cure_fsm_runtime.spawn_fsm/1","doc":"","ref":"cure_fsm_runtime.html#spawn_fsm/1"},{"type":"function","title":"cure_fsm_runtime.spawn_fsm/3","doc":"","ref":"cure_fsm_runtime.html#spawn_fsm/3"},{"type":"function","title":"cure_fsm_runtime.spawn_fsm/4","doc":"","ref":"cure_fsm_runtime.html#spawn_fsm/4"},{"type":"function","title":"cure_fsm_runtime.start_fsm/2","doc":"Starts a new FSM instance with the specified type and initial data.\n\nThis is a convenience function that calls start_fsm/3 with an empty options list.","ref":"cure_fsm_runtime.html#start_fsm/2"},{"type":"function","title":"Arguments - cure_fsm_runtime.start_fsm/2","doc":"- `FSMType` - The registered FSM type name (atom)\n- `InitialData` - Initial state data for the FSM instance","ref":"cure_fsm_runtime.html#start_fsm/2-arguments"},{"type":"function","title":"Returns - cure_fsm_runtime.start_fsm/2","doc":"- `{ok, Pid}` - Success with the FSM process PID\n- `{error, {fsm_type_not_found, FSMType}}` - FSM type not registered\n- `{error, Reason}` - Other gen_server startup errors","ref":"cure_fsm_runtime.html#start_fsm/2-returns"},{"type":"function","title":"Example - cure_fsm_runtime.start_fsm/2","doc":"```erlang\n{ok, FSM} = cure_fsm_runtime:start_fsm(counter, #{count => 0}).\n```","ref":"cure_fsm_runtime.html#start_fsm/2-example"},{"type":"function","title":"cure_fsm_runtime.start_fsm/3","doc":"Starts a new FSM instance with the specified type, initial data, and options.","ref":"cure_fsm_runtime.html#start_fsm/3"},{"type":"function","title":"Arguments - cure_fsm_runtime.start_fsm/3","doc":"- `FSMType` - The registered FSM type name (atom)\n- `InitialData` - Initial state data for the FSM instance\n- `Options` - List of startup options (currently unused)","ref":"cure_fsm_runtime.html#start_fsm/3-arguments"},{"type":"function","title":"Returns - cure_fsm_runtime.start_fsm/3","doc":"- `{ok, Pid}` - Success with the FSM process PID\n- `{error, {fsm_type_not_found, FSMType}}` - FSM type not registered\n- `{error, Reason}` - Other gen_server startup errors","ref":"cure_fsm_runtime.html#start_fsm/3-returns"},{"type":"function","title":"Example - cure_fsm_runtime.start_fsm/3","doc":"```erlang\n{ok, FSM} = cure_fsm_runtime:start_fsm(traffic_light, #{}, []).\n```","ref":"cure_fsm_runtime.html#start_fsm/3-example"},{"type":"function","title":"cure_fsm_runtime.stop_fsm/1","doc":"Stops an FSM instance gracefully.","ref":"cure_fsm_runtime.html#stop_fsm/1"},{"type":"function","title":"Arguments - cure_fsm_runtime.stop_fsm/1","doc":"- `FSMPid` - The PID of the FSM process to stop","ref":"cure_fsm_runtime.html#stop_fsm/1-arguments"},{"type":"function","title":"Returns - cure_fsm_runtime.stop_fsm/1","doc":"- `ok` - FSM stopped successfully\n- `{error, Reason}` - Error stopping the FSM","ref":"cure_fsm_runtime.html#stop_fsm/1-returns"},{"type":"function","title":"Example - cure_fsm_runtime.stop_fsm/1","doc":"```erlang\nok = cure_fsm_runtime:stop_fsm(FSMPid).\n```","ref":"cure_fsm_runtime.html#stop_fsm/1-example"},{"type":"function","title":"cure_fsm_runtime.terminate/2","doc":"","ref":"cure_fsm_runtime.html#terminate/2"},{"type":"function","title":"cure_fsm_runtime.unregister_fsm_type/1","doc":"Removes an FSM type definition from the global registry.","ref":"cure_fsm_runtime.html#unregister_fsm_type/1"},{"type":"function","title":"Arguments - cure_fsm_runtime.unregister_fsm_type/1","doc":"- `FSMType` - The FSM type name to unregister (atom)","ref":"cure_fsm_runtime.html#unregister_fsm_type/1-arguments"},{"type":"function","title":"Returns - cure_fsm_runtime.unregister_fsm_type/1","doc":"- `true` - FSM type unregistered successfully (or did not exist)","ref":"cure_fsm_runtime.html#unregister_fsm_type/1-returns"},{"type":"function","title":"Example - cure_fsm_runtime.unregister_fsm_type/1","doc":"```erlang\ncure_fsm_runtime:unregister_fsm_type(old_counter).\n```","ref":"cure_fsm_runtime.html#unregister_fsm_type/1-example"},{"type":"module","title":"cure_guard_codegen","doc":"# Guard Validation Code Generation\n\nThis module generates runtime validation code for dependent type guards.\nIt translates guard constraints into executable BEAM code that validates\nvalues against dependent type requirements.","ref":"cure_guard_codegen.html"},{"type":"module","title":"Features - cure_guard_codegen","doc":"- **Dependent Type Validation**: Generate checks for dependent type constraints\n- **Optimized Code**: Efficient guard code with minimal runtime overhead\n- **SMT Integration**: Use SMT solver results to optimize guard checks\n- **Error Reporting**: Generate informative error messages for failed guards","ref":"cure_guard_codegen.html#module-features"},{"type":"module","title":"Guard Types - cure_guard_codegen","doc":"","ref":"cure_guard_codegen.html#module-guard-types"},{"type":"module","title":"Numeric Constraints - cure_guard_codegen","doc":"```cure\nVector(T, n: Nat) when n > 0\n```\nGenerates: Runtime check that n > 0","ref":"cure_guard_codegen.html#module-numeric-constraints"},{"type":"module","title":"Refinement Types - cure_guard_codegen","doc":"```cure\nNonEmpty(T) = List(T, n) when n > 0\n```\nGenerates: Length check for lists","ref":"cure_guard_codegen.html#module-refinement-types"},{"type":"module","title":"Complex Constraints - cure_guard_codegen","doc":"```cure\nMatrix(T, rows: Nat, cols: Nat) when rows > 0 and cols > 0\n```\nGenerates: Multiple validation checks","ref":"cure_guard_codegen.html#module-complex-constraints"},{"type":"module","title":"Code Generation Strategy - cure_guard_codegen","doc":"1. **Static Analysis**: Use SMT solver to prove constraints at compile time\n2. **Runtime Guards**: Generate checks for constraints that can't be proven\n3. **Optimization**: Eliminate redundant checks through dataflow analysis\n4. **Caching**: Cache validation results for expensive computations","ref":"cure_guard_codegen.html#module-code-generation-strategy"},{"type":"function","title":"cure_guard_codegen.clear_proof_cache/0","doc":"","ref":"cure_guard_codegen.html#clear_proof_cache/0"},{"type":"function","title":"cure_guard_codegen.compile_constraint/2","doc":"","ref":"cure_guard_codegen.html#compile_constraint/2"},{"type":"function","title":"cure_guard_codegen.generate_guard/2","doc":"","ref":"cure_guard_codegen.html#generate_guard/2"},{"type":"function","title":"cure_guard_codegen.generate_guard/3","doc":"","ref":"cure_guard_codegen.html#generate_guard/3"},{"type":"function","title":"cure_guard_codegen.generate_validation_function/3","doc":"","ref":"cure_guard_codegen.html#generate_validation_function/3"},{"type":"function","title":"cure_guard_codegen.optimize_guard/2","doc":"","ref":"cure_guard_codegen.html#optimize_guard/2"},{"type":"type","title":"cure_guard_codegen.expr/0","doc":"","ref":"cure_guard_codegen.html#t:expr/0"},{"type":"module","title":"cure_guard_compiler","doc":null,"ref":"cure_guard_compiler.html"},{"type":"function","title":"cure_guard_compiler.compile_guard/2","doc":null,"ref":"cure_guard_compiler.html#compile_guard/2"},{"type":"function","title":"cure_guard_compiler.compile_guards/2","doc":null,"ref":"cure_guard_compiler.html#compile_guards/2"},{"type":"function","title":"cure_guard_compiler.is_guard_safe/1","doc":null,"ref":"cure_guard_compiler.html#is_guard_safe/1"},{"type":"function","title":"cure_guard_compiler.optimize_guard/1","doc":null,"ref":"cure_guard_compiler.html#optimize_guard/1"},{"type":"module","title":"cure_lexer","doc":"# Cure Programming Language - Lexer\n\nThe lexer module provides tokenization services for Cure source code, converting\nraw text into a structured stream of tokens for the parser. It supports all Cure\nlanguage constructs including keywords, operators, literals, and comments.","ref":"cure_lexer.html"},{"type":"module","title":"Features - cure_lexer","doc":"- **Position Tracking**: Every token includes precise line and column information\n- **String Interpolation**: Support for `#{expr}` string interpolation syntax\n- **Multi-character Operators**: Recognition of operators like `->`, `|>`, `::`, etc.\n- **Comprehensive Literals**: Numbers, strings, atoms, and boolean values\n- **Keywords**: All Cure language keywords including FSM constructs\n- **Error Recovery**: Detailed error reporting with location information","ref":"cure_lexer.html#module-features"},{"type":"module","title":"Token Types - cure_lexer","doc":"The lexer recognizes the following token categories:\n\n- **Keywords**: `def`, `fsm`, `match`, `when`, etc.\n- **Identifiers**: Variable and function names\n- **Literals**: Numbers, strings, atoms, booleans\n- **Operators**: `+`, `->`, `|>`, `::`, `==`, etc.\n- **Delimiters**: `()`, `[]`, `{}`, `,`, `;`, etc.\n- **Comments**: Line comments starting with `#`","ref":"cure_lexer.html#module-token-types"},{"type":"module","title":"String Interpolation - cure_lexer","doc":"Supports string interpolation with `#{expression}` syntax:\n\n```cure\n\"Hello #{name}!\"  % Tokenized as interpolated string\n```","ref":"cure_lexer.html#module-string-interpolation"},{"type":"module","title":"Error Handling - cure_lexer","doc":"All tokenization errors include precise location information:\n\n```erlang\n{error, {Reason, Line, Column}}\n```","ref":"cure_lexer.html#module-error-handling"},{"type":"function","title":"cure_lexer.scan/1","doc":"","ref":"cure_lexer.html#scan/1"},{"type":"function","title":"cure_lexer.token_type/1","doc":"Extract the type from a token record.\n\nThis utility function extracts the token type, which is useful for\npattern matching and categorizing tokens in the parser.","ref":"cure_lexer.html#token_type/1"},{"type":"function","title":"Arguments - cure_lexer.token_type/1","doc":"- `Token` - Token record to extract type from","ref":"cure_lexer.html#token_type/1-arguments"},{"type":"function","title":"Returns - cure_lexer.token_type/1","doc":"- Atom representing the token type (e.g., `def`, `identifier`, `number`)","ref":"cure_lexer.html#token_type/1-returns"},{"type":"function","title":"Examples - cure_lexer.token_type/1","doc":"```erlang\nToken = #token{type = identifier, value = <<\"add\">>, line = 1, column = 5},\ntoken_type(Token).\n% => identifier\n\nKeywordToken = #token{type = def, value = def, line = 1, column = 1},\ntoken_type(KeywordToken).\n% => def\n```","ref":"cure_lexer.html#token_type/1-examples"},{"type":"function","title":"cure_lexer.tokenize/1","doc":"Tokenize a string of Cure source code into a list of tokens.\n\nThis is the main entry point for lexical analysis. It processes the entire\ninput and returns a list of tokens with position information.","ref":"cure_lexer.html#tokenize/1"},{"type":"function","title":"Arguments - cure_lexer.tokenize/1","doc":"- `Source` - Binary containing Cure source code to tokenize","ref":"cure_lexer.html#tokenize/1-arguments"},{"type":"function","title":"Returns - cure_lexer.tokenize/1","doc":"- `{ok, Tokens}` - Successful tokenization with list of token records\n- `{error, {Reason, Line, Column}}` - Tokenization error with location\n- `{error, {Error, Reason, Stack}}` - Internal error with stack trace","ref":"cure_lexer.html#tokenize/1-returns"},{"type":"function","title":"Token Record - cure_lexer.tokenize/1","doc":"Each token is a record with fields:\n- `type` - Token type atom (e.g., `identifier`, `number`, `def`)\n- `value` - Token value (e.g., variable name, number value)\n- `line` - Line number (1-based)\n- `column` - Column number (1-based)","ref":"cure_lexer.html#tokenize/1-token-record"},{"type":"function","title":"Examples - cure_lexer.tokenize/1","doc":"```erlang\ntokenize(<<\"def add(x, y) = x + y\">>).\n% => {ok, [\n%      #token{type=def, value=def, line=1, column=1},\n%      #token{type=identifier, value= <<\"add\">>, line=1, column=5},\n%      #token{type='(', value='(', line=1, column=8},\n%      ...\n%    ]}\n\ntokenize(<<\"invalid \\xff character\">>).\n% => {error, {invalid_character, 1, 9}}\n```","ref":"cure_lexer.html#tokenize/1-examples"},{"type":"function","title":"Error Types - cure_lexer.tokenize/1","doc":"- `invalid_character` - Unrecognized character in input\n- `unterminated_string` - String literal without closing quote\n- `invalid_number_format` - Malformed numeric literal\n- `unterminated_comment` - Block comment without proper termination","ref":"cure_lexer.html#tokenize/1-error-types"},{"type":"function","title":"cure_lexer.tokenize_file/1","doc":"Tokenize a Cure source file.\n\nThis is a convenience function that reads a file from disk and tokenizes\nits contents. It handles file I/O errors and passes the content to the\nmain tokenization function.","ref":"cure_lexer.html#tokenize_file/1"},{"type":"function","title":"Arguments - cure_lexer.tokenize_file/1","doc":"- `Filename` - Path to the .cure source file to tokenize","ref":"cure_lexer.html#tokenize_file/1-arguments"},{"type":"function","title":"Returns - cure_lexer.tokenize_file/1","doc":"- `{ok, Tokens}` - Successful tokenization with list of token records\n- `{error, {file_error, Reason}}` - File I/O error\n- `{error, {Reason, Line, Column}}` - Tokenization error with location","ref":"cure_lexer.html#tokenize_file/1-returns"},{"type":"function","title":"Examples - cure_lexer.tokenize_file/1","doc":"```erlang\ntokenize_file(\"examples/hello.cure\").\n% => {ok, [#token{type=def, ...}, ...]}\n\ntokenize_file(\"nonexistent.cure\").\n% => {error, {file_error, enoent}}\n```","ref":"cure_lexer.html#tokenize_file/1-examples"},{"type":"module","title":"cure_lsp_server","doc":"# Cure Language Server Protocol (LSP) Implementation\n\nThis module implements the Language Server Protocol for the Cure programming language,\nproviding IDE features like:\n\n- Real-time syntax checking\n- Type inference hints\n- Go-to-definition\n- Hover information\n- Code completion\n- Diagnostics reporting","ref":"cure_lsp_server.html"},{"type":"module","title":"LSP Protocol - cure_lsp_server","doc":"The server communicates over JSON-RPC 2.0 using stdio or TCP socket.","ref":"cure_lsp_server.html#module-lsp-protocol"},{"type":"module","title":"Features - cure_lsp_server","doc":"","ref":"cure_lsp_server.html#module-features"},{"type":"module","title":"Implemented - cure_lsp_server","doc":"- `initialize` - Server initialization\n- `textDocument/didOpen` - Document opened\n- `textDocument/didChange` - Document changed\n- `textDocument/didSave` - Document saved\n- `textDocument/didClose` - Document closed\n- `textDocument/hover` - Hover information\n- `textDocument/diagnostic` - Real-time diagnostics","ref":"cure_lsp_server.html#module-implemented"},{"type":"module","title":"Planned - cure_lsp_server","doc":"- `textDocument/completion` - Code completion\n- `textDocument/definition` - Go to definition\n- `textDocument/references` - Find references\n- `textDocument/rename` - Symbol renaming","ref":"cure_lsp_server.html#module-planned"},{"type":"function","title":"cure_lsp_server.code_change/3","doc":"","ref":"cure_lsp_server.html#code_change/3"},{"type":"function","title":"cure_lsp_server.get_diagnostics/1","doc":"","ref":"cure_lsp_server.html#get_diagnostics/1"},{"type":"function","title":"cure_lsp_server.handle_call/3","doc":"","ref":"cure_lsp_server.html#handle_call/3"},{"type":"function","title":"cure_lsp_server.handle_cast/2","doc":"","ref":"cure_lsp_server.html#handle_cast/2"},{"type":"function","title":"cure_lsp_server.handle_info/2","doc":"","ref":"cure_lsp_server.html#handle_info/2"},{"type":"function","title":"cure_lsp_server.handle_message/1","doc":"","ref":"cure_lsp_server.html#handle_message/1"},{"type":"function","title":"cure_lsp_server.init/1","doc":"","ref":"cure_lsp_server.html#init/1"},{"type":"function","title":"cure_lsp_server.start_link/0","doc":"","ref":"cure_lsp_server.html#start_link/0"},{"type":"function","title":"cure_lsp_server.start_link/1","doc":"","ref":"cure_lsp_server.html#start_link/1"},{"type":"function","title":"cure_lsp_server.stop/0","doc":"","ref":"cure_lsp_server.html#stop/0"},{"type":"function","title":"cure_lsp_server.terminate/2","doc":"","ref":"cure_lsp_server.html#terminate/2"},{"type":"function","title":"cure_lsp_server.update_document/2","doc":"","ref":"cure_lsp_server.html#update_document/2"},{"type":"module","title":"cure_parser","doc":"# Cure Programming Language - Parser\n\nThe parser module implements a recursive descent parser that converts tokens from\nthe lexer into an Abstract Syntax Tree (AST). It handles the complete Cure language\ngrammar including modules, functions, finite state machines, types, records,\nand expressions.","ref":"cure_parser.html"},{"type":"module","title":"Features - cure_parser","doc":"","ref":"cure_parser.html#module-features"},{"type":"module","title":"Language Constructs - cure_parser","doc":"- **Modules**: Module definitions with exports and imports\n- **Functions**: Function definitions with parameters, return types, and guards\n- **FSMs**: Finite state machine definitions with states and transitions\n- **Types**: User-defined types, records, and type aliases\n- **Expressions**: Complete expression parsing including pattern matching\n- **Literals**: Numbers, strings, atoms, lists, tuples, and maps","ref":"cure_parser.html#module-language-constructs"},{"type":"module","title":"Parser Architecture - cure_parser","doc":"- **Recursive Descent**: Top-down parsing with predictive lookahead\n- **Error Recovery**: Comprehensive error reporting with location information\n- **Token Stream**: Sequential token processing with position tracking\n- **AST Generation**: Direct AST construction during parsing","ref":"cure_parser.html#module-parser-architecture"},{"type":"module","title":"Error Handling - cure_parser","doc":"- **Syntax Errors**: Detailed error messages with expected vs. actual tokens\n- **Location Tracking**: Line and column information for all parse errors\n- **Error Recovery**: Attempts to continue parsing after errors where possible\n- **Structured Errors**: Well-formed error tuples for programmatic handling","ref":"cure_parser.html#module-error-handling"},{"type":"module","title":"Grammar Support - cure_parser","doc":"The parser supports the complete Cure language grammar:","ref":"cure_parser.html#module-grammar-support"},{"type":"module","title":"Top-Level Constructs - cure_parser","doc":"```cure\nmodule MyModule do\n  export [function/2, MyType]\n  \n  def function(param1: Type1, param2: Type2) -> ReturnType do\n    # Function body\n  end\n  \n  fsm StateMachine do\n    state idle do\n      on start -> running\n    end\n  end\nend\n```","ref":"cure_parser.html#module-top-level-constructs"},{"type":"module","title":"Expression Parsing - cure_parser","doc":"- **Arithmetic**: `+`, `-`, `*`, `/`, `div`, `rem`\n- **Logical**: `and`, `or`, `not`, `andalso`, `orelse`\n- **Comparison**: `==`, `/=`, `<`, `>`, `=<`, `>=`\n- **Pattern Matching**: Complete pattern support with guards\n- **Function Calls**: Local and remote function calls\n- **Data Structures**: Lists, tuples, maps, records","ref":"cure_parser.html#module-expression-parsing"},{"type":"module","title":"Type System Integration - cure_parser","doc":"- **Type Annotations**: Function parameters and return types\n- **Type Definitions**: User-defined types and aliases\n- **Generic Types**: Parameterized types with constraints\n- **Dependent Types**: Types that depend on values","ref":"cure_parser.html#module-type-system-integration"},{"type":"module","title":"API Usage - cure_parser","doc":"```erlang\n%% Parse tokens directly\n{ok, AST} = cure_parser:parse(Tokens).\n\n%% Parse from file\n{ok, AST} = cure_parser:parse_file(\"example.cure\").\n\n%% Handle parse errors\ncase cure_parser:parse_file(\"example.cure\") of\n    {ok, AST} -> \n        cure_utils:debug(\"Parsed successfully~n\");\n    {error, {parse_error, Reason, Line, Column}} ->\n        cure_utils:debug(\"Parse error at ~p:~p: ~p~n\", [Line, Column, Reason])\nend.\n```","ref":"cure_parser.html#module-api-usage"},{"type":"module","title":"Parser State - cure_parser","doc":"The parser maintains state including:\n- **Token Stream**: Current and remaining tokens\n- **Position**: Current parsing position for error reporting\n- **Filename**: Source file name for error messages\n- **Context**: Current parsing context for better error messages","ref":"cure_parser.html#module-parser-state"},{"type":"module","title":"Error Types - cure_parser","doc":"The parser can return these error types:\n- `{parse_error, Reason, Line, Column}` - Syntax error with location\n- `{expected, TokenType, got, ActualType}` - Expected token mismatch\n- `{unexpected_token, TokenType}` - Unexpected token in context\n- `{Error, Reason, Stack}` - Internal parser errors","ref":"cure_parser.html#module-error-types"},{"type":"module","title":"Performance Characteristics - cure_parser","doc":"- **Linear Time**: O(n) parsing time for well-formed input\n- **Memory Efficient**: Streaming token processing\n- **Early Termination**: Stops on first syntax error\n- **Lookahead**: Minimal lookahead for efficient parsing","ref":"cure_parser.html#module-performance-characteristics"},{"type":"module","title":"Integration - cure_parser","doc":"The parser integrates with:\n- **Lexer**: Consumes tokens from cure_lexer\n- **AST**: Produces AST records defined in cure_ast.hrl\n- **Type Checker**: Provides AST input for type checking\n- **Compiler**: Part of the complete compilation pipeline","ref":"cure_parser.html#module-integration"},{"type":"function","title":"cure_parser.parse/1","doc":"Parses a list of tokens into an Abstract Syntax Tree (AST).\n\nThis is the main parsing function that takes a list of tokens from the lexer\nand produces a complete AST representing the Cure program structure.","ref":"cure_parser.html#parse/1"},{"type":"function","title":"Arguments - cure_parser.parse/1","doc":"- `Tokens` - List of token records from cure_lexer","ref":"cure_parser.html#parse/1-arguments"},{"type":"function","title":"Returns - cure_parser.parse/1","doc":"- `{ok, Program}` - Successfully parsed AST program\n- `{error, {parse_error, Reason, Line, Column}}` - Syntax error with location\n- `{error, {Error, Reason, Stack}}` - Internal parser error","ref":"cure_parser.html#parse/1-returns"},{"type":"function","title":"Example - cure_parser.parse/1","doc":"```erlang\nTokens = cure_lexer:tokenize(\"def hello() -> :ok end\"),\n{ok, AST} = cure_parser:parse(Tokens).\n```","ref":"cure_parser.html#parse/1-example"},{"type":"function","title":"Error Handling - cure_parser.parse/1","doc":"The parser provides detailed error information including:\n- Specific error reason (expected token, unexpected construct, etc.)\n- Line and column numbers for error location\n- Full stack trace for internal errors","ref":"cure_parser.html#parse/1-error-handling"},{"type":"function","title":"cure_parser.parse_file/1","doc":"Parses a Cure source file into an Abstract Syntax Tree (AST).\n\nThis convenience function reads and tokenizes a file, then parses the tokens\ninto an AST. It handles both lexical and syntax errors from the complete\nlexing and parsing pipeline.","ref":"cure_parser.html#parse_file/1"},{"type":"function","title":"Arguments - cure_parser.parse_file/1","doc":"- `Filename` - Path to the Cure source file to parse","ref":"cure_parser.html#parse_file/1-arguments"},{"type":"function","title":"Returns - cure_parser.parse_file/1","doc":"- `{ok, Program}` - Successfully parsed AST program\n- `{error, {parse_error, Reason, Line, Column}}` - Syntax error with location\n- `{error, LexError}` - Lexical error from tokenization\n- `{error, {Error, Reason, Stack}}` - Internal parser error","ref":"cure_parser.html#parse_file/1-returns"},{"type":"function","title":"Example - cure_parser.parse_file/1","doc":"```erlang\ncase cure_parser:parse_file(\"examples/hello.cure\") of\n    {ok, AST} ->\n        cure_utils:debug(\"Successfully parsed file~n\");\n    {error, {parse_error, Reason, Line, Col}} ->\n        cure_utils:debug(\"Parse error at ~p:~p: ~p~n\", [Line, Col, Reason]);\n    {error, Reason} ->\n        cure_utils:debug(\"Error: ~p~n\", [Reason])\nend.\n```","ref":"cure_parser.html#parse_file/1-example"},{"type":"function","title":"Error Sources - cure_parser.parse_file/1","doc":"This function can return errors from:\n1. **File I/O**: File not found, permission errors\n2. **Lexical Analysis**: Invalid tokens, malformed strings\n3. **Syntax Analysis**: Grammar violations, unexpected tokens","ref":"cure_parser.html#parse_file/1-error-sources"},{"type":"module","title":"cure_profiler","doc":"# Cure Runtime Profiler\n\nCollects runtime execution statistics to guide compiler optimizations.\nProvides lightweight instrumentation and aggregation of:\n- Function call counts and frequencies\n- Hot path detection through call sequences\n- Type usage patterns at runtime\n- Memory allocation patterns\n- Performance metrics","ref":"cure_profiler.html"},{"type":"module","title":"Usage - cure_profiler","doc":"```erlang\n% Initialize profiling\ncure_profiler:start_profiling(),\n\n% Run your code\nmy_application:run(),\n\n% Collect profile data\nProfileData = cure_profiler:get_profile_data(),\n\n% Use for optimization\nOptimizedAST = cure_type_optimizer:optimize_with_profile(AST, ProfileData),\n\n% Stop profiling\ncure_profiler:stop_profiling().\n```","ref":"cure_profiler.html#module-usage"},{"type":"module","title":"Profile Data Format - cure_profiler","doc":"Profile data is stored as a map with the following structure:\n```erlang\n#{\n    function_calls => #{FunctionName => CallCount},\n    call_sequences => [{Caller, Callee, Count}],\n    type_usage => #{Type => UsageCount},\n    memory_allocations => #{Function => AllocationSize},\n    hot_functions => [FunctionName],\n    hot_paths => [[FunctionName]],\n    timestamp => Milliseconds\n}\n```","ref":"cure_profiler.html#module-profile-data-format"},{"type":"function","title":"cure_profiler.analyze_profile/0","doc":"","ref":"cure_profiler.html#analyze_profile/0"},{"type":"function","title":"cure_profiler.analyze_profile/1","doc":"","ref":"cure_profiler.html#analyze_profile/1"},{"type":"function","title":"cure_profiler.export_profile/1","doc":"","ref":"cure_profiler.html#export_profile/1"},{"type":"function","title":"cure_profiler.get_function_stats/0","doc":"","ref":"cure_profiler.html#get_function_stats/0"},{"type":"function","title":"cure_profiler.get_hot_functions/0","doc":"","ref":"cure_profiler.html#get_hot_functions/0"},{"type":"function","title":"cure_profiler.get_hot_functions/1","doc":"","ref":"cure_profiler.html#get_hot_functions/1"},{"type":"function","title":"cure_profiler.get_hot_paths/0","doc":"","ref":"cure_profiler.html#get_hot_paths/0"},{"type":"function","title":"cure_profiler.get_profile_data/0","doc":"","ref":"cure_profiler.html#get_profile_data/0"},{"type":"function","title":"cure_profiler.get_type_usage/0","doc":"","ref":"cure_profiler.html#get_type_usage/0"},{"type":"function","title":"cure_profiler.import_profile/1","doc":"","ref":"cure_profiler.html#import_profile/1"},{"type":"function","title":"cure_profiler.record_call_sequence/2","doc":"","ref":"cure_profiler.html#record_call_sequence/2"},{"type":"function","title":"cure_profiler.record_function_call/1","doc":"","ref":"cure_profiler.html#record_function_call/1"},{"type":"function","title":"cure_profiler.record_function_call/2","doc":"","ref":"cure_profiler.html#record_function_call/2"},{"type":"function","title":"cure_profiler.record_memory_allocation/2","doc":"","ref":"cure_profiler.html#record_memory_allocation/2"},{"type":"function","title":"cure_profiler.record_type_usage/2","doc":"","ref":"cure_profiler.html#record_type_usage/2"},{"type":"function","title":"cure_profiler.reset_profiling/0","doc":"","ref":"cure_profiler.html#reset_profiling/0"},{"type":"function","title":"cure_profiler.start_profiling/0","doc":"","ref":"cure_profiler.html#start_profiling/0"},{"type":"function","title":"cure_profiler.start_profiling/1","doc":"","ref":"cure_profiler.html#start_profiling/1"},{"type":"function","title":"cure_profiler.stop_profiling/0","doc":"","ref":"cure_profiler.html#stop_profiling/0"},{"type":"module","title":"cure_runtime","doc":"# Cure Programming Language - Runtime Execution Engine\n\nThe runtime execution engine interprets and executes BEAM instructions generated\nby the Cure compiler. It provides a complete execution environment for Cure\nprograms with stack-based instruction processing, function calls, module loading,\nand integration with the Erlang standard library.","ref":"cure_runtime.html"},{"type":"module","title":"Features - cure_runtime","doc":"","ref":"cure_runtime.html#module-features"},{"type":"module","title":"Instruction Execution - cure_runtime","doc":"- **Stack-based VM**: Uses an execution stack for operand management\n- **BEAM Instructions**: Processes compiler-generated BEAM instructions\n- **Control Flow**: Supports jumps, labels, conditionals, and function calls\n- **Pattern Matching**: Handles pattern matching operations\n- **Lambda Functions**: Creates and executes anonymous functions","ref":"cure_runtime.html#module-instruction-execution"},{"type":"module","title":"Function System - cure_runtime","doc":"- **Module Loading**: Loads compiled Cure modules into runtime state\n- **Function Resolution**: Resolves and calls both internal and external functions\n- **Parameter Binding**: Maps function parameters to argument values\n- **Standard Library**: Built-in integration with cure_std functions\n- **Global Functions**: Pre-loaded standard functions accessible from any context","ref":"cure_runtime.html#module-function-system"},{"type":"module","title":"Memory Management - cure_runtime","doc":"- **Runtime State**: Maintains execution state with stack, locals, and parameters\n- **Module Registry**: Tracks loaded modules and their functions\n- **Variable Scoping**: Separate scopes for parameters, local variables, and globals\n- **Stack Operations**: Efficient stack manipulation for all operations","ref":"cure_runtime.html#module-memory-management"},{"type":"module","title":"Error Handling - cure_runtime","doc":"- **Instruction Errors**: Detailed error reporting for instruction execution\n- **Function Errors**: Comprehensive function call error handling\n- **Stack Errors**: Stack underflow and overflow detection\n- **External Errors**: Error propagation from external function calls","ref":"cure_runtime.html#module-error-handling"},{"type":"module","title":"Runtime Architecture - cure_runtime","doc":"","ref":"cure_runtime.html#module-runtime-architecture"},{"type":"module","title":"Execution Model - cure_runtime","doc":"The runtime uses a stack-based execution model where:\n1. **Instructions** operate on an execution stack\n2. **Operands** are pushed/popped from the stack\n3. **Results** are left on the stack for subsequent operations\n4. **Functions** execute with isolated parameter and local variable scopes","ref":"cure_runtime.html#module-execution-model"},{"type":"module","title":"State Management - cure_runtime","doc":"```erlang\n#runtime_state{\n    stack = [],      % Execution stack for operands\n    locals = #{},    % Local variables in current scope\n    params = #{},    % Function parameters\n    modules = #{},   % Loaded modules\n    globals = #{}    % Global function registry\n}\n```","ref":"cure_runtime.html#module-state-management"},{"type":"module","title":"Instruction Set - cure_runtime","doc":"Supported BEAM instruction types:\n- **Load Operations**: load_literal, load_param, load_local, load_global\n- **Store Operations**: store_local\n- **Arithmetic**: binary_op, unary_op with standard operators\n- **Control Flow**: jump, jump_if_false, label, return\n- **Function Calls**: call, monadic_pipe_call\n- **Data Structures**: make_list, make_lambda\n- **Stack Management**: pop, pattern_match","ref":"cure_runtime.html#module-instruction-set"},{"type":"module","title":"Usage Examples - cure_runtime","doc":"","ref":"cure_runtime.html#module-usage-examples"},{"type":"module","title":"Basic Program Execution - cure_runtime","doc":"```erlang\n%% Execute a compiled module\n{ok, CompiledModule} = cure_codegen:compile_module(ModuleAST),\n{ok, Result} = cure_runtime:execute_module(CompiledModule).\n\n%% Run a complete program with multiple modules\n{ok, Modules} = cure_codegen:compile_program(ProgramAST),\n{ok, Result} = cure_runtime:run_program(Modules).\n```","ref":"cure_runtime.html#module-basic-program-execution"},{"type":"module","title":"Function Calls - cure_runtime","doc":"```erlang\nState = cure_runtime:create_runtime_state(),\n{ok, Result, NewState} = cure_runtime:call_function(add, [5, 3], State).\n```","ref":"cure_runtime.html#module-function-calls"},{"type":"module","title":"Module Loading - cure_runtime","doc":"```erlang\nState = cure_runtime:create_runtime_state(),\nStateWithModule = cure_runtime:load_module(CompiledModule, State).\n```","ref":"cure_runtime.html#module-module-loading"},{"type":"module","title":"Integration - cure_runtime","doc":"","ref":"cure_runtime.html#module-integration"},{"type":"module","title":"Cure Standard Library - cure_runtime","doc":"The runtime automatically loads and provides access to:\n- Result/Option monadic operations (ok, error, some, none)\n- List processing functions (map, filter, foldl, head, tail)\n- Mathematical functions (abs, sqrt, pi, safe_divide)\n- String operations (concat, split, trim, case conversion)\n- I/O functions (print, println)\n- FSM operations (fsm_create, fsm_send_safe)","ref":"cure_runtime.html#module-cure-standard-library"},{"type":"module","title":"External Function Calls - cure_runtime","doc":"Supports calling external Erlang functions with automatic error handling\nand result propagation back to the Cure execution environment.","ref":"cure_runtime.html#module-external-function-calls"},{"type":"module","title":"Monadic Pipe Operations - cure_runtime","doc":"Native support for Cure's monadic pipe operator (|>) with automatic\nok/error unwrapping and error propagation through cure_std:pipe/2.","ref":"cure_runtime.html#module-monadic-pipe-operations"},{"type":"module","title":"Error Handling - cure_runtime","doc":"","ref":"cure_runtime.html#module-error-handling"},{"type":"module","title":"Error Types - cure_runtime","doc":"- `{function_not_found, FuncName}` - Function resolution failures\n- `{external_function_error, Error, Reason}` - External function call errors\n- `{function_execution_error, FuncName, Reason}` - Internal function errors\n- `{parameter_not_found, ParamName}` - Parameter binding errors\n- `{local_variable_not_found, VarName}` - Local variable access errors\n- `stack_underflow` - Insufficient stack items for operation\n- `{unsupported_instruction, Instruction}` - Unknown instruction types\n- `{label_not_found, Label}` - Jump target resolution failures","ref":"cure_runtime.html#module-error-types"},{"type":"module","title":"Error Propagation - cure_runtime","doc":"Errors are propagated through the call stack with detailed context\ninformation including function names, instruction details, and stack state.","ref":"cure_runtime.html#module-error-propagation"},{"type":"module","title":"Performance Characteristics - cure_runtime","doc":"- **Instruction Execution**: O(1) for most instructions\n- **Function Resolution**: O(1) hash map lookup\n- **Stack Operations**: O(1) for push/pop, O(n) for multi-item operations\n- **Module Loading**: O(n) where n is the number of functions\n- **Memory Usage**: Linear in program size and call stack depth","ref":"cure_runtime.html#module-performance-characteristics"},{"type":"module","title":"Thread Safety - cure_runtime","doc":"The runtime state is designed for single-threaded execution within a process.\nConcurrent execution requires separate runtime state instances per thread.\nExternal function calls may interact with concurrent Erlang processes safely.","ref":"cure_runtime.html#module-thread-safety"},{"type":"function","title":"cure_runtime.call_function/3","doc":"Calls a function by name with the provided arguments.\n\nThis is the primary interface for invoking functions within the runtime.\nIt handles both internal Cure functions and external Erlang functions,\nwith automatic error handling and state management.","ref":"cure_runtime.html#call_function/3"},{"type":"function","title":"Arguments - cure_runtime.call_function/3","doc":"- `FuncName` - Function name (atom)\n- `Args` - List of arguments to pass to the function\n- `State` - Current runtime state","ref":"cure_runtime.html#call_function/3-arguments"},{"type":"function","title":"Returns - cure_runtime.call_function/3","doc":"- `{ok, Result, NewState}` - Function executed successfully\n- `{error, {function_not_found, FuncName}}` - Function not in registry\n- `{error, {external_function_error, Error, Reason}}` - External function failed\n- `{error, {function_execution_error, FuncName, Reason}}` - Internal function failed","ref":"cure_runtime.html#call_function/3-returns"},{"type":"function","title":"Example - cure_runtime.call_function/3","doc":"```erlang\nState = cure_runtime:create_runtime_state(),\n\n%% Call standard library function\n{ok, Result, State1} = cure_runtime:call_function(abs, [-5], State),\n%% Result = 5\n\n%% Call user-defined function (after loading module)\nStateWithModule = cure_runtime:load_module(CompiledModule, State1),\n{ok, UserResult, State2} = cure_runtime:call_function(my_func, [1, 2], StateWithModule).\n```","ref":"cure_runtime.html#call_function/3-example"},{"type":"function","title":"Function Types - cure_runtime.call_function/3","doc":"","ref":"cure_runtime.html#call_function/3-function-types"},{"type":"function","title":"External Functions - cure_runtime.call_function/3","doc":"- Implemented in Erlang modules (typically cure_std)\n- Called using `apply/3` with automatic error catching\n- Standard library functions like print, map, abs, etc.\n- Maintain no internal state between calls","ref":"cure_runtime.html#call_function/3-external-functions"},{"type":"function","title":"Internal Functions - cure_runtime.call_function/3","doc":"- Implemented in Cure with compiled BEAM instructions\n- Execute within isolated parameter/local variable scope\n- Can call other internal or external functions\n- Maintain stack-based execution model","ref":"cure_runtime.html#call_function/3-internal-functions"},{"type":"function","title":"Error Handling - cure_runtime.call_function/3","doc":"- Function resolution failures are reported with function name\n- External function errors include original Erlang error details\n- Internal function errors include execution context and stack trace\n- State is preserved across failed function calls","ref":"cure_runtime.html#call_function/3-error-handling"},{"type":"function","title":"State Management - cure_runtime.call_function/3","doc":"- Global state (modules, globals) is preserved across calls\n- Function parameters and locals are isolated per call\n- Stack is managed automatically during execution\n- External functions cannot modify runtime state","ref":"cure_runtime.html#call_function/3-state-management"},{"type":"function","title":"cure_runtime.create_runtime_state/0","doc":"Creates a fresh runtime state with pre-loaded standard library functions.\n\nThis function initializes the runtime environment with all necessary\ncomponents for executing Cure programs, including the complete standard\nlibrary function registry.","ref":"cure_runtime.html#create_runtime_state/0"},{"type":"function","title":"Returns - cure_runtime.create_runtime_state/0","doc":"- `#runtime_state{}` - Fresh runtime state ready for execution","ref":"cure_runtime.html#create_runtime_state/0-returns"},{"type":"function","title":"Example - cure_runtime.create_runtime_state/0","doc":"```erlang\nState = cure_runtime:create_runtime_state(),\n{ok, Result, NewState} = cure_runtime:call_function(print, [\"Hello\"], State).\n```","ref":"cure_runtime.html#create_runtime_state/0-example"},{"type":"function","title":"Pre-loaded Functions - cure_runtime.create_runtime_state/0","doc":"The runtime state includes immediate access to:","ref":"cure_runtime.html#create_runtime_state/0-pre-loaded-functions"},{"type":"function","title":"Monadic Operations - cure_runtime.create_runtime_state/0","doc":"- `ok/1`, `error/1` - Result type constructors\n- `some/1`, `none/0` - Option type constructors\n- `map_ok/2`, `pipe/2` - Monadic operations","ref":"cure_runtime.html#create_runtime_state/0-monadic-operations"},{"type":"function","title":"List Processing - cure_runtime.create_runtime_state/0","doc":"- `map/2`, `filter/2`, `foldl/3` - Higher-order list functions\n- `head/1`, `tail/1`, `length/1` - Basic list operations\n- `find/2` - List searching","ref":"cure_runtime.html#create_runtime_state/0-list-processing"},{"type":"function","title":"Mathematical Functions - cure_runtime.create_runtime_state/0","doc":"- `abs/1`, `sqrt/1`, `pi/0` - Basic math\n- `safe_divide/2`, `safe_sqrt/2` - Safe math operations\n- `gcd/2`, `factorial/1` - Extended math functions","ref":"cure_runtime.html#create_runtime_state/0-mathematical-functions"},{"type":"function","title":"String Operations - cure_runtime.create_runtime_state/0","doc":"- `string_concat/2`, `split/2`, `trim/1` - String manipulation\n- `to_upper/1`, `to_lower/1` - Case conversion\n- `contains/2`, `starts_with/2`, `ends_with/2` - String testing\n- `string_join/2`, `string_empty/1` - String utilities","ref":"cure_runtime.html#create_runtime_state/0-string-operations"},{"type":"function","title":"I/O Functions - cure_runtime.create_runtime_state/0","doc":"- `print/1`, `println/1` - Console output\n- `int_to_string/1`, `float_to_string/1` - Type conversion","ref":"cure_runtime.html#create_runtime_state/0-i-o-functions"},{"type":"function","title":"FSM Operations - cure_runtime.create_runtime_state/0","doc":"- `fsm_create/2`, `fsm_send_safe/2` - FSM management\n- `create_counter/1` - Counter FSM creation","ref":"cure_runtime.html#create_runtime_state/0-fsm-operations"},{"type":"function","title":"Function Resolution - cure_runtime.create_runtime_state/0","doc":"All pre-loaded functions use external references to cure_std module\nfunctions, ensuring consistent behavior and implementation.","ref":"cure_runtime.html#create_runtime_state/0-function-resolution"},{"type":"function","title":"cure_runtime.execute_function/3","doc":"","ref":"cure_runtime.html#execute_function/3"},{"type":"function","title":"cure_runtime.execute_module/1","doc":"Executes a compiled Cure module by running its main/0 function.\n\nThis is the primary entry point for executing standalone Cure modules.\nIt creates a fresh runtime state, loads the module, and executes the\nmain function if present.","ref":"cure_runtime.html#execute_module/1"},{"type":"function","title":"Arguments - cure_runtime.execute_module/1","doc":"- `CompiledModule` - Module compiled by cure_codegen:compile_module/1,2","ref":"cure_runtime.html#execute_module/1-arguments"},{"type":"function","title":"Returns - cure_runtime.execute_module/1","doc":"- `{ok, Result}` - Successfully executed with main function result\n- `{error, main_function_not_found}` - Module has no main/0 function\n- `{error, Reason}` - Execution error during main function","ref":"cure_runtime.html#execute_module/1-returns"},{"type":"function","title":"Example - cure_runtime.execute_module/1","doc":"```erlang\n%% Compile and execute a module with main/0\nModuleAST = parse_module(\"def main() = 42\"),\n{ok, CompiledModule} = cure_codegen:compile_module(ModuleAST),\n{ok, 42} = cure_runtime:execute_module(CompiledModule).\n```","ref":"cure_runtime.html#execute_module/1-example"},{"type":"function","title":"Main Function Requirements - cure_runtime.execute_module/1","doc":"- Must be named `main`\n- Must have arity 0 (no parameters)\n- Should return the program's exit value or result\n- Will be executed in a fresh runtime environment","ref":"cure_runtime.html#execute_module/1-main-function-requirements"},{"type":"function","title":"Runtime Environment - cure_runtime.execute_module/1","doc":"The execution environment includes:\n- Clean runtime state with empty stack\n- Pre-loaded standard library functions\n- Module functions available for internal calls\n- Proper error handling and propagation","ref":"cure_runtime.html#execute_module/1-runtime-environment"},{"type":"function","title":"cure_runtime.load_module/2","doc":"Loads a compiled module into the runtime state, making its functions available.\n\nThis function integrates a compiled module into the runtime environment,\nregistering all its functions in the global function registry and storing\nthe module for future reference.","ref":"cure_runtime.html#load_module/2"},{"type":"function","title":"Arguments - cure_runtime.load_module/2","doc":"- `CompiledModule` - Module compiled by cure_codegen:compile_module/1,2\n- `State` - Current runtime state","ref":"cure_runtime.html#load_module/2-arguments"},{"type":"function","title":"Returns - cure_runtime.load_module/2","doc":"- `#runtime_state{}` - Updated runtime state with loaded module","ref":"cure_runtime.html#load_module/2-returns"},{"type":"function","title":"Example - cure_runtime.load_module/2","doc":"```erlang\nState = cure_runtime:create_runtime_state(),\n{ok, Module} = cure_codegen:compile_module(ModuleAST),\nStateWithModule = cure_runtime:load_module(Module, State),\n\n%% Now module functions are available\n{ok, Result, _} = cure_runtime:call_function(my_function, [args], StateWithModule).\n```","ref":"cure_runtime.html#load_module/2-example"},{"type":"function","title":"Module Integration - cure_runtime.load_module/2","doc":"Loading a module performs the following operations:\n1. **Function Registration**: All module functions are added to globals\n2. **Name Resolution**: Functions become callable by name from any context\n3. **Module Storage**: Module definition is stored for introspection\n4. **Namespace Merging**: Functions are merged with existing global functions","ref":"cure_runtime.html#load_module/2-module-integration"},{"type":"function","title":"Function Availability - cure_runtime.load_module/2","doc":"- All functions in the module become globally callable\n- Functions shadow previously loaded functions with same name\n- Both exported and non-exported functions are available (no visibility restrictions)\n- Functions can call other functions from the same or different loaded modules","ref":"cure_runtime.html#load_module/2-function-availability"},{"type":"function","title":"Module Format - cure_runtime.load_module/2","doc":"Expected compiled module format:\n```erlang\n#{\n    name => ModuleName,\n    functions => [CompiledFunction, ...],\n    exports => [{FuncName, Arity}, ...],\n    attributes => [...]\n}\n```","ref":"cure_runtime.html#load_module/2-module-format"},{"type":"function","title":"Error Handling - cure_runtime.load_module/2","doc":"Module loading is designed to always succeed. Malformed modules may\nresult in functions that cannot be executed, but loading itself will\nnot fail.","ref":"cure_runtime.html#load_module/2-error-handling"},{"type":"function","title":"cure_runtime.record_field/2","doc":"Accesses a field from a record/tuple at runtime.\n\nThis function provides runtime support for field access when the record type\nisn't known statically during compilation. It handles both Erlang-style records\n(which are tuples with the record name as the first element) and plain tuples.","ref":"cure_runtime.html#record_field/2"},{"type":"function","title":"Arguments - cure_runtime.record_field/2","doc":"- `Record` - The record or tuple to access\n- `FieldName` - The atom name of the field to access","ref":"cure_runtime.html#record_field/2-arguments"},{"type":"function","title":"Returns - cure_runtime.record_field/2","doc":"- The value of the specified field\n- Raises an error if the field doesn't exist or Record is invalid","ref":"cure_runtime.html#record_field/2-returns"},{"type":"function","title":"Example - cure_runtime.record_field/2","doc":"```erlang\n%% For a record like {turnstile_payload, 'Lock', coin}\nPayload = {'TurnstilePayload', 'Lock', coin},\nEvent = cure_runtime:record_field(Payload, event),  % Returns coin\n```","ref":"cure_runtime.html#record_field/2-example"},{"type":"function","title":"Implementation Notes - cure_runtime.record_field/2","doc":"- For Erlang records (tuples with atom tag as first element), we determine\n  field positions from the record structure\n- This is a temporary solution until proper type information is available\n  during code generation\n- Performance: O(1) tuple element access","ref":"cure_runtime.html#record_field/2-implementation-notes"},{"type":"function","title":"cure_runtime.run_program/1","doc":"Runs a complete Cure program consisting of multiple modules.\n\nThis function loads all provided modules into the runtime and executes\nthe first main/0 function found across all modules. This is used for\nmulti-module Cure programs.","ref":"cure_runtime.html#run_program/1"},{"type":"function","title":"Arguments - cure_runtime.run_program/1","doc":"- `Modules` - List of compiled modules from cure_codegen:compile_program/1,2","ref":"cure_runtime.html#run_program/1-arguments"},{"type":"function","title":"Returns - cure_runtime.run_program/1","doc":"- `{ok, Result}` - Successfully executed with main function result\n- `{error, no_modules}` - Empty module list provided\n- `{error, main_function_not_found}` - No main/0 function in any module\n- `{error, Reason}` - Execution error during program execution","ref":"cure_runtime.html#run_program/1-returns"},{"type":"function","title":"Example - cure_runtime.run_program/1","doc":"```erlang\n%% Compile and run a multi-module program\nProgramAST = [Module1AST, Module2AST, MainModuleAST],\n{ok, Modules} = cure_codegen:compile_program(ProgramAST),\n{ok, Result} = cure_runtime:run_program(Modules).\n```","ref":"cure_runtime.html#run_program/1-example"},{"type":"function","title":"Module Loading Order - cure_runtime.run_program/1","doc":"1. All modules are loaded into the runtime state first\n2. Functions from all modules become available globally\n3. The first main/0 function found is executed\n4. Modules are searched in the order provided","ref":"cure_runtime.html#run_program/1-module-loading-order"},{"type":"function","title":"Inter-module Dependencies - cure_runtime.run_program/1","doc":"- Functions from all loaded modules are available to each other\n- No explicit import/export checking at runtime\n- Name conflicts resolved by load order (later modules shadow earlier ones)","ref":"cure_runtime.html#run_program/1-inter-module-dependencies"},{"type":"module","title":"cure_show_native","doc":"Native Erlang implementations of Show trait functions for Cure.\n\nProvides efficient primitive-to-string conversions for the Show trait system.","ref":"cure_show_native.html"},{"type":"function","title":"cure_show_native.atom_to_string/1","doc":"Convert an atom to its string representation.","ref":"cure_show_native.html#atom_to_string/1"},{"type":"function","title":"cure_show_native.bool_to_string/1","doc":"Convert a boolean to its string representation.","ref":"cure_show_native.html#bool_to_string/1"},{"type":"function","title":"cure_show_native.escape_string/1","doc":"Escape special characters in a string and wrap in quotes.","ref":"cure_show_native.html#escape_string/1"},{"type":"function","title":"cure_show_native.float_to_string/1","doc":"Convert a float to its string representation.","ref":"cure_show_native.html#float_to_string/1"},{"type":"function","title":"cure_show_native.int_to_string/1","doc":"Convert an integer to its string representation.","ref":"cure_show_native.html#int_to_string/1"},{"type":"function","title":"cure_show_native.is_atom_value/1","doc":"Check if value is an atom (for Cure pattern guards).","ref":"cure_show_native.html#is_atom_value/1"},{"type":"function","title":"cure_show_native.is_bool_value/1","doc":"Check if value is a boolean (for Cure pattern guards).","ref":"cure_show_native.html#is_bool_value/1"},{"type":"function","title":"cure_show_native.is_float_value/1","doc":"Check if value is a float (for Cure pattern guards).","ref":"cure_show_native.html#is_float_value/1"},{"type":"function","title":"cure_show_native.is_integer_value/1","doc":"Check if value is an integer (for Cure pattern guards).","ref":"cure_show_native.html#is_integer_value/1"},{"type":"function","title":"cure_show_native.is_list_value/1","doc":"Check if value is a list (for Cure pattern guards).","ref":"cure_show_native.html#is_list_value/1"},{"type":"function","title":"cure_show_native.is_string_value/1","doc":"Check if value is a string/binary (for Cure pattern guards).","ref":"cure_show_native.html#is_string_value/1"},{"type":"function","title":"cure_show_native.is_tuple_value/1","doc":"Check if value is a tuple (for Cure pattern guards).","ref":"cure_show_native.html#is_tuple_value/1"},{"type":"function","title":"cure_show_native.show_list/1","doc":"Convert a list to its string representation.","ref":"cure_show_native.html#show_list/1"},{"type":"function","title":"cure_show_native.show_list_elements/1","doc":"Convert list elements to comma-separated string representations.","ref":"cure_show_native.html#show_list_elements/1"},{"type":"function","title":"cure_show_native.show_tuple/1","doc":"Convert a tuple to its string representation.\nOnly handles tuples up to size 5 for now.","ref":"cure_show_native.html#show_tuple/1"},{"type":"module","title":"cure_smt_parser","doc":"# Cure SMT Model Parser\n\nParses S-expression output from SMT solvers (Z3, CVC5) to extract\nvariable bindings and convert them to Erlang terms.","ref":"cure_smt_parser.html"},{"type":"module","title":"Features - cure_smt_parser","doc":"- Parse (model ...) sections\n- Extract (define-fun ...) statements\n- Convert SMT values to Erlang terms\n- Handle Int, Bool, Real types\n- Error handling for malformed output","ref":"cure_smt_parser.html#module-features"},{"type":"module","title":"Usage - cure_smt_parser","doc":"```erlang\n% Parse model from Z3 output\nLines = [\n    <<\\\"(\\\">>,\n    <<\\\"  (define-fun x () Int 5)\\\">>,\n    <<\\\"  (define-fun y () Int 3)\\\">>,\n    <<\\\")\\\">>\n],\n{ok, Model} = cure_smt_parser:parse_model(Lines).\n% => {ok, #{x => 5, y => 3}}\n```","ref":"cure_smt_parser.html#module-usage"},{"type":"function","title":"cure_smt_parser.extract_bindings/1","doc":"Extract variable bindings from model text.\n\nFinds all (define-fun ...) statements and extracts variable bindings.","ref":"cure_smt_parser.html#extract_bindings/1"},{"type":"function","title":"Arguments - cure_smt_parser.extract_bindings/1","doc":"- `ModelText` - Binary containing model S-expressions","ref":"cure_smt_parser.html#extract_bindings/1-arguments"},{"type":"function","title":"Returns - cure_smt_parser.extract_bindings/1","doc":"- List of {Name, Value} tuples","ref":"cure_smt_parser.html#extract_bindings/1-returns"},{"type":"function","title":"cure_smt_parser.parse_define_fun/1","doc":"Parse a (define-fun ...) statement.\n\nExtracts variable name, type, and value from a define-fun statement.","ref":"cure_smt_parser.html#parse_define_fun/1"},{"type":"function","title":"Arguments - cure_smt_parser.parse_define_fun/1","doc":"- `Line` - Binary line containing define-fun","ref":"cure_smt_parser.html#parse_define_fun/1-arguments"},{"type":"function","title":"Returns - cure_smt_parser.parse_define_fun/1","doc":"- `{ok, {Name, Value}}` - Parsed binding\n- `{error, Reason}` - Parse error","ref":"cure_smt_parser.html#parse_define_fun/1-returns"},{"type":"function","title":"cure_smt_parser.parse_model/1","doc":"Parse a model from solver output lines.\n\nTakes a list of binary lines from the solver and extracts variable bindings.","ref":"cure_smt_parser.html#parse_model/1"},{"type":"function","title":"Arguments - cure_smt_parser.parse_model/1","doc":"- `Lines` - List of binary lines from solver output","ref":"cure_smt_parser.html#parse_model/1-arguments"},{"type":"function","title":"Returns - cure_smt_parser.parse_model/1","doc":"- `{ok, Model}` - Map of variable names to values\n- `{error, Reason}` - Parse error","ref":"cure_smt_parser.html#parse_model/1-returns"},{"type":"function","title":"Example - cure_smt_parser.parse_model/1","doc":"```erlang\nLines = [<<\\\"(\\\">>, <<\\\"  (define-fun x () Int 5)\\\">>, <<\\\")\\\">>],\n{ok, #{x => 5}} = parse_model(Lines).\n```","ref":"cure_smt_parser.html#parse_model/1-example"},{"type":"function","title":"cure_smt_parser.parse_value/1","doc":"Parse a value without type information.\n\nAttempts to infer type and parse accordingly.","ref":"cure_smt_parser.html#parse_value/1"},{"type":"function","title":"Arguments - cure_smt_parser.parse_value/1","doc":"- `ValueBin` - Binary containing the value","ref":"cure_smt_parser.html#parse_value/1-arguments"},{"type":"function","title":"Returns - cure_smt_parser.parse_value/1","doc":"- Erlang term (guessed type)","ref":"cure_smt_parser.html#parse_value/1-returns"},{"type":"function","title":"cure_smt_parser.parse_value/2","doc":"Parse a value based on its SMT type.\n\nConverts SMT-LIB value representation to Erlang term.","ref":"cure_smt_parser.html#parse_value/2"},{"type":"function","title":"Arguments - cure_smt_parser.parse_value/2","doc":"- `Type` - SMT type atom ('Int', 'Bool', 'Real')\n- `ValueBin` - Binary containing the value","ref":"cure_smt_parser.html#parse_value/2-arguments"},{"type":"function","title":"Returns - cure_smt_parser.parse_value/2","doc":"- Erlang term (integer, boolean, float)","ref":"cure_smt_parser.html#parse_value/2-returns"},{"type":"module","title":"cure_smt_process","doc":"# Cure SMT Solver Process Manager\n\nManages external SMT solver processes (Z3, CVC5) using Erlang ports.\nProvides process pooling, timeout enforcement, and resource management.","ref":"cure_smt_process.html"},{"type":"module","title":"Features - cure_smt_process","doc":"- Port-based communication with solvers\n- Process pool for performance\n- Timeout enforcement\n- Automatic crash recovery\n- Resource limits\n- Query execution with model extraction","ref":"cure_smt_process.html#module-features"},{"type":"module","title":"Usage - cure_smt_process","doc":"```erlang\n% Start a solver\n{ok, Pid} = cure_smt_process:start_solver(z3, 5000).\n\n% Execute a query\nQuery = \\\"(set-logic QF_LIA)\\\\n(check-sat)\\\\n\\\",\n{sat, Lines} = cure_smt_process:execute_query(Pid, Query).\n\n% Stop solver\ncure_smt_process:stop_solver(Pid).\n```","ref":"cure_smt_process.html#module-usage"},{"type":"function","title":"cure_smt_process.code_change/3","doc":"","ref":"cure_smt_process.html#code_change/3"},{"type":"function","title":"cure_smt_process.execute_query/2","doc":"Execute an SMT-LIB query on a solver process.","ref":"cure_smt_process.html#execute_query/2"},{"type":"function","title":"Arguments - cure_smt_process.execute_query/2","doc":"- `Pid` - Solver process PID\n- `Query` - SMT-LIB query string or iolist","ref":"cure_smt_process.html#execute_query/2-arguments"},{"type":"function","title":"Returns - cure_smt_process.execute_query/2","doc":"- `{sat, Lines}` - Satisfiable with model lines\n- `{unsat, []}` - Unsatisfiable\n- `{unknown, []}` - Solver couldn't determine\n- `{error, Reason}` - Execution error","ref":"cure_smt_process.html#execute_query/2-returns"},{"type":"function","title":"cure_smt_process.execute_query/3","doc":"","ref":"cure_smt_process.html#execute_query/3"},{"type":"function","title":"cure_smt_process.get_pooled_solver/2","doc":"Get a solver from the pool.","ref":"cure_smt_process.html#get_pooled_solver/2"},{"type":"function","title":"cure_smt_process.get_stats/1","doc":"Get solver statistics.","ref":"cure_smt_process.html#get_stats/1"},{"type":"function","title":"cure_smt_process.handle_call/3","doc":"","ref":"cure_smt_process.html#handle_call/3"},{"type":"function","title":"cure_smt_process.handle_cast/2","doc":"","ref":"cure_smt_process.html#handle_cast/2"},{"type":"function","title":"cure_smt_process.handle_info/2","doc":"","ref":"cure_smt_process.html#handle_info/2"},{"type":"function","title":"cure_smt_process.init/1","doc":"","ref":"cure_smt_process.html#init/1"},{"type":"function","title":"cure_smt_process.reset_solver/1","doc":"Reset a solver process (clear all assertions).","ref":"cure_smt_process.html#reset_solver/1"},{"type":"function","title":"cure_smt_process.return_solver/2","doc":"Return a solver to the pool.","ref":"cure_smt_process.html#return_solver/2"},{"type":"function","title":"cure_smt_process.start_pool/1","doc":"Start a solver process pool.","ref":"cure_smt_process.html#start_pool/1"},{"type":"function","title":"cure_smt_process.start_solver/2","doc":"Start a solver process.","ref":"cure_smt_process.html#start_solver/2"},{"type":"function","title":"Arguments - cure_smt_process.start_solver/2","doc":"- `Solver` - Solver type (z3 or cvc5)\n- `Timeout` - Query timeout in milliseconds","ref":"cure_smt_process.html#start_solver/2-arguments"},{"type":"function","title":"Returns - cure_smt_process.start_solver/2","doc":"- `{ok, Pid}` - Solver process PID\n- `{error, Reason}` - Error starting solver","ref":"cure_smt_process.html#start_solver/2-returns"},{"type":"function","title":"cure_smt_process.start_solver/3","doc":"","ref":"cure_smt_process.html#start_solver/3"},{"type":"function","title":"cure_smt_process.stop_pool/1","doc":"Stop the solver pool.","ref":"cure_smt_process.html#stop_pool/1"},{"type":"function","title":"cure_smt_process.stop_solver/1","doc":"Stop a solver process.","ref":"cure_smt_process.html#stop_solver/1"},{"type":"function","title":"cure_smt_process.terminate/2","doc":"","ref":"cure_smt_process.html#terminate/2"},{"type":"module","title":"cure_smt_solver","doc":"# Cure Programming Language - SMT Solver and Proof Assistant\n\nThe SMT (Satisfiability Modulo Theories) solver provides constraint solving\ncapabilities for Cure's dependent type system. It handles arithmetic constraints,\nlogical reasoning, and proof generation for dependent type verification.","ref":"cure_smt_solver.html"},{"type":"module","title":"Features - cure_smt_solver","doc":"","ref":"cure_smt_solver.html#module-features"},{"type":"module","title":"Constraint Solving - cure_smt_solver","doc":"- **Arithmetic Constraints**: Linear and non-linear arithmetic over integers/reals\n- **Equality Reasoning**: Equality and disequality constraints\n- **Boolean Logic**: Propositional logic with AND, OR, NOT, IMPLIES\n- **Quantified Formulas**: Existential and universal quantification","ref":"cure_smt_solver.html#module-constraint-solving"},{"type":"module","title":"Pattern Matching Support - cure_smt_solver","doc":"- **Length Inference**: Infers list length constraints from pattern matching\n- **Structural Constraints**: Handles tuple/record structure constraints\n- **Exhaustiveness Checking**: Verifies pattern match completeness\n- **Reachability Analysis**: Determines unreachable pattern branches","ref":"cure_smt_solver.html#module-pattern-matching-support"},{"type":"module","title":"Proof Generation - cure_smt_solver","doc":"- **Constructive Proofs**: Generates proof terms for valid constraints\n- **Counter-examples**: Provides counter-examples for invalid constraints\n- **Proof Verification**: Checks independently generated proofs\n- **Automated Reasoning**: Combines multiple proof strategies","ref":"cure_smt_solver.html#module-proof-generation"},{"type":"module","title":"Dependent Type Integration - cure_smt_solver","doc":"- **Type-level Arithmetic**: Solves constraints involving type-level values\n- **Refinement Types**: Verifies refinement type predicates\n- **Constraint Propagation**: Propagates constraints through type inference\n- **Vector Types**: Handles length-indexed vectors and arrays","ref":"cure_smt_solver.html#module-dependent-type-integration"},{"type":"module","title":"Core Operations - cure_smt_solver","doc":"","ref":"cure_smt_solver.html#module-core-operations"},{"type":"module","title":"Constraint Solving - cure_smt_solver","doc":"```erlang\n%% Create arithmetic constraints\nConstraint1 = cure_smt_solver:arithmetic_constraint(X, '+', Y),\nConstraint2 = cure_smt_solver:equality_constraint(Result, Z),\n\n%% Solve constraints\ncase cure_smt_solver:solve_constraints([Constraint1, Constraint2]) of\n    {sat, Solution} -> \n        cure_utils:debug(\"Solution: ~p~n\", [Solution]);\n    unsat -> \n        cure_utils:debug(\"No solution exists~n\");\n    unknown -> \n        cure_utils:debug(\"Cannot determine satisfiability~n\")\nend.\n```","ref":"cure_smt_solver.html#module-constraint-solving"},{"type":"module","title":"Pattern Length Inference - cure_smt_solver","doc":"```erlang\n%% Infer length constraints from list patterns\nPattern = {list_pattern, [a, b], {identifier_pattern, tail}, Location},\nLengthVar = cure_smt_solver:variable_term(list_length),\nConstraints = cure_smt_solver:infer_pattern_length(Pattern, LengthVar).\n%% Generates: list_length = 2 + tail_length\n```","ref":"cure_smt_solver.html#module-pattern-length-inference"},{"type":"module","title":"Proof Generation - cure_smt_solver","doc":"```erlang\n%% Prove that a constraint follows from assumptions\nAssumptions = [X_greater_than_zero, Y_positive],\nGoal = cure_smt_solver:arithmetic_constraint(X, '+', Y, '>', zero),\n\ncase cure_smt_solver:prove_constraint(Assumptions, Goal) of\n    {proved, Proof} -> \n        cure_utils:debug(\"Proof: ~p~n\", [Proof]);\n    {disproved, CounterExample} -> \n        cure_utils:debug(\"Counter-example: ~p~n\", [CounterExample]);\n    unknown -> \n        cure_utils:debug(\"Cannot prove or disprove~n\")\nend.\n```","ref":"cure_smt_solver.html#module-proof-generation"},{"type":"module","title":"Constraint Types - cure_smt_solver","doc":"","ref":"cure_smt_solver.html#module-constraint-types"},{"type":"module","title":"Arithmetic Constraints - cure_smt_solver","doc":"- **Linear**: `ax + by = c`, `ax + by ≤ c`\n- **Non-linear**: `xy = z`, `x² + y² ≤ r²`\n- **Modular**: `x ≡ y (mod m)`\n- **Divisibility**: `x divides y`","ref":"cure_smt_solver.html#module-arithmetic-constraints"},{"type":"module","title":"Logical Constraints - cure_smt_solver","doc":"- **Propositional**: `P ∧ Q`, `P ∨ Q`, `¬P`\n- **Implications**: `P → Q`, `P ↔ Q`\n- **Quantified**: `∀x. P(x)`, `∃x. P(x)`","ref":"cure_smt_solver.html#module-logical-constraints"},{"type":"module","title":"Type-level Constraints - cure_smt_solver","doc":"- **Length Constraints**: `length(xs) = n`\n- **Range Constraints**: `0 ≤ index < length`\n- **Dimension Constraints**: `Matrix(m, n) @ Matrix(n, p) = Matrix(m, p)`","ref":"cure_smt_solver.html#module-type-level-constraints"},{"type":"module","title":"SMT Solver Interface - cure_smt_solver","doc":"","ref":"cure_smt_solver.html#module-smt-solver-interface"},{"type":"module","title":"Constraint Representation - cure_smt_solver","doc":"```erlang\n-record(smt_constraint, {\n    type :: equality | inequality | arithmetic | logical,\n    left :: smt_term(),\n    op :: '=' | '<' | '>' | '<=' | '>=' | '/=' | '+' | '-' | '*',\n    right :: smt_term(),\n    location :: location()\n}).\n```","ref":"cure_smt_solver.html#module-constraint-representation"},{"type":"module","title":"Term Representation - cure_smt_solver","doc":"```erlang\n-record(smt_term, {\n    type :: variable | constant | expression,\n    value :: atom() | integer() | float() | smt_expression(),\n    location :: location()\n}).\n```","ref":"cure_smt_solver.html#module-term-representation"},{"type":"module","title":"Solving Strategies - cure_smt_solver","doc":"","ref":"cure_smt_solver.html#module-solving-strategies"},{"type":"module","title":"Decision Procedures - cure_smt_solver","doc":"1. **Linear Arithmetic**: Simplex algorithm for linear constraints\n2. **Congruence Closure**: Equality reasoning with uninterpreted functions\n3. **Bit-vectors**: Precise reasoning about fixed-width integers\n4. **Arrays**: Theory of arrays with select/store operations","ref":"cure_smt_solver.html#module-decision-procedures"},{"type":"module","title":"Proof Search - cure_smt_solver","doc":"1. **Resolution**: Propositional resolution with conflict analysis\n2. **DPLL(T)**: Integration of propositional and theory reasoning\n3. **Instantiation**: Quantifier instantiation with triggers\n4. **Model Construction**: Building satisfying assignments","ref":"cure_smt_solver.html#module-proof-search"},{"type":"module","title":"Performance Characteristics - cure_smt_solver","doc":"- **Linear Arithmetic**: Polynomial time in most practical cases\n- **General Arithmetic**: May be exponential (semi-decidable)\n- **Propositional Logic**: NP-complete but efficient SAT solvers\n- **Quantified Formulas**: Undecidable in general, heuristic-based","ref":"cure_smt_solver.html#module-performance-characteristics"},{"type":"module","title":"Integration with Type System - cure_smt_solver","doc":"","ref":"cure_smt_solver.html#module-integration-with-type-system"},{"type":"module","title":"Dependent Types - cure_smt_solver","doc":"```cure\ntype Vector(T, n: Nat) where n > 0\n%% SMT solver verifies: n > 0\n\ndef safe_index(v: Vector(T, n), i: Int) -> T where 0 <= i < n\n%% SMT solver verifies: 0 <= i < n\n```","ref":"cure_smt_solver.html#module-dependent-types"},{"type":"module","title":"Refinement Types - cure_smt_solver","doc":"```cure\ntype Positive = Int where x > 0\ntype Even = Int where x % 2 == 0\n%% SMT solver verifies refinement predicates\n```","ref":"cure_smt_solver.html#module-refinement-types"},{"type":"module","title":"Error Handling - cure_smt_solver","doc":"The SMT solver provides structured error information:\n- **Unsatisfiable Core**: Minimal unsatisfiable subset of constraints\n- **Model Generation**: Concrete counter-examples for failed proofs\n- **Timeout Handling**: Graceful degradation for complex problems\n- **Resource Limits**: Configurable limits on solving time/memory","ref":"cure_smt_solver.html#module-error-handling"},{"type":"module","title":"External Solver Integration - cure_smt_solver","doc":"Supports integration with external SMT solvers:\n- **Z3**: Microsoft Research SMT solver\n- **CVC4**: Stanford/NYU SMT solver  \n- **Yices**: SRI SMT solver\n- **MathSAT**: FBKIRST SMT solver","ref":"cure_smt_solver.html#module-external-solver-integration"},{"type":"module","title":"Thread Safety - cure_smt_solver","doc":"The SMT solver is stateless and thread-safe. Multiple constraint solving\noperations can run concurrently without interference.","ref":"cure_smt_solver.html#module-thread-safety"},{"type":"function","title":"cure_smt_solver.addition_expression/1","doc":"","ref":"cure_smt_solver.html#addition_expression/1"},{"type":"function","title":"cure_smt_solver.arithmetic_constraint/3","doc":"","ref":"cure_smt_solver.html#arithmetic_constraint/3"},{"type":"function","title":"cure_smt_solver.check_proof/2","doc":"","ref":"cure_smt_solver.html#check_proof/2"},{"type":"function","title":"cure_smt_solver.check_satisfiable/1","doc":"","ref":"cure_smt_solver.html#check_satisfiable/1"},{"type":"function","title":"cure_smt_solver.constant_term/1","doc":"","ref":"cure_smt_solver.html#constant_term/1"},{"type":"function","title":"cure_smt_solver.constraint_to_string/1","doc":"","ref":"cure_smt_solver.html#constraint_to_string/1"},{"type":"function","title":"cure_smt_solver.division_expression/1","doc":"","ref":"cure_smt_solver.html#division_expression/1"},{"type":"function","title":"cure_smt_solver.equality_constraint/2","doc":"","ref":"cure_smt_solver.html#equality_constraint/2"},{"type":"function","title":"cure_smt_solver.generate_proof/2","doc":"","ref":"cure_smt_solver.html#generate_proof/2"},{"type":"function","title":"cure_smt_solver.implication_constraint/2","doc":"","ref":"cure_smt_solver.html#implication_constraint/2"},{"type":"function","title":"cure_smt_solver.inequality_constraint/3","doc":"","ref":"cure_smt_solver.html#inequality_constraint/3"},{"type":"function","title":"cure_smt_solver.infer_pattern_length/2","doc":"","ref":"cure_smt_solver.html#infer_pattern_length/2"},{"type":"function","title":"cure_smt_solver.infer_pattern_length_constraint/2","doc":"","ref":"cure_smt_solver.html#infer_pattern_length_constraint/2"},{"type":"function","title":"cure_smt_solver.infer_tail_length_constraint/3","doc":"","ref":"cure_smt_solver.html#infer_tail_length_constraint/3"},{"type":"function","title":"cure_smt_solver.list_pattern_length_constraint/2","doc":"","ref":"cure_smt_solver.html#list_pattern_length_constraint/2"},{"type":"function","title":"cure_smt_solver.modulo_expression/1","doc":"","ref":"cure_smt_solver.html#modulo_expression/1"},{"type":"function","title":"cure_smt_solver.multiplication_expression/1","doc":"","ref":"cure_smt_solver.html#multiplication_expression/1"},{"type":"function","title":"cure_smt_solver.negate_constraint/1","doc":"","ref":"cure_smt_solver.html#negate_constraint/1"},{"type":"function","title":"cure_smt_solver.new_constraint/3","doc":"","ref":"cure_smt_solver.html#new_constraint/3"},{"type":"function","title":"cure_smt_solver.prove_constraint/2","doc":"","ref":"cure_smt_solver.html#prove_constraint/2"},{"type":"function","title":"cure_smt_solver.solve_constraints/1","doc":"","ref":"cure_smt_solver.html#solve_constraints/1"},{"type":"function","title":"cure_smt_solver.solve_constraints/2","doc":"","ref":"cure_smt_solver.html#solve_constraints/2"},{"type":"function","title":"cure_smt_solver.subtraction_expression/1","doc":"","ref":"cure_smt_solver.html#subtraction_expression/1"},{"type":"function","title":"cure_smt_solver.variable_term/1","doc":"","ref":"cure_smt_solver.html#variable_term/1"},{"type":"type","title":"cure_smt_solver.location/0","doc":"","ref":"cure_smt_solver.html#t:location/0"},{"type":"type","title":"cure_smt_solver.proof_term/0","doc":"","ref":"cure_smt_solver.html#t:proof_term/0"},{"type":"type","title":"cure_smt_solver.smt_constraint/0","doc":"","ref":"cure_smt_solver.html#t:smt_constraint/0"},{"type":"type","title":"cure_smt_solver.smt_expression/0","doc":"","ref":"cure_smt_solver.html#t:smt_expression/0"},{"type":"type","title":"cure_smt_solver.smt_term/0","doc":"","ref":"cure_smt_solver.html#t:smt_term/0"},{"type":"module","title":"cure_smt_translator","doc":"# Cure SMT-LIB Translator\n\nTranslates Cure type constraints and expressions into SMT-LIB format\nfor consumption by external SMT solvers (Z3, CVC5).","ref":"cure_smt_translator.html"},{"type":"module","title":"Features - cure_smt_translator","doc":"- Full translation of Cure expressions to SMT-LIB s-expressions\n- Type mapping (Int, Nat, Bool, Float to SMT types)\n- Logic inference (QF_LIA, QF_LRA, etc.)\n- Variable declaration generation\n- Assertion generation from constraints","ref":"cure_smt_translator.html#module-features"},{"type":"module","title":"Usage - cure_smt_translator","doc":"```erlang\n% Translate a constraint to SMT-LIB query\nConstraint = #binary_op_expr{op = '>', left = var(x), right = lit(0)},\nEnv = #{x => {type, int}},\nQuery = cure_smt_translator:generate_query(Constraint, Env).\n% => \\\"(set-logic QF_LIA)\\\\n(declare-const x Int)\\\\n(assert (> x 0))\\\\n(check-sat)\\\\n\\\"\n```","ref":"cure_smt_translator.html#module-usage"},{"type":"function","title":"cure_smt_translator.collect_variables/2","doc":"Collect all variables from a constraint.\n\nTraverses the AST to find all variable references.","ref":"cure_smt_translator.html#collect_variables/2"},{"type":"function","title":"Arguments - cure_smt_translator.collect_variables/2","doc":"- `Constraint` - Cure AST expression\n- `Env` - Environment (for type information)","ref":"cure_smt_translator.html#collect_variables/2-arguments"},{"type":"function","title":"Returns - cure_smt_translator.collect_variables/2","doc":"- `[atom()]` - List of variable names (deduplicated)","ref":"cure_smt_translator.html#collect_variables/2-returns"},{"type":"function","title":"cure_smt_translator.declare_variable/2","doc":"Generate SMT-LIB declaration for a variable.\n\nCreates a (declare-const ...) declaration based on the variable's type.","ref":"cure_smt_translator.html#declare_variable/2"},{"type":"function","title":"Arguments - cure_smt_translator.declare_variable/2","doc":"- `VarName` - Variable name (atom)\n- `Env` - Environment with type information","ref":"cure_smt_translator.html#declare_variable/2-arguments"},{"type":"function","title":"Returns - cure_smt_translator.declare_variable/2","doc":"- `iolist()` - SMT-LIB declaration","ref":"cure_smt_translator.html#declare_variable/2-returns"},{"type":"function","title":"cure_smt_translator.generate_query/2","doc":"Generate a complete SMT-LIB query from a Cure constraint.\n\nProduces a full SMT-LIB query including logic declaration, variable declarations,\nassertions, and check-sat command.","ref":"cure_smt_translator.html#generate_query/2"},{"type":"function","title":"Arguments - cure_smt_translator.generate_query/2","doc":"- `Constraint` - Cure AST expression representing the constraint\n- `Env` - Environment mapping variables to types","ref":"cure_smt_translator.html#generate_query/2-arguments"},{"type":"function","title":"Returns - cure_smt_translator.generate_query/2","doc":"- `iolist()` - SMT-LIB query as iolist (use iolist_to_binary/1 to convert)","ref":"cure_smt_translator.html#generate_query/2-returns"},{"type":"function","title":"Example - cure_smt_translator.generate_query/2","doc":"```erlang\nConstraint = #binary_op_expr{op = '+', left = var(x), right = var(y)},\nQuery = generate_query(Constraint, #{x => {type, int}, y => {type, int}}).\n```","ref":"cure_smt_translator.html#generate_query/2-example"},{"type":"function","title":"cure_smt_translator.generate_query/3","doc":"Generate SMT-LIB query with options.","ref":"cure_smt_translator.html#generate_query/3"},{"type":"function","title":"Options - cure_smt_translator.generate_query/3","doc":"- `{get_model, boolean()}` - Include (get-model) command (default: true)\n- `{logic, smt_logic()}` - Override logic inference\n- `{timeout, integer()}` - Solver timeout hint in milliseconds","ref":"cure_smt_translator.html#generate_query/3-options"},{"type":"function","title":"cure_smt_translator.infer_logic/1","doc":"Infer the appropriate SMT-LIB logic for a constraint.\n\nAnalyzes the constraint to determine which SMT-LIB logic is required.","ref":"cure_smt_translator.html#infer_logic/1"},{"type":"function","title":"Logics - cure_smt_translator.infer_logic/1","doc":"- `QF_LIA` - Quantifier-free linear integer arithmetic\n- `QF_LRA` - Quantifier-free linear real arithmetic  \n- `QF_LIRA` - Quantifier-free linear integer/real arithmetic\n- `QF_NIA` - Quantifier-free nonlinear integer arithmetic","ref":"cure_smt_translator.html#infer_logic/1-logics"},{"type":"function","title":"Arguments - cure_smt_translator.infer_logic/1","doc":"- `Constraint` - Cure AST expression","ref":"cure_smt_translator.html#infer_logic/1-arguments"},{"type":"function","title":"Returns - cure_smt_translator.infer_logic/1","doc":"- `smt_logic()` - Inferred logic","ref":"cure_smt_translator.html#infer_logic/1-returns"},{"type":"function","title":"cure_smt_translator.translate_expr/1","doc":"Translate a Cure expression to SMT-LIB s-expression.\n\nConverts Cure AST expressions to SMT-LIB format recursively.","ref":"cure_smt_translator.html#translate_expr/1"},{"type":"function","title":"Arguments - cure_smt_translator.translate_expr/1","doc":"- `Expr` - Cure AST expression","ref":"cure_smt_translator.html#translate_expr/1-arguments"},{"type":"function","title":"Returns - cure_smt_translator.translate_expr/1","doc":"- `iolist()` - SMT-LIB s-expression","ref":"cure_smt_translator.html#translate_expr/1-returns"},{"type":"function","title":"cure_smt_translator.translate_expr/2","doc":"","ref":"cure_smt_translator.html#translate_expr/2"},{"type":"type","title":"cure_smt_translator.expr/0","doc":"","ref":"cure_smt_translator.html#t:expr/0"},{"type":"type","title":"cure_smt_translator.smt_logic/0","doc":"","ref":"cure_smt_translator.html#t:smt_logic/0"},{"type":"module","title":"cure_std","doc":"# Cure Programming Language - Standard Library Runtime\n\nProvides core runtime functions that cannot be implemented in pure Cure due to\ntheir need for Erlang-specific features. This module contains the essential\nlow-level operations for I/O, monadic operations, FSM integration, and\nvalue serialization.","ref":"cure_std.html"},{"type":"module","title":"Architecture - cure_std","doc":"This module represents the boundary between pure Cure code and the underlying\nErlang runtime. Most standard library functions are now implemented in Cure\nitself (in lib/std/), but this module contains the irreducible core that\nrequires direct Erlang integration.","ref":"cure_std.html#module-architecture"},{"type":"module","title":"Core Responsibilities - cure_std","doc":"- **Monadic Operations**: Implementation of Result/Option pipe semantics\n- **I/O Operations**: Console output and formatting functions\n- **FSM Integration**: Bridge to FSM runtime system\n- **Value Serialization**: Converting Cure values to string representations\n- **Runtime Utilities**: Low-level operations for runtime system","ref":"cure_std.html#module-core-responsibilities"},{"type":"module","title":"Function Categories - cure_std","doc":"","ref":"cure_std.html#module-function-categories"},{"type":"module","title":"Monadic Operations - cure_std","doc":"- `pipe/2` - Monadic pipe operator implementation\n- `is_monad/1` - Type checking for Result/Option values","ref":"cure_std.html#module-monadic-operations"},{"type":"module","title":"I/O Functions - cure_std","doc":"- `print/1` - Output without newline\n- `println/1` - Output with newline\n- `show/1` - Convert values to string representation","ref":"cure_std.html#module-i-o-functions"},{"type":"module","title":"FSM Operations - cure_std","doc":"- `fsm_create/2` - Create FSM instances\n- `fsm_send_safe/2` - Safe message sending to FSMs\n- `create_counter/1` - Specialized counter FSM creation","ref":"cure_std.html#module-fsm-operations"},{"type":"module","title":"Utility Functions - cure_std","doc":"- `list_to_string/1` - List serialization\n- `join_ints/2` - Integer list formatting","ref":"cure_std.html#module-utility-functions"},{"type":"module","title":"Monadic Pipe Semantics - cure_std","doc":"The `pipe/2` function implements Cure's monadic pipe operator (|>) with\nthese rules:\n\n1. **Error Propagation**: `Error(x) |> f` = `Error(x)`\n2. **Ok Unwrapping**: `Ok(x) |> f` = `f(x)` (wrapped if not already monadic)\n3. **Value Passing**: `x |> f` = `f(x)` (wrapped if not already monadic)","ref":"cure_std.html#module-monadic-pipe-semantics"},{"type":"module","title":"Example Usage - cure_std","doc":"```erlang\n%% Direct function calls (typically from runtime)\ncure_std:print(\"Hello, World!\").\ncure_std:pipe({'Ok', 5}, fun(X) -> X * 2 end).\n%% Returns: {'Ok', 10}\n\ncure_std:show({'Ok', [1, 2, 3]}).\n%% Returns: \"Ok([1, 2, 3])\"\n```","ref":"cure_std.html#module-example-usage"},{"type":"module","title":"Integration with Cure - cure_std","doc":"Functions in this module are automatically registered in the runtime's\nglobal function registry and can be called from Cure code using standard\nfunction call syntax. The runtime handles the bridge between Cure's\ntype system and Erlang's dynamic typing.","ref":"cure_std.html#module-integration-with-cure"},{"type":"module","title":"Error Handling - cure_std","doc":"- I/O functions always succeed (return 'ok')\n- Pipe operations catch Erlang exceptions and wrap them as Error values\n- FSM operations return Result types for safe error handling\n- Show function handles unknown types gracefully","ref":"cure_std.html#module-error-handling"},{"type":"module","title":"Performance Considerations - cure_std","doc":"- All functions are designed for single-call efficiency\n- String operations use efficient list concatenation\n- Monadic operations minimize pattern matching overhead\n- FSM operations are lightweight stubs (full implementation in cure_fsm_runtime)","ref":"cure_std.html#module-performance-considerations"},{"type":"function","title":"cure_std.create_counter/1","doc":"","ref":"cure_std.html#create_counter/1"},{"type":"function","title":"cure_std.fsm_create/2","doc":"","ref":"cure_std.html#fsm_create/2"},{"type":"function","title":"cure_std.fsm_send_safe/2","doc":"","ref":"cure_std.html#fsm_send_safe/2"},{"type":"function","title":"cure_std.is_monad/1","doc":"Checks if a value is a monadic type (Result or Option).\n\nThis function determines whether a value follows the monadic pattern\nused by Cure's Result and Option types, which is essential for proper\npipe operator behavior.","ref":"cure_std.html#is_monad/1"},{"type":"function","title":"Arguments - cure_std.is_monad/1","doc":"- `Value` - Any Erlang term to check","ref":"cure_std.html#is_monad/1-arguments"},{"type":"function","title":"Returns - cure_std.is_monad/1","doc":"- `true` - Value is a Result (Ok/Error) type\n- `false` - Value is not a monadic type","ref":"cure_std.html#is_monad/1-returns"},{"type":"function","title":"Example - cure_std.is_monad/1","doc":"```erlang\ncure_std:is_monad({'Ok', 42}).     %% true\ncure_std:is_monad({'Error', msg}). %% true\ncure_std:is_monad(42).             %% false\ncure_std:is_monad([1, 2, 3]).      %% false\n```","ref":"cure_std.html#is_monad/1-example"},{"type":"function","title":"Supported Monadic Types - cure_std.is_monad/1","doc":"- `{'Ok', Value}` - Successful result with value\n- `{'Error', Reason}` - Failed result with error reason\n\nNote: Option types (Some/None) are not currently detected as monadic\nby this function, though they follow similar patterns.","ref":"cure_std.html#is_monad/1-supported-monadic-types"},{"type":"function","title":"Usage - cure_std.is_monad/1","doc":"Primarily used internally by pipe/2 to determine whether function\nresults need to be wrapped in Ok constructors or can be returned as-is.","ref":"cure_std.html#is_monad/1-usage"},{"type":"function","title":"cure_std.join_ints/2","doc":"","ref":"cure_std.html#join_ints/2"},{"type":"function","title":"cure_std.list_to_string/1","doc":"","ref":"cure_std.html#list_to_string/1"},{"type":"function","title":"cure_std.pipe/2","doc":"Implements Cure's monadic pipe operator (|>) with Result type semantics.\n\nThis function is the core implementation of Cure's pipe operator, providing\nmonadic composition with automatic error propagation and value wrapping.\nIt handles three distinct cases based on the input value type.","ref":"cure_std.html#pipe/2"},{"type":"function","title":"Arguments - cure_std.pipe/2","doc":"- `LHO` - Left-hand operand (value to be piped)\n- `RHO` - Right-hand operand (function to apply)","ref":"cure_std.html#pipe/2-arguments"},{"type":"function","title":"Returns - cure_std.pipe/2","doc":"- Result of applying RHO to LHO (possibly unwrapped), with appropriate wrapping\n- Error values are propagated without calling RHO\n- Runtime errors are caught and wrapped as Error values","ref":"cure_std.html#pipe/2-returns"},{"type":"function","title":"Pipe Rules - cure_std.pipe/2","doc":"","ref":"cure_std.html#pipe/2-pipe-rules"},{"type":"function","title":"Rule 1: Error Propagation - cure_std.pipe/2","doc":"```erlang\ncure_std:pipe({'Error', reason}, Fun).\n%% Returns: {'Error', reason} (Fun is not called)\n```","ref":"cure_std.html#pipe/2-rule-1-error-propagation"},{"type":"function","title":"Rule 2: Ok Unwrapping - cure_std.pipe/2","doc":"```erlang\ncure_std:pipe({'Ok', 5}, fun(X) -> X * 2 end).\n%% Returns: {'Ok', 10} (value unwrapped, result wrapped)\n\ncure_std:pipe({'Ok', 5}, fun(X) -> {'Ok', X * 2} end).\n%% Returns: {'Ok', 10} (already monadic, not double-wrapped)\n```","ref":"cure_std.html#pipe/2-rule-2-ok-unwrapping"},{"type":"function","title":"Rule 3: Value Passing - cure_std.pipe/2","doc":"```erlang\ncure_std:pipe(5, fun(X) -> X * 2 end).\n%% Returns: {'Ok', 10} (non-monadic input, result wrapped)\n\ncure_std:pipe(5, fun(X) -> {'Error', 'too_big'} end).\n%% Returns: {'Error', 'too_big'} (monadic result preserved)\n```","ref":"cure_std.html#pipe/2-rule-3-value-passing"},{"type":"function","title":"Error Handling - cure_std.pipe/2","doc":"If RHO throws an exception during execution:\n```erlang\ncure_std:pipe({'Ok', 0}, fun(X) -> 1/X end).\n%% Returns: {'Error', {pipe_runtime_error, error, badarith}}\n```","ref":"cure_std.html#pipe/2-error-handling"},{"type":"function","title":"Usage in Cure - cure_std.pipe/2","doc":"```cure\n%% In Cure code, this becomes:\nvalue |> function1 |> function2\n\n%% Which compiles to:\npipe(pipe(value, function1), function2)\n```","ref":"cure_std.html#pipe/2-usage-in-cure"},{"type":"function","title":"Type Safety - cure_std.pipe/2","doc":"The pipe operator maintains type safety by:\n- Never double-wrapping already monadic values\n- Propagating errors without execution\n- Catching runtime exceptions as Error values\n- Preserving monadic invariants through composition chains","ref":"cure_std.html#pipe/2-type-safety"},{"type":"function","title":"cure_std.print/1","doc":"Prints a message to standard output without adding a newline.\n\nThis function outputs text directly to the console using Erlang's I/O\nformatting system. It's designed for inline output where you want to\ncontinue writing on the same line.","ref":"cure_std.html#print/1"},{"type":"function","title":"Arguments - cure_std.print/1","doc":"- `Message` - String or list to print (must be printable)","ref":"cure_std.html#print/1-arguments"},{"type":"function","title":"Returns - cure_std.print/1","doc":"- `ok` - Always succeeds","ref":"cure_std.html#print/1-returns"},{"type":"function","title":"Example - cure_std.print/1","doc":"```erlang\ncure_std:print(\"Hello \").\ncure_std:print(\"World!\").\n%% Output: \"Hello World!\"\n\ncure_std:print(\"Count: \").\ncure_std:print(integer_to_list(42)).\n%% Output: \"Count: 42\"\n```","ref":"cure_std.html#print/1-example"},{"type":"function","title":"Usage in Cure - cure_std.print/1","doc":"```cure\nprint(\"Processing...\")\n// Continue with other operations\nprint(\"Done!\")\n```","ref":"cure_std.html#print/1-usage-in-cure"},{"type":"function","title":"Character Encoding - cure_std.print/1","doc":"Supports Unicode text through Erlang's ~ts format specifier,\nensuring proper handling of international characters.","ref":"cure_std.html#print/1-character-encoding"},{"type":"function","title":"Error Handling - cure_std.print/1","doc":"I/O errors are handled by the underlying Erlang system.\nThis function always returns 'ok' from the Cure perspective.","ref":"cure_std.html#print/1-error-handling"},{"type":"function","title":"cure_std.println/1","doc":"Prints a message to standard output followed by a newline.\n\nThis is the most commonly used output function, automatically adding\na newline character after the message for line-by-line output formatting.","ref":"cure_std.html#println/1"},{"type":"function","title":"Arguments - cure_std.println/1","doc":"- `Message` - String or list to print (must be printable)","ref":"cure_std.html#println/1-arguments"},{"type":"function","title":"Returns - cure_std.println/1","doc":"- `ok` - Always succeeds","ref":"cure_std.html#println/1-returns"},{"type":"function","title":"Example - cure_std.println/1","doc":"```erlang\ncure_std:println(\"First line\").\ncure_std:println(\"Second line\").\n%% Output:\n%% First line\n%% Second line\n\ncure_std:println(\"Value: \" ++ integer_to_list(42)).\n%% Output: Value: 42\n```","ref":"cure_std.html#println/1-example"},{"type":"function","title":"Usage in Cure - cure_std.println/1","doc":"```cure\nprintln(\"Hello, World!\")\nprintln(\"This is on a new line\")\n```","ref":"cure_std.html#println/1-usage-in-cure"},{"type":"function","title":"Character Encoding - cure_std.println/1","doc":"Supports Unicode text through Erlang's ~ts format specifier,\nensuring proper handling of international characters.","ref":"cure_std.html#println/1-character-encoding"},{"type":"function","title":"Comparison with print/1 - cure_std.println/1","doc":"- `print/1` - No newline, for inline output\n- `println/1` - Adds newline, for line-based output","ref":"cure_std.html#println/1-comparison-with-print-1"},{"type":"function","title":"Error Handling - cure_std.println/1","doc":"I/O errors are handled by the underlying Erlang system.\nThis function always returns 'ok' from the Cure perspective.","ref":"cure_std.html#println/1-error-handling"},{"type":"function","title":"cure_std.Succ/1","doc":"Nat type unary constructor representing successor.\n\nTakes a natural number and returns its successor (n+1).\nThis is the inductive case of Peano-encoded natural numbers.","ref":"cure_std.html#Succ/1"},{"type":"function","title":"Arguments - cure_std.Succ/1","doc":"- `N` - A natural number (Nat)","ref":"cure_std.html#Succ/1-arguments"},{"type":"function","title":"Returns - cure_std.Succ/1","doc":"- N+1 (next natural number)","ref":"cure_std.html#Succ/1-returns"},{"type":"function","title":"Example - cure_std.Succ/1","doc":"```erlang\ncure_std:'Succ'(0).        %% Returns: 1 (successor of Zero)\ncure_std:'Succ'(5).        %% Returns: 6 (successor of 5)\n```","ref":"cure_std.html#Succ/1-example"},{"type":"function","title":"Usage in Cure - cure_std.Succ/1","doc":"```cure\nlet one = Succ(Zero)\nlet two = Succ(Succ(Zero))\nlet three = Succ(two)\n```","ref":"cure_std.html#Succ/1-usage-in-cure"},{"type":"function","title":"Type - cure_std.Succ/1","doc":"- Succ : Nat -> Nat","ref":"cure_std.html#Succ/1-type"},{"type":"function","title":"cure_std.show/1","doc":"Converts any Cure value to its string representation for debugging and display.\n\nThis function provides comprehensive string serialization for all Cure data\ntypes, with special handling for monadic types (Result/Option) and structured\ndata like lists and tuples.","ref":"cure_std.html#show/1"},{"type":"function","title":"Arguments - cure_std.show/1","doc":"- `Value` - Any Cure/Erlang term to convert to string","ref":"cure_std.html#show/1-arguments"},{"type":"function","title":"Returns - cure_std.show/1","doc":"- String representation of the value\n- \"unknown\" for unrecognized value types","ref":"cure_std.html#show/1-returns"},{"type":"function","title":"Examples - cure_std.show/1","doc":"","ref":"cure_std.html#show/1-examples"},{"type":"function","title":"Monadic Types - cure_std.show/1","doc":"```erlang\ncure_std:show({'Ok', 42}).        %% \"Ok(42)\"\ncure_std:show({'Error', failed}). %% \"Error(failed)\"\ncure_std:show({'Some', data}).    %% \"Some(data)\"\ncure_std:show('None').            %% \"None\"\n```","ref":"cure_std.html#show/1-monadic-types"},{"type":"function","title":"Basic Types - cure_std.show/1","doc":"```erlang\ncure_std:show(42).           %% \"42\"\ncure_std:show(3.14).         %% \"3.14\"\ncure_std:show(hello).        %% \"hello\"\ncure_std:show(\"string\").     %% \"string\"\n```","ref":"cure_std.html#show/1-basic-types"},{"type":"function","title":"Structured Types - cure_std.show/1","doc":"```erlang\ncure_std:show([1, 2, 3]).           %% \"[1, 2, 3]\"\ncure_std:show({a, b}).              %% \"{a, b}\"\ncure_std:show({1, 2, 3, 4}).        %% \"{1, 2, 3, 4}\"\ncure_std:show({1, 2, 3, 4, 5}).     %% \"{1, 2, 3, 4, ...}\"\n```","ref":"cure_std.html#show/1-structured-types"},{"type":"function","title":"Nested Structures - cure_std.show/1","doc":"```erlang\ncure_std:show({'Ok', [1, 2, {'Some', 3}]}).\n%% \"Ok([1, 2, Some(3)])\"\n```","ref":"cure_std.html#show/1-nested-structures"},{"type":"function","title":"Usage in Cure - cure_std.show/1","doc":"```cure\nlet value = Ok([1, 2, 3])\nprintln(show(value))  // Outputs: Ok([1, 2, 3])\n```","ref":"cure_std.html#show/1-usage-in-cure"},{"type":"function","title":"Tuple Handling - cure_std.show/1","doc":"- Tuples with 0-4 elements: Full representation\n- Tuples with 5+ elements: Truncated with \"...\" suffix\n- Nested tuples are recursively formatted","ref":"cure_std.html#show/1-tuple-handling"},{"type":"function","title":"Error Handling - cure_std.show/1","doc":"Unknown or unsupported types return \"unknown\" rather than crashing,\nmaking this function safe for debugging any Cure value.","ref":"cure_std.html#show/1-error-handling"},{"type":"function","title":"Performance Notes - cure_std.show/1","doc":"- Recursive formatting for nested structures\n- String concatenation using Erlang's efficient list operations\n- Optimized for readability over performance","ref":"cure_std.html#show/1-performance-notes"},{"type":"function","title":"cure_std.Zero/0","doc":"Nat type nullary constructor representing zero.\n\nIn Cure's Peano encoding of natural numbers:\n- Zero represents 0\n- Succ(Zero) represents 1\n- Succ(Succ(Zero)) represents 2, etc.","ref":"cure_std.html#Zero/0"},{"type":"function","title":"Returns - cure_std.Zero/0","doc":"- 0 (represented as integer for runtime efficiency)","ref":"cure_std.html#Zero/0-returns"},{"type":"function","title":"Example - cure_std.Zero/0","doc":"```erlang\ncure_std:'Zero'().  %% Returns: 0\n```","ref":"cure_std.html#Zero/0-example"},{"type":"function","title":"Usage in Cure - cure_std.Zero/0","doc":"```cure\ndef length(list: List(T)): Nat =\n  match list do\n    [] -> Zero\n    [_ | t] -> Succ(length(t))\n  end\n```","ref":"cure_std.html#Zero/0-usage-in-cure"},{"type":"function","title":"Type - cure_std.Zero/0","doc":"- Zero : Nat","ref":"cure_std.html#Zero/0-type"},{"type":"module","title":"cure_string_native","doc":"Native Erlang implementations of string operations for Cure.\n\nProvides high-performance string manipulation functions that operate on\nUTF-8 binaries (String type) and charlists (Charlist type).","ref":"cure_string_native.html"},{"type":"function","title":"cure_string_native.at/2","doc":"Get the grapheme at a specific index (0-based).\nReturns {ok, Grapheme} or {error, out_of_bounds}.","ref":"cure_string_native.html#at/2"},{"type":"function","title":"cure_string_native.byte_size/1","doc":"Get the byte size of a string.","ref":"cure_string_native.html#byte_size/1"},{"type":"function","title":"cure_string_native.capitalize/1","doc":"Capitalize the first grapheme of a string.","ref":"cure_string_native.html#capitalize/1"},{"type":"function","title":"cure_string_native.codepoints/1","doc":"Get a list of Unicode codepoints from a string.","ref":"cure_string_native.html#codepoints/1"},{"type":"function","title":"cure_string_native.concat/2","doc":"Concatenate two strings efficiently.","ref":"cure_string_native.html#concat/2"},{"type":"function","title":"cure_string_native.contains/2","doc":"Check if a string contains a substring.","ref":"cure_string_native.html#contains/2"},{"type":"function","title":"cure_string_native.downcase/1","doc":"Convert string to lowercase (Unicode-aware).","ref":"cure_string_native.html#downcase/1"},{"type":"function","title":"cure_string_native.duplicate/2","doc":"Duplicate a string n times.","ref":"cure_string_native.html#duplicate/2"},{"type":"function","title":"cure_string_native.ends_with/2","doc":"Check if a string ends with a given suffix.","ref":"cure_string_native.html#ends_with/2"},{"type":"function","title":"cure_string_native.first/1","doc":"Get the first grapheme of a string.","ref":"cure_string_native.html#first/1"},{"type":"function","title":"cure_string_native.from_binary/1","doc":"Convert a binary to a string, validating UTF-8.\nReturns {ok, String} or {error, invalid_utf8}.","ref":"cure_string_native.html#from_binary/1"},{"type":"function","title":"cure_string_native.from_charlist/1","doc":"Convert a charlist to a UTF-8 string.","ref":"cure_string_native.html#from_charlist/1"},{"type":"function","title":"cure_string_native.graphemes/1","doc":"Split a string into a list of grapheme clusters.","ref":"cure_string_native.html#graphemes/1"},{"type":"function","title":"cure_string_native.is_empty/1","doc":"Check if a string is empty.","ref":"cure_string_native.html#is_empty/1"},{"type":"function","title":"cure_string_native.join/2","doc":"Join a list of strings with a separator.","ref":"cure_string_native.html#join/2"},{"type":"function","title":"cure_string_native.last/1","doc":"Get the last grapheme of a string.","ref":"cure_string_native.html#last/1"},{"type":"function","title":"cure_string_native.length/1","doc":"Get the length of a string in graphemes (Unicode-aware).","ref":"cure_string_native.html#length/1"},{"type":"function","title":"cure_string_native.pad_left/3","doc":"Pad a string on the left to a given width.","ref":"cure_string_native.html#pad_left/3"},{"type":"function","title":"cure_string_native.pad_right/3","doc":"Pad a string on the right to a given width.","ref":"cure_string_native.html#pad_right/3"},{"type":"function","title":"cure_string_native.replace/3","doc":"Replace the first occurrence of a pattern.","ref":"cure_string_native.html#replace/3"},{"type":"function","title":"cure_string_native.replace_all/3","doc":"Replace all occurrences of a pattern.","ref":"cure_string_native.html#replace_all/3"},{"type":"function","title":"cure_string_native.reverse/1","doc":"Reverse a string (Unicode-aware, reverses graphemes).","ref":"cure_string_native.html#reverse/1"},{"type":"function","title":"cure_string_native.slice/3","doc":"Extract a substring by grapheme position and length.","ref":"cure_string_native.html#slice/3"},{"type":"function","title":"cure_string_native.split/2","doc":"Split a string by a pattern.","ref":"cure_string_native.html#split/2"},{"type":"function","title":"cure_string_native.split_at/2","doc":"Split a string at a specific grapheme index.","ref":"cure_string_native.html#split_at/2"},{"type":"function","title":"cure_string_native.starts_with/2","doc":"Check if a string starts with a given prefix.","ref":"cure_string_native.html#starts_with/2"},{"type":"function","title":"cure_string_native.to_atom/1","doc":"Convert string to atom.","ref":"cure_string_native.html#to_atom/1"},{"type":"function","title":"cure_string_native.to_binary/1","doc":"Convert string to raw binary (identity function for strings).","ref":"cure_string_native.html#to_binary/1"},{"type":"function","title":"cure_string_native.to_charlist/1","doc":"Convert a UTF-8 string to a charlist.","ref":"cure_string_native.html#to_charlist/1"},{"type":"function","title":"cure_string_native.trim/1","doc":"Trim whitespace from both ends of a string.","ref":"cure_string_native.html#trim/1"},{"type":"function","title":"cure_string_native.trim_left/1","doc":"Trim whitespace from the left side of a string.","ref":"cure_string_native.html#trim_left/1"},{"type":"function","title":"cure_string_native.trim_right/1","doc":"Trim whitespace from the right side of a string.","ref":"cure_string_native.html#trim_right/1"},{"type":"function","title":"cure_string_native.upcase/1","doc":"Convert string to uppercase (Unicode-aware).","ref":"cure_string_native.html#upcase/1"},{"type":"function","title":"cure_string_native.valid_utf8/1","doc":"Check if a binary is valid UTF-8.","ref":"cure_string_native.html#valid_utf8/1"},{"type":"module","title":"cure_type_optimizer","doc":"# Cure Programming Language - Type-directed Optimizer\n\nThe type optimizer leverages rich type information from Cure's dependent type\nsystem to perform sophisticated program optimizations. It analyzes type usage\npatterns, specializes generic functions, eliminates dead code, and optimizes\nmemory layouts based on static type analysis.","ref":"cure_type_optimizer.html"},{"type":"module","title":"Key Features - cure_type_optimizer","doc":"","ref":"cure_type_optimizer.html#module-key-features"},{"type":"module","title":"Function Specialization - cure_type_optimizer","doc":"- **Type-based Specialization**: Creates specialized versions of generic functions\n- **Call-site Analysis**: Identifies frequent type instantiations\n- **Cost-benefit Analysis**: Balances code size vs. performance gains\n- **Automatic Generation**: Generates specialized function variants","ref":"cure_type_optimizer.html#module-function-specialization"},{"type":"module","title":"Monomorphization - cure_type_optimizer","doc":"- **Generic Elimination**: Converts polymorphic functions to monomorphic variants\n- **Type Instantiation**: Resolves all type variables with concrete types\n- **Dispatch Optimization**: Eliminates runtime type dispatch overhead\n- **Template Expansion**: Expands type templates at compile time","ref":"cure_type_optimizer.html#module-monomorphization"},{"type":"module","title":"Inlining Optimization - cure_type_optimizer","doc":"- **Type-guided Inlining**: Uses type information for better inlining decisions\n- **Call-site Specialization**: Inlines based on argument types\n- **Size Thresholds**: Configurable limits to prevent code bloat\n- **Hot-path Optimization**: Prioritizes frequently executed code paths","ref":"cure_type_optimizer.html#module-inlining-optimization"},{"type":"module","title":"Dead Code Elimination - cure_type_optimizer","doc":"- **Type-based Reachability**: Uses type analysis for precise dead code detection\n- **Specialization Cleanup**: Removes unused specialized variants\n- **Constraint-based Analysis**: Leverages dependent type constraints\n- **Whole-program Analysis**: Global dead code elimination","ref":"cure_type_optimizer.html#module-dead-code-elimination"},{"type":"module","title":"Memory Layout Optimization - cure_type_optimizer","doc":"- **Struct Packing**: Optimizes memory layout based on type information\n- **Cache-aware Layouts**: Arranges fields for better cache locality\n- **Alignment Optimization**: Ensures proper alignment for performance\n- **Size Minimization**: Reduces memory footprint where possible","ref":"cure_type_optimizer.html#module-memory-layout-optimization"},{"type":"module","title":"Optimization Pipeline - cure_type_optimizer","doc":"","ref":"cure_type_optimizer.html#module-optimization-pipeline"},{"type":"module","title":"Phase 1: Type Analysis - cure_type_optimizer","doc":"```erlang\n{TypeInfo, UsageStats} = cure_type_optimizer:analyze_program_types(AST),\n%% Collects:\n%% - Function type signatures\n%% - Call site information with argument types\n%% - Type usage frequencies\n%% - Monomorphic instantiation opportunities\n```","ref":"cure_type_optimizer.html#module-phase-1-type-analysis"},{"type":"module","title":"Phase 2: Opportunity Identification - cure_type_optimizer","doc":"```erlang\nContext = cure_type_optimizer:find_optimization_opportunities(AST, Context1),\n%% Identifies:\n%% - Specialization candidates\n%% - Inlining opportunities\n%% - Dead code\n%% - Memory layout improvements\n```","ref":"cure_type_optimizer.html#module-phase-2-opportunity-identification"},{"type":"module","title":"Phase 3: Optimization Application - cure_type_optimizer","doc":"```erlang\nOptimizedAST = cure_type_optimizer:run_optimization_passes(AST, Context2),\n%% Applies optimizations in order:\n%% 1. Function specialization\n%% 2. Monomorphization  \n%% 3. Inlining\n%% 4. Dead code elimination\n%% 5. Memory layout optimization\n```","ref":"cure_type_optimizer.html#module-phase-3-optimization-application"},{"type":"module","title":"Usage Examples - cure_type_optimizer","doc":"","ref":"cure_type_optimizer.html#module-usage-examples"},{"type":"module","title":"Program Optimization - cure_type_optimizer","doc":"```erlang\n%% Basic optimization with default settings\n{ok, OptimizedAST, Report} = cure_type_optimizer:optimize_program(AST),\n\n%% Custom optimization configuration\nConfig = #optimization_config{\n    level = 3,  % Aggressive optimization\n    enable_specialization = true,\n    max_specializations = 20,\n    inline_threshold = 100\n},\n{ok, OptimizedAST, Report} = cure_type_optimizer:optimize_program(AST, Config).\n```","ref":"cure_type_optimizer.html#module-program-optimization"},{"type":"module","title":"Module-level Optimization - cure_type_optimizer","doc":"```erlang\n{ok, OptimizedModule} = cure_type_optimizer:optimize_module(Module),\n\n%% With custom config\n{ok, OptimizedModule} = cure_type_optimizer:optimize_module(Module, Config).\n```","ref":"cure_type_optimizer.html#module-module-level-optimization"},{"type":"module","title":"Individual Optimization Passes - cure_type_optimizer","doc":"```erlang\n%% Run specific optimization passes\nSpecializedAST = cure_type_optimizer:function_specialization_pass(AST),\nMonomorphicAST = cure_type_optimizer:monomorphization_pass(SpecializedAST),\nInlinedAST = cure_type_optimizer:inlining_pass(MonomorphicAST).\n```","ref":"cure_type_optimizer.html#module-individual-optimization-passes"},{"type":"module","title":"Configuration Options - cure_type_optimizer","doc":"","ref":"cure_type_optimizer.html#module-configuration-options"},{"type":"module","title":"Optimization Levels - cure_type_optimizer","doc":"- **Level 0**: No optimizations (debugging)\n- **Level 1**: Basic optimizations (safe, minimal)\n- **Level 2**: Standard optimizations (default, balanced)\n- **Level 3**: Aggressive optimizations (maximum performance)","ref":"cure_type_optimizer.html#module-optimization-levels"},{"type":"module","title":"Fine-grained Control - cure_type_optimizer","doc":"- **Specialization Limits**: Maximum number of specialized variants\n- **Inlining Thresholds**: Size limits for function inlining\n- **Memory Optimization**: Enable/disable layout optimizations\n- **Pass Selection**: Enable/disable individual optimization passes","ref":"cure_type_optimizer.html#module-fine-grained-control"},{"type":"module","title":"Performance Characteristics - cure_type_optimizer","doc":"","ref":"cure_type_optimizer.html#module-performance-characteristics"},{"type":"module","title":"Typical Improvements - cure_type_optimizer","doc":"- **Function Calls**: 25-60% improvement through specialization\n- **Memory Usage**: 10-30% reduction through layout optimization\n- **Code Size**: Variable (may increase with specialization, decrease with DCE)\n- **Compile Time**: Increases proportionally to optimization level","ref":"cure_type_optimizer.html#module-typical-improvements"},{"type":"module","title":"Analysis Complexity - cure_type_optimizer","doc":"- **Type Analysis**: O(n log n) where n is program size\n- **Specialization**: O(k × m) where k is candidates, m is instantiations\n- **Dead Code**: O(n + e) where e is call graph edges\n- **Memory Layout**: O(t) where t is number of types","ref":"cure_type_optimizer.html#module-analysis-complexity"},{"type":"module","title":"Integration - cure_type_optimizer","doc":"The type optimizer integrates with:\n- **Type Checker**: Uses inferred type information\n- **Code Generator**: Provides optimized AST for compilation\n- **Runtime**: Optimizes for runtime performance characteristics\n- **Profiler**: Can use runtime profiling data for optimization hints","ref":"cure_type_optimizer.html#module-integration"},{"type":"module","title":"Optimization Report - cure_type_optimizer","doc":"Generates detailed reports including:\n- **Specializations Created**: List of generated specialized functions\n- **Inlining Decisions**: Functions inlined and their sizes\n- **Dead Code Eliminated**: Removed functions and their impact\n- **Memory Improvements**: Layout changes and size reductions\n- **Performance Estimates**: Expected performance improvements","ref":"cure_type_optimizer.html#module-optimization-report"},{"type":"module","title":"Safety and Correctness - cure_type_optimizer","doc":"- **Type Preservation**: All optimizations preserve type safety\n- **Semantic Equivalence**: Optimized code maintains original semantics\n- **Constraint Preservation**: Dependent type constraints are maintained\n- **Error Handling**: Graceful degradation when optimization fails","ref":"cure_type_optimizer.html#module-safety-and-correctness"},{"type":"function","title":"cure_type_optimizer.analyze_program_types/1","doc":"","ref":"cure_type_optimizer.html#analyze_program_types/1"},{"type":"function","title":"cure_type_optimizer.analyze_specialization_candidates/1","doc":"","ref":"cure_type_optimizer.html#analyze_specialization_candidates/1"},{"type":"function","title":"cure_type_optimizer.analyze_type_usage/1","doc":"","ref":"cure_type_optimizer.html#analyze_type_usage/1"},{"type":"function","title":"cure_type_optimizer.collect_call_sites/1","doc":"","ref":"cure_type_optimizer.html#collect_call_sites/1"},{"type":"function","title":"cure_type_optimizer.collect_poly_instantiation_sites/1","doc":"","ref":"cure_type_optimizer.html#collect_poly_instantiation_sites/1"},{"type":"function","title":"cure_type_optimizer.collect_poly_instantiations_from_expr/2","doc":"","ref":"cure_type_optimizer.html#collect_poly_instantiations_from_expr/2"},{"type":"function","title":"cure_type_optimizer.collect_poly_instantiations_from_function/1","doc":"","ref":"cure_type_optimizer.html#collect_poly_instantiations_from_function/1"},{"type":"function","title":"cure_type_optimizer.collect_poly_instantiations_from_module/1","doc":"","ref":"cure_type_optimizer.html#collect_poly_instantiations_from_module/1"},{"type":"function","title":"cure_type_optimizer.collect_type_information/1","doc":"","ref":"cure_type_optimizer.html#collect_type_information/1"},{"type":"function","title":"cure_type_optimizer.collect_type_usage_patterns/1","doc":"","ref":"cure_type_optimizer.html#collect_type_usage_patterns/1"},{"type":"function","title":"cure_type_optimizer.count_function_calls/1","doc":"","ref":"cure_type_optimizer.html#count_function_calls/1"},{"type":"function","title":"cure_type_optimizer.create_monomorphic_function/3","doc":"","ref":"cure_type_optimizer.html#create_monomorphic_function/3"},{"type":"function","title":"cure_type_optimizer.dead_code_elimination_pass/1","doc":"","ref":"cure_type_optimizer.html#dead_code_elimination_pass/1"},{"type":"function","title":"cure_type_optimizer.dead_code_elimination_pass/2","doc":"","ref":"cure_type_optimizer.html#dead_code_elimination_pass/2"},{"type":"function","title":"cure_type_optimizer.default_optimization_config/0","doc":"","ref":"cure_type_optimizer.html#default_optimization_config/0"},{"type":"function","title":"cure_type_optimizer.eliminate_unused_specializations/2","doc":"","ref":"cure_type_optimizer.html#eliminate_unused_specializations/2"},{"type":"function","title":"cure_type_optimizer.find_optimization_opportunities/2","doc":"","ref":"cure_type_optimizer.html#find_optimization_opportunities/2"},{"type":"function","title":"cure_type_optimizer.find_reachable_functions/2","doc":"","ref":"cure_type_optimizer.html#find_reachable_functions/2"},{"type":"function","title":"cure_type_optimizer.find_specialization_opportunities/1","doc":"","ref":"cure_type_optimizer.html#find_specialization_opportunities/1"},{"type":"function","title":"cure_type_optimizer.function_specialization_pass/1","doc":"","ref":"cure_type_optimizer.html#function_specialization_pass/1"},{"type":"function","title":"cure_type_optimizer.function_specialization_pass/2","doc":"","ref":"cure_type_optimizer.html#function_specialization_pass/2"},{"type":"function","title":"cure_type_optimizer.generate_specialized_variants/2","doc":"","ref":"cure_type_optimizer.html#generate_specialized_variants/2"},{"type":"function","title":"cure_type_optimizer.identify_cold_code/1","doc":"","ref":"cure_type_optimizer.html#identify_cold_code/1"},{"type":"function","title":"cure_type_optimizer.identify_hot_paths/1","doc":"","ref":"cure_type_optimizer.html#identify_hot_paths/1"},{"type":"function","title":"cure_type_optimizer.initialize_optimization_context/1","doc":"","ref":"cure_type_optimizer.html#initialize_optimization_context/1"},{"type":"function","title":"cure_type_optimizer.inlining_pass/1","doc":"","ref":"cure_type_optimizer.html#inlining_pass/1"},{"type":"function","title":"cure_type_optimizer.inlining_pass/2","doc":"","ref":"cure_type_optimizer.html#inlining_pass/2"},{"type":"function","title":"cure_type_optimizer.memory_layout_optimization_pass/1","doc":"","ref":"cure_type_optimizer.html#memory_layout_optimization_pass/1"},{"type":"function","title":"cure_type_optimizer.memory_layout_optimization_pass/2","doc":"","ref":"cure_type_optimizer.html#memory_layout_optimization_pass/2"},{"type":"function","title":"cure_type_optimizer.monomorphization_pass/1","doc":"","ref":"cure_type_optimizer.html#monomorphization_pass/1"},{"type":"function","title":"cure_type_optimizer.monomorphization_pass/2","doc":"","ref":"cure_type_optimizer.html#monomorphization_pass/2"},{"type":"function","title":"cure_type_optimizer.monomorphize_ast/2","doc":"","ref":"cure_type_optimizer.html#monomorphize_ast/2"},{"type":"function","title":"cure_type_optimizer.optimize_module/1","doc":"","ref":"cure_type_optimizer.html#optimize_module/1"},{"type":"function","title":"cure_type_optimizer.optimize_module/2","doc":"","ref":"cure_type_optimizer.html#optimize_module/2"},{"type":"function","title":"cure_type_optimizer.optimize_program/1","doc":"","ref":"cure_type_optimizer.html#optimize_program/1"},{"type":"function","title":"cure_type_optimizer.optimize_program/2","doc":"","ref":"cure_type_optimizer.html#optimize_program/2"},{"type":"function","title":"cure_type_optimizer.replace_poly_calls_in_expr/2","doc":"","ref":"cure_type_optimizer.html#replace_poly_calls_in_expr/2"},{"type":"function","title":"cure_type_optimizer.run_optimization_passes/2","doc":"","ref":"cure_type_optimizer.html#run_optimization_passes/2"},{"type":"function","title":"cure_type_optimizer.set_optimization_level/1","doc":"","ref":"cure_type_optimizer.html#set_optimization_level/1"},{"type":"function","title":"cure_type_optimizer.specialize_function_body/3","doc":"","ref":"cure_type_optimizer.html#specialize_function_body/3"},{"type":"function","title":"cure_type_optimizer.track_polymorphic_call/3","doc":"","ref":"cure_type_optimizer.html#track_polymorphic_call/3"},{"type":"function","title":"cure_type_optimizer.transform_ast_with_specializations/2","doc":"","ref":"cure_type_optimizer.html#transform_ast_with_specializations/2"},{"type":"module","title":"cure_typechecker","doc":"# Cure Programming Language - Type Checker\n\nThe type checker module provides high-level type checking functionality for\nCure programs. It works with parsed AST nodes and implements comprehensive\nstatic type analysis including dependent type verification, constraint solving, and type inference.","ref":"cure_typechecker.html"},{"type":"module","title":"Features - cure_typechecker","doc":"","ref":"cure_typechecker.html#module-features"},{"type":"module","title":"Comprehensive Type Checking - cure_typechecker","doc":"- **Program-Level Analysis**: Full program type checking with module support\n- **Function Type Checking**: Parameter and return type verification\n- **Expression Type Inference**: Bottom-up type inference for all expressions\n- **Dependent Type Support**: Verification of dependent type constraints","ref":"cure_typechecker.html#module-comprehensive-type-checking"},{"type":"module","title":"Module System Support - cure_typechecker","doc":"- **Module Scoping**: Proper scoping of types and functions within modules\n- **Export Verification**: Ensures exported functions exist and have correct types\n- **Import Resolution**: Type-safe import of functions and types from other modules\n- **Two-Pass Processing**: Collects signatures before checking bodies","ref":"cure_typechecker.html#module-module-system-support"},{"type":"module","title":"Advanced Type Features - cure_typechecker","doc":"- **Generic Functions**: Full support for parametric polymorphism\n- **Constraint Solving**: Integration with SMT-based constraint solving\n- **FSM Type Checking**: Verification of finite state machine definitions\n- **Erlang Interop**: Type checking for Erlang function interfaces","ref":"cure_typechecker.html#module-advanced-type-features"},{"type":"module","title":"Error Reporting - cure_typechecker","doc":"- **Detailed Error Messages**: Precise error locations with helpful descriptions\n- **Warning System**: Non-fatal issues that may indicate problems\n- **Error Recovery**: Continues checking after errors to find more issues\n- **Structured Results**: Machine-readable error and warning information","ref":"cure_typechecker.html#module-error-reporting"},{"type":"module","title":"Type Checking Process - cure_typechecker","doc":"","ref":"cure_typechecker.html#module-type-checking-process"},{"type":"module","title":"1. Environment Setup - cure_typechecker","doc":"```erlang\nEnv = cure_typechecker:builtin_env(),  % Built-in types and functions\nR esult = cure_typechecker:check_program(AST).\n```","ref":"cure_typechecker.html#module-1-environment-setup"},{"type":"module","title":"2. Module Processing - cure_typechecker","doc":"- **Signature Collection**: First pass collects all function signatures\n- **Body Checking**: Second pass verifies function bodies against signatures  \n- **Export Validation**: Ensures all exported items are properly typed","ref":"cure_typechecker.html#module-2-module-processing"},{"type":"module","title":"3. Function Analysis - cure_typechecker","doc":"- **Parameter Processing**: Converts parameter types to environment bindings\n- **Constraint Checking**: Verifies function constraints are boolean expressions\n- **Body Inference**: Infers body type and checks against declared return type\n- **Generic Resolution**: Resolves type parameters and constraints","ref":"cure_typechecker.html#module-3-function-analysis"},{"type":"module","title":"Usage Examples - cure_typechecker","doc":"","ref":"cure_typechecker.html#module-usage-examples"},{"type":"module","title":"Program Type Checking - cure_typechecker","doc":"```erlang\nAST = cure_parser:parse_file(\"example.cure\"),\nResult = cure_typechecker:check_program(AST),\ncase Result#typecheck_result.success of\n  true ->\n    cure_utils:debug(\"Type checking successful~n\");\n \n  false -> \n    Errors = Result#typecheck_result.errors,\n    cure_utils:debug(\"Type errors: ~p~n\", [Errors])\nend.\n```","ref":"cure_typechecker.html#module-program-type-checking"},{"type":"module","title":"Function Type Checking - cure_typechecker","doc":"```erlang\nFuncAST = #function_def{name = add, params = Params, body = Body, ...},\n{ok, Env, Result} = cure_typechecker:check_function(FuncAST).\n```","ref":"cure_typechecker.html#module-function-type-checking"},{"type":"module","title":"Expression Type Inference - cure_typechecker","doc":"```erlang\n{ok, Type} = cure_typechecker:check_expression(ExprAST, Environment).\n```","ref":"cure_typechecker.html#module-expression-type-inference"},{"type":"module","title":"Type Checking Results - cure_typechecker","doc":"Returns structured results with:\n\n- **Success Flag**: Overall type checking success/failure\n- **Inferred Types**: Types inferred for expressions and functions\n- **Error List**: Detailed error information with locations\n- **Warnings**: Non-fatal issues found during checking","ref":"cure_typechecker.html#module-type-checking-results"},{"type":"module","title":"Built-in Environment - cure_typechecker","doc":"Provides built-in types and functions:\n\n- **Primitive Types**: Int, Float, String, Bool, Atom\n- **Type Constructors**: List, Tuple, Map, Vector\n- **Standard Functions**: Arithmetic, logical, and utility functions\n- **FSM Operations**: Built-in FSM manipulati on functions","ref":"cure_typechecker.html#module-built-in-environment"},{"type":"module","title":"Integration - cure_typechecker","doc":"This module integrates with:\n\n- **cure_types**: Core type system operations\n- **cure_parser**: Processes parsed AST nodes  \n- **cure_smt_solver**: Constraint solving for dependent types\n- **cure_type_optimizer**: Provides type information for optimizations","ref":"cure_typechecker.html#module-integration"},{"type":"module","title":"Error Categories - cure_typechecker","doc":"- **Type Mismatches**: Incompatible type assignments or operations\n- **Undefined Variables**: References to unbound variables\n- **Constraint Violations**: Failed dependent type constraints\n- **Export Errors**: Missing or incorrectly typed exported functions\n- **Import Errors**: Invalid module imports or type mismatches","ref":"cure_typechecker.html#module-error-categories"},{"type":"module","title":"Performance - cure_typechecker","doc":"- **Two-Pass Efficiency**: Minimizes redundant type checking\n- **Incremental Checking**: Supports incremental compilation scenarios\n- **Constraint Caching**: Reuses constraint solving results where possible\n- **Environment Sharing**: Efficient environment management","ref":"cure_typechecker.html#module-performance"},{"type":"module","title":"Thread Safety - cure_typechecker","doc":"The type checker is stateless and thread-safe. Multiple type checking\noperations can run concurrently on different ASTs.","ref":"cure_typechecker.html#module-thread-safety"},{"type":"function","title":"cure_typechecker.builtin_env/0","doc":"","ref":"cure_typechecker.html#builtin_env/0"},{"type":"function","title":"cure_typechecker.check_dependent_constraint/3","doc":"","ref":"cure_typechecker.html#check_dependent_constraint/3"},{"type":"function","title":"cure_typechecker.check_expression/2","doc":"","ref":"cure_typechecker.html#check_expression/2"},{"type":"function","title":"cure_typechecker.check_expression/3","doc":"","ref":"cure_typechecker.html#check_expression/3"},{"type":"function","title":"cure_typechecker.check_fsm/2","doc":"","ref":"cure_typechecker.html#check_fsm/2"},{"type":"function","title":"cure_typechecker.check_function/2","doc":"","ref":"cure_typechecker.html#check_function/2"},{"type":"function","title":"cure_typechecker.check_module/2","doc":"","ref":"cure_typechecker.html#check_module/2"},{"type":"function","title":"cure_typechecker.check_program/1","doc":"Type checks an entire Cure program.\n\nPerforms comprehensive type checking of all top-level items in the program\nincluding modules, functions, FSMs, and type definitions.","ref":"cure_typechecker.html#check_program/1"},{"type":"function","title":"Arguments - cure_typechecker.check_program/1","doc":"- `AST` - List of top-level AST items from the parser","ref":"cure_typechecker.html#check_program/1-arguments"},{"type":"function","title":"Returns - cure_typechecker.check_program/1","doc":"- `typecheck_result()` - Complete type checking results including:\n- `success` - Boolean indicating overall success/failure\n- `type` - Program type (usually undefined for programs)\n- `errors` - List of type checking errors found\n- `warnings` \n- List of warnings found","ref":"cure_typechecker.html#check_program/1-returns"},{"type":"function","title":"Example - cure_typechecker.check_program/1","doc":"```erlang\nAST = cure_parser:parse_file(\"example.cure\"),\nResult = cure_typechecker:check_program(AST),\ncase Result#typecheck_result.success of\n  true -> \n    cure_utils:debug(\"Program type checks successfully~n\");\n \n  false -> \n    lists:foreach(fun(Error) ->\n      cure_utils:debug(\"Error: ~s~n\", [Error#typecheck_error.message])\n    end, Result#typecheck_result.errors)\nend.\n```","ref":"cure_typechecker.html#check_program/1-example"},{"type":"function","title":"Features - cure_typechecker.check_program/1","doc":"- **Built-in Environment**: Uses standard built-in types and functions\n- **Error Recovery**: Continues checking after errors to find more issues\n- **Two-Pass Processing**: Collects signatures before checking implementations\".","ref":"cure_typechecker.html#check_program/1-features"},{"type":"function","title":"cure_typechecker.convert_and_resolve_record_field_tuple/2","doc":"","ref":"cure_typechecker.html#convert_and_resolve_record_field_tuple/2"},{"type":"function","title":"cure_typechecker.convert_record_field_def/1","doc":"","ref":"cure_typechecker.html#convert_record_field_def/1"},{"type":"function","title":"cure_typechecker.convert_type_to_tuple/1","doc":"","ref":"cure_typechecker.html#convert_type_to_tuple/1"},{"type":"function","title":"cure_typechecker.create_function_type_from_signature/2","doc":"","ref":"cure_typechecker.html#create_function_type_from_signature/2"},{"type":"function","title":"cure_typechecker.create_function_type_from_signature_records/2","doc":"","ref":"cure_typechecker.html#create_function_type_from_signature_records/2"},{"type":"function","title":"cure_typechecker.extract_and_add_type_params/2","doc":"","ref":"cure_typechecker.html#extract_and_add_type_params/2"},{"type":"function","title":"cure_typechecker.extract_module_functions/1","doc":"","ref":"cure_typechecker.html#extract_module_functions/1"},{"type":"function","title":"cure_typechecker.extract_type_param_value/2","doc":"","ref":"cure_typechecker.html#extract_type_param_value/2"},{"type":"function","title":"cure_typechecker.extract_type_params_helper/2","doc":"","ref":"cure_typechecker.html#extract_type_params_helper/2"},{"type":"function","title":"cure_typechecker.get_stdlib_function_type/3","doc":"","ref":"cure_typechecker.html#get_stdlib_function_type/3"},{"type":"function","title":"cure_typechecker.infer_dependent_type/2","doc":"","ref":"cure_typechecker.html#infer_dependent_type/2"},{"type":"function","title":"cure_typechecker.infer_type/2","doc":"","ref":"cure_typechecker.html#infer_type/2"},{"type":"function","title":"cure_typechecker.load_stdlib_modules/0","doc":"","ref":"cure_typechecker.html#load_stdlib_modules/0"},{"type":"module","title":"cure_types","doc":"# Cure Programming Language - Type System Core\n\nThe core type system module implementing Cure's advanced dependent type system\nwith constraint solving, type inference, and support for higher-kinded types.\nThis module provides the foundational type operations that power Cure's static\ntype checking and dependent type verification.","ref":"cure_types.html"},{"type":"module","title":"Key Features - cure_types","doc":"","ref":"cure_types.html#module-key-features"},{"type":"module","title":"Dependent Types - cure_types","doc":"- **Value Dependencies**: Types that depend on runtime values (e.g., `Vector(T, n)`)\n- **Constraint Solving**: SMT-based constraint solving for dependent type verification\n- **Type-Level Computation**: Evaluation of type expressions with value parameters","ref":"cure_types.html#module-dependent-types"},{"type":"module","title":"Advanced Type System - cure_types","doc":"- **Higher-Kinded Types**: Support for type constructors and type families\n- **Recursive Types**: μ-types with cycle detection and well-formedness checking\n- **Union Types**: Discriminated union types with exhaustiveness checking\n- **Generic Types**: Full parametric polymorphism with constraint-based inference","ref":"cure_types.html#module-advanced-type-system"},{"type":"module","title":"Type Inference Engine - cure_types","doc":"- **Bidirectional Inference**: Combines bottom-up and top-down type inference\n- **Constraint Generation**: Generates and solves complex type constraints\n- **Alternative Generation**: Provides multiple type possibilities with confidence scores\n- **Local Inference**: Context-aware type inference for improved accuracy","ref":"cure_types.html#module-type-inference-engine"},{"type":"module","title":"Unification Algorithm - cure_types","doc":"- **Robinson Unification**: Extended Robinson unification for dependent types\n- **Occurs Check**: Prevents infinite types with comprehensive cycle detection\n- **Constraint Propagation**: Propagates type constraints through unification\n- **Substitution Management**: Efficient substitution composition and application","ref":"cure_types.html#module-unification-algorithm"},{"type":"module","title":"Core Operations - cure_types","doc":"","ref":"cure_types.html#module-core-operations"},{"type":"module","title":"Type Variables - cure_types","doc":"```erlang\n%% Create new type variables\nTVar1 = cure_types:new_type_var(),\nTVar2 = cure_types:new_type_var(custom_name).\n\n%% Check type variable properties\ntrue = cure_types:is_type_var(TVar1),\nfalse = cure_types:occurs_check(TVar1, IntType).\n```","ref":"cure_types.html#module-type-variables"},{"type":"module","title":"Type Unification - cure_types","doc":"```erlang\n%% Unify two types\n{ok, Substitution} = cure_types:unify(Type1, Type2),\n{ok, Sub, Constraints} = cure_types:unify(Type1, Type2, Environment).\n```","ref":"cure_types.html#module-type-unification"},{"type":"module","title":"Type Inference - cure_types","doc":"```erlang\n%% Basic type inference\n{ok, InferredType} = cure_types:infer_type(Expression, Environment),\n\n%% Enhanced inference with alternatives\n{ok, Result} = cure_types:enhanced_infer_type(Expression, Environment),\nConfidence = Result#enhanced_inference_result.confidence,\nAlternatives = Result#enhanced_inference_result.alternatives.\n```","ref":"cure_types.html#module-type-inference"},{"type":"module","title":"Type Environment - cure_types","doc":"The type environment maintains variable bindings and constraints:\n- **Hierarchical Scoping**: Supports nested scopes with parent environments\n- **Constraint Accumulation**: Collects and manages type constraints\n- **Efficient Lookup**: Fast variable resolution with scope traversal\n\n```erlang\n%% Environment operations\nEnv1 = cure_types:new_env(),\nEnv2 = cure_types:extend_env(Env1, variable_name, VariableType),\n{ok, Type} = cure_types:lookup_env(Env2, variable_name).\n```","ref":"cure_types.html#module-type-environment"},{"type":"module","title":"Constraint Solving - cure_types","doc":"Supports various constraint types:\n- **Equality**: `T = U`\n- **Subtyping**: `T <: U`\n- **Element Membership**: `x elem_of T`\n- **Length Constraints**: `length(xs) = n`\n- **Logical Constraints**: `implies`, `iff`\n- **Variance Constraints**: `covariant`, `contravariant`","ref":"cure_types.html#module-constraint-solving"},{"type":"module","title":"Higher-Kinded Types - cure_types","doc":"```erlang\n%% Create type constructors\nListKind = cure_types:create_kind('*', [], '*'),\nFunctorKind = cure_types:create_kind('->', [ListKind], ListKind),\n\n%% Type families\nFamily = cure_types:create_type_family(map, [F, T], Dependencies, Constraints),\nResult = cure_types:evaluate_type_family(Family, Arguments).\n```","ref":"cure_types.html#module-higher-kinded-types"},{"type":"module","title":"Performance Characteristics - cure_types","doc":"- **Type Inference**: O(n log n) for most expressions\n- **Unification**: O(n) for structural types, O(n²) worst case\n- **Constraint Solving**: Depends on constraint complexity, uses SMT solver\n- **Memory Usage**: Efficient substitution sharing reduces memory overhead","ref":"cure_types.html#module-performance-characteristics"},{"type":"module","title":"Integration - cure_types","doc":"This module integrates with:\n- **Type Checker**: Provides core type operations for checking\n- **SMT Solver**: Delegates complex constraint solving\n- **Type Optimizer**: Provides types for optimization decisions\n- **Parser**: Processes type annotations and expressions","ref":"cure_types.html#module-integration"},{"type":"module","title":"Error Handling - cure_types","doc":"Returns structured errors for:\n- **Unification Failures**: Detailed mismatch information\n- **Constraint Violations**: Specific constraint failure reasons\n- **Infinite Types**: Occurs check violations\n- **Kind Errors**: Higher-kinded type mismatches","ref":"cure_types.html#module-error-handling"},{"type":"module","title":"Thread Safety - cure_types","doc":"Type variables use a global counter that should be accessed safely in\nconcurrent environments. The module is otherwise stateless and thread-safe.","ref":"cure_types.html#module-thread-safety"},{"type":"function","title":"cure_types.apply_type_constructor/3","doc":"","ref":"cure_types.html#apply_type_constructor/3"},{"type":"function","title":"cure_types.bidirectional_infer/3","doc":"","ref":"cure_types.html#bidirectional_infer/3"},{"type":"function","title":"cure_types.check_constraint_satisfaction/2","doc":"","ref":"cure_types.html#check_constraint_satisfaction/2"},{"type":"function","title":"cure_types.check_dependent_constraint/3","doc":"","ref":"cure_types.html#check_dependent_constraint/3"},{"type":"function","title":"cure_types.check_higher_kinded_well_formed/1","doc":"","ref":"cure_types.html#check_higher_kinded_well_formed/1"},{"type":"function","title":"cure_types.check_kind/3","doc":"","ref":"cure_types.html#check_kind/3"},{"type":"function","title":"cure_types.check_recursive_convergence/3","doc":"Checks if recursive constraint solving has converged.\n\nConvergence is determined by comparing the change in substitutions\nbetween iterations.","ref":"cure_types.html#check_recursive_convergence/3"},{"type":"function","title":"Arguments - cure_types.check_recursive_convergence/3","doc":"- `OldSubst` - Previous substitution\n- `NewSubst` - Current substitution\n- `RecState` - Recursive inference state with convergence threshold","ref":"cure_types.html#check_recursive_convergence/3-arguments"},{"type":"function","title":"Returns - cure_types.check_recursive_convergence/3","doc":"- `{converged, FinalSubst}` - If convergence achieved\n- `{not_converged, MergedSubst}` - If more iterations needed","ref":"cure_types.html#check_recursive_convergence/3-returns"},{"type":"function","title":"cure_types.check_recursive_type_well_formed/1","doc":"","ref":"cure_types.html#check_recursive_type_well_formed/1"},{"type":"function","title":"cure_types.check_type/3","doc":"","ref":"cure_types.html#check_type/3"},{"type":"function","title":"cure_types.check_type/4","doc":"","ref":"cure_types.html#check_type/4"},{"type":"function","title":"cure_types.constraint_propagation/2","doc":"","ref":"cure_types.html#constraint_propagation/2"},{"type":"function","title":"cure_types.create_kind/3","doc":"","ref":"cure_types.html#create_kind/3"},{"type":"function","title":"cure_types.create_recursive_type/4","doc":"","ref":"cure_types.html#create_recursive_type/4"},{"type":"function","title":"cure_types.create_type_constructor/5","doc":"","ref":"cure_types.html#create_type_constructor/5"},{"type":"function","title":"cure_types.create_type_family/4","doc":"","ref":"cure_types.html#create_type_family/4"},{"type":"function","title":"cure_types.detect_cycles/2","doc":"","ref":"cure_types.html#detect_cycles/2"},{"type":"function","title":"cure_types.enhanced_constraint_solving/2","doc":"","ref":"cure_types.html#enhanced_constraint_solving/2"},{"type":"function","title":"cure_types.enhanced_infer_type/2","doc":"","ref":"cure_types.html#enhanced_infer_type/2"},{"type":"function","title":"cure_types.enhanced_infer_type/3","doc":"","ref":"cure_types.html#enhanced_infer_type/3"},{"type":"function","title":"cure_types.evaluate_type_family/2","doc":"","ref":"cure_types.html#evaluate_type_family/2"},{"type":"function","title":"cure_types.evaluate_type_predicate/2","doc":"","ref":"cure_types.html#evaluate_type_predicate/2"},{"type":"function","title":"cure_types.extend_env/3","doc":"Extends a type environment with a new variable binding.\n\nSupports multiple environment representations for different use cases.","ref":"cure_types.html#extend_env/3"},{"type":"function","title":"Arguments - cure_types.extend_env/3","doc":"- `Env` - Type environment (type_env(), map(), or list())\n- `Var` - Variable name (atom())\n- `Type` - Type expression to bind to the variable","ref":"cure_types.html#extend_env/3-arguments"},{"type":"function","title":"Returns - cure_types.extend_env/3","doc":"- Updated environment with the new binding","ref":"cure_types.html#extend_env/3-returns"},{"type":"function","title":"Supported Environment Types - cure_types.extend_env/3","doc":"- **type_env()**: Full environment with constraints and parent scopes\n- **map()**: Simple map for lightweight inference\n- **list()**: Association list for basic scoping","ref":"cure_types.html#extend_env/3-supported-environment-types"},{"type":"function","title":"Example - cure_types.extend_env/3","doc":"```erlang\nEnv1 = cure_types:new_env(),\nEnv2 = cure_types:extend_env(Env1, x, {primitive_type, 'Int'}),\nEnv3 = cure_types:extend_env(Env2, y, {primitive_type, 'String'}).\n```","ref":"cure_types.html#extend_env/3-example"},{"type":"function","title":"cure_types.extract_param_info/2","doc":"","ref":"cure_types.html#extract_param_info/2"},{"type":"function","title":"cure_types.extract_type_param_names/1","doc":"Extract type parameter names from a list that may contain atoms or records.","ref":"cure_types.html#extract_type_param_names/1"},{"type":"function","title":"Arguments - cure_types.extract_type_param_names/1","doc":"- `TypeParams` - List of atoms or #type_param_decl{} records","ref":"cure_types.html#extract_type_param_names/1-arguments"},{"type":"function","title":"Returns - cure_types.extract_type_param_names/1","doc":"List of type parameter name atoms","ref":"cure_types.html#extract_type_param_names/1-returns"},{"type":"function","title":"cure_types.extract_vector_params/1","doc":"","ref":"cure_types.html#extract_vector_params/1"},{"type":"function","title":"cure_types.fold_recursive_type/2","doc":"","ref":"cure_types.html#fold_recursive_type/2"},{"type":"function","title":"cure_types.free_type_vars/1","doc":"Find all free type variables in a type.","ref":"cure_types.html#free_type_vars/1"},{"type":"function","title":"Arguments - cure_types.free_type_vars/1","doc":"- `Type` - Type expression to analyze","ref":"cure_types.html#free_type_vars/1-arguments"},{"type":"function","title":"Returns - cure_types.free_type_vars/1","doc":"Set of type variable names/ids that appear free in the type","ref":"cure_types.html#free_type_vars/1-returns"},{"type":"function","title":"cure_types.free_type_vars_in_env/1","doc":"Find all free type variables in a type environment.","ref":"cure_types.html#free_type_vars_in_env/1"},{"type":"function","title":"Arguments - cure_types.free_type_vars_in_env/1","doc":"- `Env` - Type environment","ref":"cure_types.html#free_type_vars_in_env/1-arguments"},{"type":"function","title":"Returns - cure_types.free_type_vars_in_env/1","doc":"Set of type variable names/ids that appear free in any type in the environment","ref":"cure_types.html#free_type_vars_in_env/1-returns"},{"type":"function","title":"cure_types.fresh_type_vars_for_params/1","doc":"Create fresh type variables for a list of type parameters.","ref":"cure_types.html#fresh_type_vars_for_params/1"},{"type":"function","title":"Arguments - cure_types.fresh_type_vars_for_params/1","doc":"- `TypeParams` - List of type parameter atoms or #type_param_decl{} records","ref":"cure_types.html#fresh_type_vars_for_params/1-arguments"},{"type":"function","title":"Returns - cure_types.fresh_type_vars_for_params/1","doc":"A map from type parameter names to fresh type variables","ref":"cure_types.html#fresh_type_vars_for_params/1-returns"},{"type":"function","title":"Example - cure_types.fresh_type_vars_for_params/1","doc":"```erlang\nFreshVars = fresh_type_vars_for_params(['T', 'U']).\n% Result: #{'T' => TypeVar1, 'U' => TypeVar2}\n```","ref":"cure_types.html#fresh_type_vars_for_params/1-example"},{"type":"function","title":"cure_types.generalize_type/2","doc":"Generalize a type by quantifying over free type variables.\n\nImplements Hindley-Milner let-polymorphism by creating a poly_type\nthat quantifies over type variables that are free in the type but\nnot free in the environment.","ref":"cure_types.html#generalize_type/2"},{"type":"function","title":"Arguments - cure_types.generalize_type/2","doc":"- `Type` - Type to generalize\n- `Env` - Current type environment","ref":"cure_types.html#generalize_type/2-arguments"},{"type":"function","title":"Returns - cure_types.generalize_type/2","doc":"Either a poly_type (if there are free type variables) or the original type","ref":"cure_types.html#generalize_type/2-returns"},{"type":"function","title":"Example - cure_types.generalize_type/2","doc":"```erlang\n% Type: T -> T where T is free\n% Env: {x: Int}\n% Result: forall T. T -> T\nType = {function_type, [TypeVar], TypeVar},\nGeneralized = generalize_type(Type, Env).\n```","ref":"cure_types.html#generalize_type/2-example"},{"type":"function","title":"cure_types.generate_list_alternatives/3","doc":"","ref":"cure_types.html#generate_list_alternatives/3"},{"type":"function","title":"cure_types.generate_type_alternatives/3","doc":"","ref":"cure_types.html#generate_type_alternatives/3"},{"type":"function","title":"cure_types.get_tuple_param_info/1","doc":"","ref":"cure_types.html#get_tuple_param_info/1"},{"type":"function","title":"cure_types.infer_dependent_type/2","doc":"","ref":"cure_types.html#infer_dependent_type/2"},{"type":"function","title":"cure_types.infer_kind/2","doc":"","ref":"cure_types.html#infer_kind/2"},{"type":"function","title":"cure_types.infer_pattern_type/3","doc":"","ref":"cure_types.html#infer_pattern_type/3"},{"type":"function","title":"cure_types.infer_recursive_function_call/4","doc":"Performs type inference for recursive function calls with dependent type tracking.\n\nThis is the main entry point for recursive function call type inference that\nproperly handles dependent types across recursive boundaries.","ref":"cure_types.html#infer_recursive_function_call/4"},{"type":"function","title":"Arguments - cure_types.infer_recursive_function_call/4","doc":"- `FunctionName` - Name of the recursive function\n- `Args` - Argument expressions\n- `Env` - Type environment\n- `RecState` - Recursive inference state","ref":"cure_types.html#infer_recursive_function_call/4-arguments"},{"type":"function","title":"Returns - cure_types.infer_recursive_function_call/4","doc":"- `{ok, ResultType, Constraints, UpdatedState}` - Successful inference\n- `{error, Reason}` - Type inference failure","ref":"cure_types.html#infer_recursive_function_call/4-returns"},{"type":"function","title":"Features - cure_types.infer_recursive_function_call/4","doc":"- **Dependent Type Tracking**: Maintains dependent relationships across calls\n- **Fixed-Point Computation**: Iterates until type constraints converge\n- **Constraint Propagation**: Propagates constraints between recursive levels\n- **Cycle Detection**: Prevents infinite recursion in type inference","ref":"cure_types.html#infer_recursive_function_call/4-features"},{"type":"function","title":"cure_types.infer_type/2","doc":"","ref":"cure_types.html#infer_type/2"},{"type":"function","title":"cure_types.infer_type/3","doc":"","ref":"cure_types.html#infer_type/3"},{"type":"function","title":"cure_types.infer_with_alternatives/3","doc":"","ref":"cure_types.html#infer_with_alternatives/3"},{"type":"function","title":"cure_types.instantiate_poly_type/1","doc":"Instantiate a poly_type record with fresh type variables.\n\nHandles the poly_type AST record which explicitly represents\npolymorphic types with forall quantification.","ref":"cure_types.html#instantiate_poly_type/1"},{"type":"function","title":"Arguments - cure_types.instantiate_poly_type/1","doc":"- `PolyType` - A #poly_type{} record","ref":"cure_types.html#instantiate_poly_type/1-arguments"},{"type":"function","title":"Returns - cure_types.instantiate_poly_type/1","doc":"The instantiated body type with fresh type variables","ref":"cure_types.html#instantiate_poly_type/1-returns"},{"type":"function","title":"cure_types.instantiate_poly_type/2","doc":"Instantiate a poly_type record with provided type arguments.\n\nHandles explicit type application where concrete types are provided\nfor type parameters (e.g., id  applies Int to identity function).","ref":"cure_types.html#instantiate_poly_type/2"},{"type":"function","title":"Arguments - cure_types.instantiate_poly_type/2","doc":"- `PolyType` - A #poly_type{} record\n- `TypeArgs` - List of concrete types to substitute for type parameters","ref":"cure_types.html#instantiate_poly_type/2-arguments"},{"type":"function","title":"Returns - cure_types.instantiate_poly_type/2","doc":"The instantiated body type with type arguments substituted","ref":"cure_types.html#instantiate_poly_type/2-returns"},{"type":"function","title":"cure_types.instantiate_polymorphic_type/2","doc":"Instantiate a polymorphic type with fresh type variables.\n\nGiven a type with type parameters (e.g., forall T. T -> T), creates a new\ntype with fresh type variables replacing all type parameters.","ref":"cure_types.html#instantiate_polymorphic_type/2"},{"type":"function","title":"Arguments - cure_types.instantiate_polymorphic_type/2","doc":"- `Type` - The polymorphic type to instantiate\n- `TypeParams` - List of type parameter names to instantiate (e.g., ['T', 'U'])","ref":"cure_types.html#instantiate_polymorphic_type/2-arguments"},{"type":"function","title":"Returns - cure_types.instantiate_polymorphic_type/2","doc":"The instantiated type with fresh type variables","ref":"cure_types.html#instantiate_polymorphic_type/2-returns"},{"type":"function","title":"Example - cure_types.instantiate_polymorphic_type/2","doc":"```erlang\nPolyType = {function_type, [{primitive_type, 'T'}], {primitive_type, 'T'}},\nInstType = instantiate_polymorphic_type(PolyType, ['T']).\n% Result: {function_type, [TypeVar1], TypeVar1} where TypeVar1 is fresh\n```","ref":"cure_types.html#instantiate_polymorphic_type/2-example"},{"type":"function","title":"cure_types.instantiate_polymorphic_type_if_needed/1","doc":"Instantiate a polymorphic type if needed, handling both poly_type and regular types.\n\nThis is the main entry point for type instantiation during inference.\nIt handles:\n- poly_type records: Instantiates with fresh type variables\n- Regular function types: Uses existing instantiate_type_if_function\n- Other types: Returns as-is","ref":"cure_types.html#instantiate_polymorphic_type_if_needed/1"},{"type":"function","title":"Arguments - cure_types.instantiate_polymorphic_type_if_needed/1","doc":"- `Type` - Any type expression","ref":"cure_types.html#instantiate_polymorphic_type_if_needed/1-arguments"},{"type":"function","title":"Returns - cure_types.instantiate_polymorphic_type_if_needed/1","doc":"Instantiated type with fresh type variables for polymorphic types","ref":"cure_types.html#instantiate_polymorphic_type_if_needed/1-returns"},{"type":"function","title":"cure_types.instantiate_type_if_function/1","doc":"","ref":"cure_types.html#instantiate_type_if_function/1"},{"type":"function","title":"cure_types.is_generic_type_variable_name/1","doc":"","ref":"cure_types.html#is_generic_type_variable_name/1"},{"type":"function","title":"cure_types.is_nat_type/1","doc":"Checks if a type expression represents the Nat type.\n\nRecognizes both the algebraic Nat type (union type with Zero/Succ)\nand the refined Nat type (non-negative integers).","ref":"cure_types.html#is_nat_type/1"},{"type":"function","title":"Arguments - cure_types.is_nat_type/1","doc":"- `Type` - Type expression to check","ref":"cure_types.html#is_nat_type/1-arguments"},{"type":"function","title":"Returns - cure_types.is_nat_type/1","doc":"- `true` - If the type is Nat or Nat-related\n- `false` - Otherwise","ref":"cure_types.html#is_nat_type/1-returns"},{"type":"function","title":"Example - cure_types.is_nat_type/1","doc":"```erlang\ntrue = cure_types:is_nat_type({primitive_type, 'Nat'}),\ntrue = cure_types:is_nat_type({union_type, 'Nat', _, _}),\ntrue = cure_types:is_nat_type({refined_type, 'Int', ...}).\n```","ref":"cure_types.html#is_nat_type/1-example"},{"type":"function","title":"cure_types.is_saturated_type/1","doc":"","ref":"cure_types.html#is_saturated_type/1"},{"type":"function","title":"cure_types.is_type_var/1","doc":"Checks if a term is a type variable.","ref":"cure_types.html#is_type_var/1"},{"type":"function","title":"Arguments - cure_types.is_type_var/1","doc":"- `Term` - Any term to check","ref":"cure_types.html#is_type_var/1-arguments"},{"type":"function","title":"Returns - cure_types.is_type_var/1","doc":"- `true` - If the term is a type_var record\n- `false` - Otherwise","ref":"cure_types.html#is_type_var/1-returns"},{"type":"function","title":"Example - cure_types.is_type_var/1","doc":"```erlang\nTVar = cure_types:new_type_var(),\ntrue = cure_types:is_type_var(TVar),\nfalse = cure_types:is_type_var(my_atom).\n```","ref":"cure_types.html#is_type_var/1-example"},{"type":"function","title":"cure_types.is_well_formed_type/1","doc":"","ref":"cure_types.html#is_well_formed_type/1"},{"type":"function","title":"cure_types.kind_arity/1","doc":"","ref":"cure_types.html#kind_arity/1"},{"type":"function","title":"cure_types.local_type_inference/3","doc":"","ref":"cure_types.html#local_type_inference/3"},{"type":"function","title":"cure_types.lookup_env/2","doc":"Looks up a variable binding in the type environment.\n\nSearches the current environment and parent environments if available.","ref":"cure_types.html#lookup_env/2"},{"type":"function","title":"Arguments - cure_types.lookup_env/2","doc":"- `Env` - Type environment (type_env(), map(), or list())\n- `Var` - Variable name to look up (atom())","ref":"cure_types.html#lookup_env/2-arguments"},{"type":"function","title":"Returns - cure_types.lookup_env/2","doc":"- `Type` - The type bound to the variable if found\n- `undefined` - If the variable is not bound in the environment","ref":"cure_types.html#lookup_env/2-returns"},{"type":"function","title":"Scoping - cure_types.lookup_env/2","doc":"For type_env() records, searches parent environments if the variable\nis not found in the current scope.","ref":"cure_types.html#lookup_env/2-scoping"},{"type":"function","title":"Example - cure_types.lookup_env/2","doc":"```erlang\nEnv = cure_types:extend_env(cure_types:new_env(), x, IntType),\nIntType = cure_types:lookup_env(Env, x),\nundefined = cure_types:lookup_env(Env, unbound_var).\n```","ref":"cure_types.html#lookup_env/2-example"},{"type":"function","title":"cure_types.nat_from_int/1","doc":"Converts an Erlang integer to Peano-encoded Nat.\n\nCreates a chain of Succ constructors wrapping Zero,\nrepresenting the given non-negative integer.","ref":"cure_types.html#nat_from_int/1"},{"type":"function","title":"Arguments - cure_types.nat_from_int/1","doc":"- `N` - Non-negative integer","ref":"cure_types.html#nat_from_int/1-arguments"},{"type":"function","title":"Returns - cure_types.nat_from_int/1","doc":"- `{ok, NatExpr}` - Peano-encoded natural number\n- `{error, negative_integer}` - If N < 0","ref":"cure_types.html#nat_from_int/1-returns"},{"type":"function","title":"Example - cure_types.nat_from_int/1","doc":"```erlang\n{ok, Three} = cure_types:nat_from_int(3),\n%% Results in Succ(Succ(Succ(Zero)))\n```","ref":"cure_types.html#nat_from_int/1-example"},{"type":"function","title":"cure_types.nat_succ/1","doc":"Constructs the successor of a natural number.\n\nIn Peano encoding, Succ(n) represents n+1,\nsimilar to Idris's S constructor.","ref":"cure_types.html#nat_succ/1"},{"type":"function","title":"Arguments - cure_types.nat_succ/1","doc":"- `Nat` - A natural number expression","ref":"cure_types.html#nat_succ/1-arguments"},{"type":"function","title":"Returns - cure_types.nat_succ/1","doc":"- An expression representing Succ(Nat) : Nat","ref":"cure_types.html#nat_succ/1-returns"},{"type":"function","title":"Example - cure_types.nat_succ/1","doc":"```erlang\nOne = cure_types:nat_succ(cure_types:nat_zero()),\nTwo = cure_types:nat_succ(One),\n%% Results in Succ(Succ(Zero))\n```","ref":"cure_types.html#nat_succ/1-example"},{"type":"function","title":"cure_types.nat_to_int/1","doc":"Converts a Peano-encoded Nat to an Erlang integer.\n\nUnwraps the chain of Succ constructors to compute\nthe integer value.","ref":"cure_types.html#nat_to_int/1"},{"type":"function","title":"Arguments - cure_types.nat_to_int/1","doc":"- `NatExpr` - Peano-encoded natural number expression","ref":"cure_types.html#nat_to_int/1-arguments"},{"type":"function","title":"Returns - cure_types.nat_to_int/1","doc":"- `{ok, Integer}` - The integer value\n- `{error, invalid_nat}` - If not a valid Nat expression","ref":"cure_types.html#nat_to_int/1-returns"},{"type":"function","title":"Example - cure_types.nat_to_int/1","doc":"```erlang\n{ok, Three} = cure_types:nat_from_int(3),\n{ok, 3} = cure_types:nat_to_int(Three).\n```","ref":"cure_types.html#nat_to_int/1-example"},{"type":"function","title":"cure_types.nat_zero/0","doc":"Constructs the Zero value of the Nat type.\n\nIn Peano encoding, Zero is the base case for natural numbers,\nsimilar to Idris's Z constructor.","ref":"cure_types.html#nat_zero/0"},{"type":"function","title":"Returns - cure_types.nat_zero/0","doc":"- An expression representing Zero : Nat","ref":"cure_types.html#nat_zero/0-returns"},{"type":"function","title":"Example - cure_types.nat_zero/0","doc":"```erlang\nZero = cure_types:nat_zero(),\n%% Results in an identifier expression representing Zero\n```","ref":"cure_types.html#nat_zero/0-example"},{"type":"function","title":"cure_types.new_env/0","doc":"Creates a new empty type environment.\n\nThe type environment maintains variable bindings, constraints, and\nsupports hierarchical scoping through parent environments.","ref":"cure_types.html#new_env/0"},{"type":"function","title":"Returns - cure_types.new_env/0","doc":"- `type_env()` - A new empty type environment","ref":"cure_types.html#new_env/0-returns"},{"type":"function","title":"Example - cure_types.new_env/0","doc":"```erlang\nEnv = cure_types:new_env(),\nEnv2 = cure_types:extend_env(Env, x, {primitive_type, 'Int'}),\n{ok, Type} = cure_types:lookup_env(Env2, x).\n```","ref":"cure_types.html#new_env/0-example"},{"type":"function","title":"Features - cure_types.new_env/0","doc":"- **Hierarchical Scoping**: Supports nested environments\n- **Constraint Tracking**: Accumulates type constraints\n- **Efficient Lookup**: Fast variable resolution","ref":"cure_types.html#new_env/0-features"},{"type":"function","title":"cure_types.new_recursive_state/0","doc":"Creates a new recursive inference state for tracking recursive function calls.","ref":"cure_types.html#new_recursive_state/0"},{"type":"function","title":"Returns - cure_types.new_recursive_state/0","doc":"- `recursive_inference_state()` - New state with empty call stack","ref":"cure_types.html#new_recursive_state/0-returns"},{"type":"function","title":"Example - cure_types.new_recursive_state/0","doc":"```erlang\nState = cure_types:new_recursive_state(),\nUpdatedState = cure_types:push_recursive_call(factorial, ParamTypes, RetType, State).\n```","ref":"cure_types.html#new_recursive_state/0-example"},{"type":"function","title":"cure_types.new_type_var/0","doc":"Creates a new unique type variable without a specific name.\n\nThis is a convenience function that calls new_type_var/1 with undefined name.","ref":"cure_types.html#new_type_var/0"},{"type":"function","title":"Returns - cure_types.new_type_var/0","doc":"- `type_var()` - A new unique type variable","ref":"cure_types.html#new_type_var/0-returns"},{"type":"function","title":"Example - cure_types.new_type_var/0","doc":"```erlang\nTVar = cure_types:new_type_var(),\ntrue = cure_types:is_type_var(TVar).\n```","ref":"cure_types.html#new_type_var/0-example"},{"type":"function","title":"Note - cure_types.new_type_var/0","doc":"Uses a process dictionary counter to ensure uniqueness within a process.\nFor concurrent use, external synchronization may be required.","ref":"cure_types.html#new_type_var/0-note"},{"type":"function","title":"cure_types.new_type_var/1","doc":"Creates a new unique type variable with an optional name.","ref":"cure_types.html#new_type_var/1"},{"type":"function","title":"Arguments - cure_types.new_type_var/1","doc":"- `Name` - Optional name for the type variable (atom() | undefined)","ref":"cure_types.html#new_type_var/1-arguments"},{"type":"function","title":"Returns - cure_types.new_type_var/1","doc":"- `type_var()` - A new unique type variable with the given name","ref":"cure_types.html#new_type_var/1-returns"},{"type":"function","title":"Example - cure_types.new_type_var/1","doc":"```erlang\nTVar1 = cure_types:new_type_var(my_var),\nTVar2 = cure_types:new_type_var(undefined),\ntrue = TVar1#type_var.name =:= my_var.\n```","ref":"cure_types.html#new_type_var/1-example"},{"type":"function","title":"Note - cure_types.new_type_var/1","doc":"The name is primarily for debugging and error reporting. The unique ID\nensures type variable identity regardless of name.","ref":"cure_types.html#new_type_var/1-note"},{"type":"function","title":"cure_types.normalize_type/1","doc":"","ref":"cure_types.html#normalize_type/1"},{"type":"function","title":"cure_types.occurs_check/2","doc":"Performs an occurs check to prevent infinite types during unification.\n\nThe occurs check ensures that a type variable does not occur within\nthe type it would be unified with, preventing infinite type structures.","ref":"cure_types.html#occurs_check/2"},{"type":"function","title":"Arguments - cure_types.occurs_check/2","doc":"- `TypeVar` - Type variable to check for\n- `Type` - Type expression to check within","ref":"cure_types.html#occurs_check/2-arguments"},{"type":"function","title":"Returns - cure_types.occurs_check/2","doc":"- `true` - If the type variable occurs in the type (would create infinite type)\n- `false` - If the unification would be safe","ref":"cure_types.html#occurs_check/2-returns"},{"type":"function","title":"Example - cure_types.occurs_check/2","doc":"```erlang\nTVar = cure_types:new_type_var(),\nListType = {list_type, TVar},\ntrue = cure_types:occurs_check(TVar, ListType),  % Would create infinite list\nfalse = cure_types:occurs_check(TVar, {primitive_type, 'Int'}).\n```","ref":"cure_types.html#occurs_check/2-example"},{"type":"function","title":"Note - cure_types.occurs_check/2","doc":"This is essential for preventing infinite types like `T = List(T)` during unification.","ref":"cure_types.html#occurs_check/2-note"},{"type":"function","title":"cure_types.occurs_check_recursive/2","doc":"","ref":"cure_types.html#occurs_check_recursive/2"},{"type":"function","title":"cure_types.pop_recursive_call/1","doc":"Pops a recursive function call context from the call stack.","ref":"cure_types.html#pop_recursive_call/1"},{"type":"function","title":"Arguments - cure_types.pop_recursive_call/1","doc":"- `State` - Current recursive inference state","ref":"cure_types.html#pop_recursive_call/1-arguments"},{"type":"function","title":"Returns - cure_types.pop_recursive_call/1","doc":"- `{ok, Context, NewState}` - Popped context and updated state\n- `{error, empty_stack}` - If the call stack is empty","ref":"cure_types.html#pop_recursive_call/1-returns"},{"type":"function","title":"cure_types.push_recursive_call/4","doc":"Pushes a recursive function call context onto the call stack.\n\nThis tracks recursive calls to enable proper dependent type handling\nacross recursive boundaries.","ref":"cure_types.html#push_recursive_call/4"},{"type":"function","title":"Arguments - cure_types.push_recursive_call/4","doc":"- `FunctionName` - Name of the function being called recursively\n- `ParameterTypes` - Types of the parameters in this call\n- `ReturnType` - Expected return type of the function\n- `State` - Current recursive inference state","ref":"cure_types.html#push_recursive_call/4-arguments"},{"type":"function","title":"Returns - cure_types.push_recursive_call/4","doc":"- `{ok, NewState}` - Updated state with the call pushed\n- `{error, Reason}` - If maximum recursion depth exceeded","ref":"cure_types.html#push_recursive_call/4-returns"},{"type":"function","title":"Example - cure_types.push_recursive_call/4","doc":"```erlang\n{ok, NewState} = cure_types:push_recursive_call(\n    factorial, [NType], FactorialRetType, State\n).\n```","ref":"cure_types.html#push_recursive_call/4-example"},{"type":"function","title":"cure_types.safe_extract_param_value/1","doc":"","ref":"cure_types.html#safe_extract_param_value/1"},{"type":"function","title":"cure_types.solve_bounds_constraint/3","doc":"","ref":"cure_types.html#solve_bounds_constraint/3"},{"type":"function","title":"cure_types.solve_constraints/1","doc":"","ref":"cure_types.html#solve_constraints/1"},{"type":"function","title":"cure_types.solve_constraints/2","doc":"","ref":"cure_types.html#solve_constraints/2"},{"type":"function","title":"cure_types.solve_equivalence_constraint/3","doc":"","ref":"cure_types.html#solve_equivalence_constraint/3"},{"type":"function","title":"cure_types.solve_implication_constraint/3","doc":"","ref":"cure_types.html#solve_implication_constraint/3"},{"type":"function","title":"cure_types.solve_invariant_constraint/3","doc":"","ref":"cure_types.html#solve_invariant_constraint/3"},{"type":"function","title":"cure_types.solve_recursive_constraints_fixed_point/2","doc":"Solves recursive type constraints using fixed-point computation.\n\nThis function iteratively refines type constraints until they converge,\nhandling dependent types that may change across recursive calls.","ref":"cure_types.html#solve_recursive_constraints_fixed_point/2"},{"type":"function","title":"Arguments - cure_types.solve_recursive_constraints_fixed_point/2","doc":"- `Constraints` - List of type constraints to solve\n- `RecState` - Recursive inference state","ref":"cure_types.html#solve_recursive_constraints_fixed_point/2-arguments"},{"type":"function","title":"Returns - cure_types.solve_recursive_constraints_fixed_point/2","doc":"- `{ok, Substitution, Iterations}` - Converged solution\n- `{error, Reason}` - If convergence fails or max iterations exceeded","ref":"cure_types.html#solve_recursive_constraints_fixed_point/2-returns"},{"type":"function","title":"Algorithm - cure_types.solve_recursive_constraints_fixed_point/2","doc":"1. Apply current substitution to constraints\n2. Solve constraints to get new substitution\n3. Check for convergence by comparing substitutions\n4. Repeat until convergence or max iterations reached","ref":"cure_types.html#solve_recursive_constraints_fixed_point/2-algorithm"},{"type":"function","title":"cure_types.solve_type_family_equation/3","doc":"","ref":"cure_types.html#solve_type_family_equation/3"},{"type":"function","title":"cure_types.solve_variance_constraint/4","doc":"","ref":"cure_types.html#solve_variance_constraint/4"},{"type":"function","title":"cure_types.substitute/2","doc":"","ref":"cure_types.html#substitute/2"},{"type":"function","title":"cure_types.track_dependent_constraints_in_recursion/3","doc":"Tracks dependent constraints within recursive function calls.\n\nThis function maintains the relationships between dependent types\nacross recursive call boundaries, ensuring type safety.","ref":"cure_types.html#track_dependent_constraints_in_recursion/3"},{"type":"function","title":"Arguments - cure_types.track_dependent_constraints_in_recursion/3","doc":"- `Constraints` - Type constraints from the current call\n- `Context` - Recursive call context\n- `RecState` - Current recursive inference state","ref":"cure_types.html#track_dependent_constraints_in_recursion/3-arguments"},{"type":"function","title":"Returns - cure_types.track_dependent_constraints_in_recursion/3","doc":"- `{ok, TrackedConstraints, UpdatedState}` - Success with tracked constraints\n- `{error, Reason}` - If constraint tracking fails","ref":"cure_types.html#track_dependent_constraints_in_recursion/3-returns"},{"type":"function","title":"cure_types.type_to_string/1","doc":"","ref":"cure_types.html#type_to_string/1"},{"type":"function","title":"cure_types.unfold_recursive_type/1","doc":"","ref":"cure_types.html#unfold_recursive_type/1"},{"type":"function","title":"cure_types.unfold_recursive_type/2","doc":"","ref":"cure_types.html#unfold_recursive_type/2"},{"type":"function","title":"cure_types.unify/2","doc":"Unifies two types using the Robinson unification algorithm.\n\nThis is a convenience function that calls unify/3 with an empty substitution.","ref":"cure_types.html#unify/2"},{"type":"function","title":"Arguments - cure_types.unify/2","doc":"- `Type1` - First type expression to unify\n- `Type2` - Second type expression to unify","ref":"cure_types.html#unify/2-arguments"},{"type":"function","title":"Returns - cure_types.unify/2","doc":"- `{ok, Substitution}` - Successful unification with substitution map\n- `{error, Reason}` - Unification failure with detailed error","ref":"cure_types.html#unify/2-returns"},{"type":"function","title":"Example - cure_types.unify/2","doc":"```erlang\n{ok, Subst} = cure_types:unify(IntType, IntType),\n{ok, Subst2} = cure_types:unify(TVar, IntType),\n{error, _} = cure_types:unify(IntType, StringType).\n```","ref":"cure_types.html#unify/2-example"},{"type":"function","title":"Error Cases - cure_types.unify/2","doc":"- Type mismatch (e.g., Int vs String)\n- Occurs check failure (infinite types)\n- Constraint violations","ref":"cure_types.html#unify/2-error-cases"},{"type":"function","title":"cure_types.unify/3","doc":"Unifies two types with an existing substitution.\n\nApplies the existing substitution to both types before unification\nand composes the results.","ref":"cure_types.html#unify/3"},{"type":"function","title":"Arguments - cure_types.unify/3","doc":"- `Type1` - First type expression to unify\n- `Type2` - Second type expression to unify  \n- `Subst` - Existing substitution map to compose with","ref":"cure_types.html#unify/3-arguments"},{"type":"function","title":"Returns - cure_types.unify/3","doc":"- `{ok, NewSubstitution}` - Combined substitution after unification\n- `{error, Reason}` - Unification failure with detailed error","ref":"cure_types.html#unify/3-returns"},{"type":"function","title":"Example - cure_types.unify/3","doc":"```erlang\n{ok, Subst1} = cure_types:unify(TVar1, IntType),\n{ok, Subst2} = cure_types:unify(TVar2, StringType, Subst1),\n%% Subst2 now contains bindings for both TVar1 and TVar2\n```","ref":"cure_types.html#unify/3-example"},{"type":"function","title":"Substitution Composition - cure_types.unify/3","doc":"The function applies the input substitution to both types before\nunification and composes the result with the input substitution.","ref":"cure_types.html#unify/3-substitution-composition"},{"type":"function","title":"cure_types.unify_kinds/2","doc":"","ref":"cure_types.html#unify_kinds/2"},{"type":"function","title":"cure_types.unify_recursive_types/3","doc":"","ref":"cure_types.html#unify_recursive_types/3"},{"type":"function","title":"cure_types.unify_with_recursive_context/4","doc":"Performs unification with recursive context tracking.\n\nThis extends the standard unification algorithm to properly handle\ntype variables and dependent types across recursive call boundaries.","ref":"cure_types.html#unify_with_recursive_context/4"},{"type":"function","title":"Arguments - cure_types.unify_with_recursive_context/4","doc":"- `Types1` - First set of types to unify\n- `Types2` - Second set of types to unify  \n- `Context` - Recursive call context\n- `RecState` - Recursive inference state","ref":"cure_types.html#unify_with_recursive_context/4-arguments"},{"type":"function","title":"Returns - cure_types.unify_with_recursive_context/4","doc":"- `{ok, Constraints, UpdatedState}` - Successful unification with constraints\n- `{error, Reason}` - Unification failure","ref":"cure_types.html#unify_with_recursive_context/4-returns"},{"type":"module","title":"cure_utils","doc":null,"ref":"cure_utils.html"},{"type":"function","title":"cure_utils.debug/1","doc":null,"ref":"cure_utils.html#debug/1"},{"type":"function","title":"cure_utils.debug/2","doc":null,"ref":"cure_utils.html#debug/2"},{"type":"extras","title":"Cure Programming Language","doc":"# Cure Programming Language\n\nA strongly-typed, dependently-typed programming language for the BEAM virtual machine with built-in finite state machines, **complete import system**, and **comprehensive standard library**.\n\n🚀 **Last Updated: October 31, 2025**\n\n✅ **Working import system** with full module resolution  \n✅ **Standard library** with verified runtime execution (12 modules)  \n✅ **Dependent types** with compile-time verification  \n✅ **Complete compiler pipeline** from source to BEAM bytecode  \n✅ **FSM runtime system** with native BEAM integration  \n✅ **Type-directed optimizations** (25-60% performance improvement)  \n✅ **Comprehensive testing** infrastructure with high success rate  \n✅ **LSP Server** with real-time diagnostics and IDE integration  \n✅ **SMT Solver Integration** (API level - CLI integration planned)  \n✅ **Guard Compilation** with runtime validation and optimization  \n✅ **Record operations** with field access and update syntax","ref":"readme.html"},{"type":"extras","title":"Core Features - Cure Programming Language","doc":"### ✅ **Production-Ready Components**\n- **🚀 Complete Import System**: Full module resolution with `import Module [functions]` syntax\n- **📚 Working Standard Library**: 12 modules (core, io, show, list, fsm, result, pair, vector, string, math, system, rec) with essential functions\n- **🎯 Dependent Types**: Length-indexed vectors, refinement types with internal constraint representation\n- **🎆 Finite State Machines**: Arrow-based transition syntax (`State1 --> |event| State2`) compiling to BEAM behaviors\n- **⚡ Type-Directed Optimizations**: Monomorphization, function specialization, inlining (25-60% improvement)\n- **🏗️ BEAM Integration**: Native compilation to BEAM bytecode with OTP compatibility\n- **🔧 Pattern Matching**: Match expressions with guards and dependent type constraints\n- **📊 Complete Testing Infrastructure**: Comprehensive test suites covering all compiler stages\n- **🔌 LSP Server**: Language Server Protocol implementation with real-time diagnostics and hover info\n- **⚙️ Guard Compilation**: Dependent type guard validation with runtime optimization\n- **🧮 SMT Integration**: Z3/CVC5 solver integration at API level (CLI integration planned)\n- **📝 Record Operations**: Field access (`record.field`) and update syntax (`Record{base | field: value}`)\n\n### 🎯 **Language Capabilities**\n- **Control Flow**: Match expressions with pattern guards (note: `if-then-else` not implemented)\n- **String Operations**: Concatenation with `<>` operator, charlist literals with Unicode curly quotes\n- **List Operations**: Cons operator `|` for pattern matching `[h | t]`\n- **SMT-Based Constraint Solving**: Z3/CVC5 integration at API level for type constraints\n- **Error Handling**: Result/Option types from standard library\n- **CLI & Build System**: Complete development toolchain with wrapper scripts\n- **IDE Integration**: LSP server with real-time diagnostics and hover information\n- **Enhanced Error Messages**: Precise location tracking with source code snippets\n\n### 📋 **Planned Features** (See TODO.md for details)\n- **Pipe Operator**: `|>` for function chaining (parser support exists, needs verification)\n- **Type Classes/Traits**: Polymorphic interfaces with `typeclass` and `instance` keywords\n- **If-Then-Else**: Traditional conditional expressions\n- **String Interpolation**: Template-based string construction\n- **Advanced FSM Syntax**: Guards and actions in state transitions\n- **Effect System**: Computational effects tracking\n- **Macro System**: Compile-time code generation","ref":"readme.html#core-features"},{"type":"extras","title":"Project Structure - Cure Programming Language","doc":"```\ncure/\n├── src/\n│   ├── lexer/          # Tokenization and lexical analysis\n│   ├── parser/         # Syntax analysis, AST generation, and error reporting\n│   ├── types/          # Dependent type system implementation\n│   ├── codegen/        # BEAM bytecode generation and guard compilation\n│   ├── fsm/            # Finite state machine primitives\n│   ├── smt/            # SMT solver integration (Z3, CVC5)\n│   ├── lsp/            # Language Server Protocol implementation\n│   └── runtime/        # Runtime system integration\n├── lib/                # Standard library\n├── test/               # Comprehensive test suites\n├── examples/           # Example programs\n└── docs/              # Language specification and documentation\n```","ref":"readme.html#project-structure"},{"type":"extras","title":"Getting Started - Cure Programming Language","doc":"","ref":"readme.html#getting-started"},{"type":"extras","title":"Quick Start - Cure Programming Language","doc":"```bash\n# Build the compiler\nmake all\n\n# Try the FSM traffic light example\n./cure examples/06_fsm_traffic_light.cure\n\n# Run the compiled program\nerl -pa _build/ebin -noshell -eval \"'TrafficLightDemo':main(), init:stop().\"\n\n# Expected output:\n# Starting traffic light FSM...\n# Current state: red\n# [Traffic light transitions through states]\n\n# Show help\n./cure --help\n\n# Run test suite\nmake test\n```","ref":"readme.html#quick-start"},{"type":"extras","title":"Installation - Cure Programming Language","doc":"**Prerequisites**: Erlang/OTP 20+, Make, Unix-like environment\n\n```bash\n# Clone and build\ngit clone  \ncd cure\nmake all\n\n# Verify installation\n./cure --version\n\n# Run tests\nmake test\n```","ref":"readme.html#installation"},{"type":"extras","title":"Command Line Interface - Cure Programming Language","doc":"The Cure compiler includes a comprehensive CLI for compiling `.cure` files to BEAM bytecode.\n\nBasic usage:\n```bash\ncure [OPTIONS]  \n```\n\nKey options:\n- `-o, --output  `: Specify output file\n- `-d, --output-dir  `: Set output directory\n- `--verbose`: Enable detailed output\n- `--no-type-check`: Skip type checking\n\nSee [docs/CLI_USAGE.md](docs/CLI_USAGE.md) for complete documentation.","ref":"readme.html#command-line-interface"},{"type":"extras","title":"Language Examples - Cure Programming Language","doc":"","ref":"readme.html#language-examples"},{"type":"extras","title":"List Processing with Standard Library - Cure Programming Language","doc":"```cure\nmodule ListDemo do\n  export [demo/0]\n  \n  import Std.List [map, filter, fold]\n  import Std.IO [print]\n  \n  def demo(): Unit =\n    let numbers = [1, 2, 3, 4, 5]\n    \n    # Map operation\n    let doubled = map(numbers, fn(x) -> x * 2 end)\n    print(\"Doubled: \" <> show(doubled))\n    \n    # Filter operation  \n    let evens = filter(numbers, fn(x) -> x % 2 == 0 end)\n    print(\"Evens: \" <> show(evens))\n    \n    # Fold operation\n    let sum = fold(numbers, 0, fn(x, acc) -> acc + x end)\n    print(\"Sum: \" <> show(sum))\nend\n```","ref":"readme.html#list-processing-with-standard-library"},{"type":"extras","title":"Result Type Error Handling - Cure Programming Language","doc":"```cure\nmodule ResultDemo do\n  export [safe_divide/2]\n  \n  import Std.Result [ok, error, map, and_then]\n  \n  def safe_divide(a: Int, b: Int): Result(Int, String) =\n    match b do\n      0 -> error(\"Division by zero\")\n      _ -> ok(a / b)\n    end\n  \n  def compute(): Result(Int, String) =\n    and_then(safe_divide(10, 2), fn(x) ->\n      map(safe_divide(x, 0), fn(y) -> y * 2 end)\n    end)\nend\n```","ref":"readme.html#result-type-error-handling"},{"type":"extras","title":"Pattern Matching with Guards - Cure Programming Language","doc":"```cure\nmodule Guards do\n  export [classify/1]\n  \n  def classify(x: Int): Atom =\n    match x do\n      n when n < 0 -> :negative\n      0 -> :zero\n      n when n > 0 -> :positive\n    end\nend\n```","ref":"readme.html#pattern-matching-with-guards"},{"type":"extras","title":"Finite State Machine (Arrow-Based Syntax) - Cure Programming Language","doc":"```cure\nmodule TrafficLight do\n  export [create/0, next/1]\n  \n  import Std.FSM [fsm_new, fsm_send, fsm_stop]\n  import Std.Pair [pair]\n  \n  # Define FSM with arrow-based transitions\n  fsm TrafficLight do\n    initial: :red\n    \n    :red --> |:timer| :green\n    :green --> |:timer| :yellow  \n    :yellow --> |:timer| :red\n    \n    :green --> |:emergency| :red\n  end\n  \n  def create(): FSM(TrafficLight) =\n    fsm_new(TrafficLight, :red)\n  \n  def next(fsm: FSM(TrafficLight)): FSM(TrafficLight) =\n    fsm_send(fsm, pair(:timer, unit()))\nend\n```","ref":"readme.html#finite-state-machine-arrow-based-syntax"},{"type":"extras","title":"Record Operations - Cure Programming Language","doc":"```cure\nmodule Records do\n  export [demo/0]\n  \n  record Person do\n    name: String\n    age: Int\n    email: String\n  end\n  \n  def demo(): Unit =\n    let person = Person{name: \"Alice\", age: 30, email: \"alice@example.com\"}\n    \n    # Field access\n    let name = person.name\n    \n    # Record update (immutable)\n    let older = Person{person | age: 31}\n    \n    print(\"Name: \" <> name)\n    print(\"New age: \" <> show(older.age))\nend\n```","ref":"readme.html#record-operations"},{"type":"extras","title":"Available Examples - Cure Programming Language","doc":"See the `examples/` directory for working code:\n- `01_list_basics.cure` - List operations and standard library functions\n- `02_result_handling.cure` - Error handling with Result type\n- `03_option_type.cure` - Optional values with Option type\n- `04_pattern_guards.cure` - Pattern matching with guard clauses\n- `05_recursion.cure` - Recursive functions and tail call optimization\n- `06_fsm_traffic_light.cure` - Complete FSM implementation","ref":"readme.html#available-examples"},{"type":"extras","title":"Implementation Status - Cure Programming Language","doc":"### ✅ **Complete & Functional** (~85% Core Features)\n- **Lexical Analysis**: Complete tokenizer with position tracking and error recovery\n- **Parsing**: Full AST generation with recursive descent parsing and comprehensive error handling\n- **Type System**: Dependent type checking with refinement types (internal constraint representation)\n- **Type Optimization**: Monomorphization, specialization, inlining, dead code elimination (25-60% performance gain)\n- **FSM System**: Arrow-based FSM syntax compiling to BEAM behaviors with runtime operations\n- **Code Generation**: BEAM bytecode generation with debug information and OTP compatibility\n- **Standard Library**: 12 working modules (core, io, show, list, fsm, result, pair, vector, string, math, system, rec)\n- **Record Operations**: Field access and update syntax fully implemented\n- **Pattern Matching**: Match expressions with guards and dependent type constraints\n- **CLI & Build System**: Complete development toolchain with wrapper scripts\n- **Testing Infrastructure**: Comprehensive test suites covering lexer, parser, types, FSM, codegen\n- **LSP Server**: Language server with real-time diagnostics and hover information\n- **SMT Integration**: Z3/CVC5 solver integration at API level\n\n### 📋 **Missing Critical Features** (~15% - See TODO.md)\n- **Pipe Operator**: `|>` for function chaining (parser recognizes, needs implementation verification)\n- **Type Classes/Traits**: Polymorphic interfaces with `typeclass`/`instance` keywords not recognized\n- **If-Then-Else**: Traditional conditional expressions (currently only `match` expressions)\n- **String Interpolation**: Template-based string construction (AST exists, implementation unclear)\n- **Advanced FSM Syntax**: Guards and actions in state transitions\n- **CLI SMT Integration**: Command-line options for SMT solver (API works, CLI planned)\n\n### 🏗️ **Future Features** (Research/Experimental)\n- **Effect System**: Computational effects tracking and management  \n- **Macro System**: Compile-time code generation and metaprogramming\n- **Linear Types**: Resource management and memory safety\n- **Gradual Typing**: Mixed static/dynamic typing for Erlang interoperability\n- **Distributed FSMs**: Cross-node state machine coordination\n- **Package Manager**: Dependency management and distribution","ref":"readme.html#implementation-status"},{"type":"extras","title":"Performance Characteristics - Cure Programming Language","doc":"","ref":"readme.html#performance-characteristics"},{"type":"extras","title":"Compilation Performance - Cure Programming Language","doc":"- **Small files** (<100 lines): <1 second\n- **Medium projects** (1K-10K lines): 5-30 seconds\n- **Large projects** (100K+ lines): 30-300 seconds with incremental compilation","ref":"readme.html#compilation-performance"},{"type":"extras","title":"Runtime Performance - Cure Programming Language","doc":"- **Function calls**: ~10ns overhead (after type-directed optimization)\n- **FSM events**: ~1μs including message passing\n- **Type checking**: Zero runtime overhead (compile-time only)\n- **Memory usage**: Comparable to equivalent Erlang code\n- **Optimization impact**: 25-60% performance improvement over unoptimized code","ref":"readme.html#runtime-performance"},{"type":"extras","title":"Documentation - Cure Programming Language","doc":"Comprehensive documentation is available in the `docs/` directory:\n\n- **[LANGUAGE_SPEC.md](docs/LANGUAGE_SPEC.md)** - Complete language specification\n- **[TYPE_SYSTEM.md](docs/TYPE_SYSTEM.md)** - Dependent types and type system details\n- **[FSM_USAGE.md](docs/FSM_USAGE.md)** - Finite state machine guide\n- **[FEATURE_REFERENCE.md](docs/FEATURE_REFERENCE.md)** - Quick reference for all language features\n- **[STD_SUMMARY.md](docs/STD_SUMMARY.md)** - Standard library module documentation\n- **[TODO.md](docs/TODO.md)** - Missing features and future work\n- **[EDITOR_SETUP.md](docs/EDITOR_SETUP.md)** - IDE configuration for Cure development","ref":"readme.html#documentation"},{"type":"extras","title":"Community & Development - Cure Programming Language","doc":"Cure is a research and educational project demonstrating advanced programming language concepts in a practical, BEAM-compatible implementation.","ref":"readme.html#community-development"},{"type":"extras","title":"Contributing - Cure Programming Language","doc":"Contributions welcome! Priority areas (see TODO.md):\n- **Pipe operator implementation** - Complete `|>` integration\n- **Type classes/traits** - Polymorphic interface system\n- **If-then-else expressions** - Traditional control flow\n- **Standard library expansion** - More utility functions\n- **String interpolation** - Template-based strings\n- **Developer tooling** - Enhanced IDE support\n- **Documentation and examples** - More learning resources","ref":"readme.html#contributing"},{"type":"extras","title":"License - Cure Programming Language","doc":"To be determined based on project direction and community needs.","ref":"readme.html#license"}],"proglang":"erlang","content_type":"text/markdown","producer":{"name":"ex_doc","version":"0.35.1"}}