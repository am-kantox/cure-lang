<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Cure Language Features Reference - Cure Documentation</title>
    <meta name="description" content="Version: Current Implementation Status  
Last Updated: October 31, 2025">
    <link rel="icon" type="image/png" href="../media/logo-128x128.png">
    <link rel="stylesheet" href="../css/style.css">
</head>
<body>
    <!-- Header -->
    <header class="site-header">
        <div class="nav-container">
            <div class="logo-section">
                <img src="../media/logo-128x128.png" alt="Cure Logo" class="logo">
                <div>
                    <h1 class="site-title">Cure</h1>
                    <p class="site-tagline">Verification-First Programming</p>
                </div>
            </div>
            <nav class="main-nav">
                <ul>
                    <li><a href="../index.html">Home</a></li>
                    <li><a href="../docs.html">Documentation</a></li>
                    <li><a href="../api/index.html">API Reference</a></li>
                </ul>
            </nav>
        </div>
    </header>

    <!-- Main Content -->
    <div class="doc-page">
        <div class="doc-nav">
            <a href="../docs.html">‚Üê Back to Documentation</a>
        </div>
        
        <h1>Cure Language Features Reference</h1>

<strong>Version</strong>: Current Implementation Status  
<strong>Last Updated</strong>: October 31, 2025

<p>This document provides a comprehensive reference for all Cure language features, including current implementation status, syntax examples, and usage patterns.</p>

<h2>Table of Contents</h2>

<ol>
<li><a href="#core-language-syntax">Core Language Syntax</a></li>
<li><a href="#data-types-and-type-system">Data Types and Type System</a></li>
<li><a href="#finite-state-machines">Finite State Machines</a></li>
<li><a href="#type-classes-and-constraints">Type Classes and Constraints</a></li>
<li><a href="#advanced-features">Advanced Features</a></li>
<li><a href="#standard-library-integration">Standard Library Integration</a></li>
<li><a href="#cli-and-build-system">CLI and Build System</a></li>
<li><a href="#compilation-and-runtime">Compilation and Runtime</a></li>
<li><a href="#testing-infrastructure">Testing Infrastructure</a></li>
<li><a href="#performance-and-optimization">Performance and Optimization</a></li>
</ol>

<h2>Core Language Syntax</h2>

<h3>Module System</h3>
<pre><code>module ModuleName do
  import Std [abs/1, sqrt/1, Option, Result]
  import Std.Math [sin/1, cos/1]
  
  export [main/0, demo_function/1]
  
  # Module contents...
end
</code></pre>

<h3>Function Definitions</h3>
<pre><code># Simple function
def add(x: Int, y: Int): Int = x + y

# Function with complex body
def demo(): Unit =
  let result = calculate_something()
  println("Result: " <> show(result))
  0

# Helper function
def helper(x: Int): String = int_to_string(x)
</code></pre>

<h3>Lambda Expressions</h3>
<pre><code># Simple lambda
let double = fn(x) -> x * 2 end

# Lambda with pattern matching instead of if-then-else
let safe_div = fn(x, y) ->
  match y == 0 do
    true -> error("Division by zero")
    false -> ok(x / y)
  end
end

# Lambda with multiple parameters
let fold_sum = fold(numbers, 0, fn(x, acc) -> x + acc end)
</code></pre>

<h3>Pattern Matching</h3>
<pre><code>match expression do
  Ok(value) -> handle_success(value)
  Error(msg) -> handle_error(msg)
end

match list do
  [] -> "empty"
  [x] -> "single: " <> show(x)
  [x | rest] -> "head: " <> show(x) <> ", rest: " <> show(rest)
end

match option do
  Some(found) -> "Found: " <> show(found)
  None -> "Not found"
end
</code></pre>

<h3>Case Expressions</h3>

<p>Cure supports <code>case</code> expressions as an alternative to <code>match</code> (they are semantically identical):</p>

<pre><code># Case with 'of' keyword
case expression of
  Ok(value) -> handle_success(value)
  Error(msg) -> handle_error(msg)
end

# Functionally equivalent to match
match expression do
  Ok(value) -> handle_success(value)
  Error(msg) -> handle_error(msg)
end
</code></pre>

<strong>Note</strong>: Cure does not have <code>if-then-else</code> expressions. Use <code>match</code> or <code>case</code> for conditional logic.

<h3>Let Bindings</h3>
<pre><code># Simple let
let x = 42

# Let with complex expression
let result = calculate()
  |> map(fn(x) -> x * 2 end)
  |> filter(fn(x) -> x > 10 end)
</code></pre>

<h3>Pipe Operations</h3>
<pre><code>result = input
  |> transform1()
  |> transform2(argument)
  |> final_transform()
</code></pre>

<h2>Data Types and Type System</h2>

<h3>Primitive Types</h3>
<ul>
<li><code>Int</code>: 64-bit signed integers</li>
<li><code>Float</code>: 64-bit IEEE floating-point numbers  </li>
<li><code>String</code>: UTF-8 encoded text strings</li>
<li><code>Bool</code>: Boolean values (<code>true</code>, <code>false</code>)</li>
<li><code>Atom</code>: Symbolic constants (<code>:atom_name</code>)</li>
<li><code>Binary</code>: Byte sequences</li>
<li><code>Unit</code>: Unit type for functions with no return value</li>
<li><code>Nat</code>: Natural numbers (Int >= 0) - refinement type</li>
<li><code>Pos</code>: Positive integers (Int > 0) - refinement type</li>
<li><code>Pid</code>: BEAM process identifier</li>
</ul>

<h3>Composite Types</h3>
<pre><code>List(T)                    # Homogeneous lists
List(T, n)                 # Length-indexed lists (dependent type)
Tuple(T1, T2, ...)         # Fixed-size tuples
Result(T, E)               # Error handling without exceptions
Option(T)                  # Nullable values
</code></pre>

<h3>Constructor Types</h3>
<pre><code>Ok(value)                  # Success result
Error(message)             # Error result
Some(value)                # Present optional value
None                       # Absent optional value
</code></pre>

<h3>Dependent Types</h3>
<pre><code># Length-indexed types
Vector(T, n: Nat)          # Fixed-length vector
List(T, n: Nat)            # List with compile-time known length
Matrix(rows: Nat, cols: Nat, T)  # 2D matrix with dimensions

# Constraint-based types
{x: Int | x > 0}           # Positive integers
{x: Float | x >= 0.0}      # Non-negative floats
{xs: List(T) | length(xs) > 0}  # Non-empty lists

# Function-dependent types
def replicate(n: Nat, x: T): List(T, n)  # Return type depends on argument
def safe_head(xs: List(T, n)): T when n > 0  # Precondition constraint
</code></pre>

<h2>Operators</h2>

<h3>Binary Operators</h3>
<ul>
<li>Arithmetic: <code>+</code>, <code>-</code>, <code>*</code>, <code>/</code>, <code>%</code></li>
<li>Comparison: <code>==</code>, <code>!=</code>, <code><</code>, <code>></code>, <code><=</code>, <code>>=</code></li>
<li>String: <code><></code> (concatenation)</li>
<li>List: <code>|</code> (cons operator, used in <code>[h | t]</code> syntax)</li>
<li>Pipe: <code>|></code> (function composition)</li>
</ul>

<h3>Unary Operators</h3>
<ul>
<li>Arithmetic: <code>+x</code>, <code>-x</code></li>
<li>Logical: <code>not(expr)</code></li>
</ul>

<h2>Literals</h2>

<h3>Numbers</h3>
<pre><code>42          # Integer
3.14        # Float
-5          # Negative integer
</code></pre>

<h3>Strings</h3>
<pre><code>"Hello, World!"       # Simple string
"Line 1\nLine 2"      # String with escape sequences
"Quote: \"text\""     # String with escaped quotes
</code></pre>

<h3>Lists</h3>
<pre><code>[]                    # Empty list
[1, 2, 3]            # List of integers
["a", "b", "c"]      # List of strings
</code></pre>

<h3>Tuples</h3>

<p>Tuples use curly brace <code>{}</code> syntax:</p>

<pre><code>{}                    # Empty tuple (Unit)
{42}                  # Single element tuple
{1, "hello", true}    # Multi-element tuple
{:ok, "success"}      # Tagged tuple (atom + value)
{:error, "failed"}    # Error tuple (atom + value)
</code></pre>

<strong>Note</strong>: Tuple pattern matching is fully supported:
<pre><code>match point do
  {x, y} when x > 0.0 and y > 0.0 -> "First quadrant"
  {x, y} when x == 0.0 and y == 0.0 -> "Origin"
  _ -> "Other quadrant"
end
</code></pre>

<h3>Atoms</h3>
<pre><code>:atom_name
:increment
:ok
</code></pre>

<h2>Finite State Machines</h2>

<p>Cure provides first-class support for finite state machines with compile-time verification, state-dependent data, and integration with the BEAM actor model.</p>

<h3>Basic FSM Definition</h3>

<p>Cure FSMs use a record-based payload system with arrow transition syntax:</p>

<pre><code># Define a payload record to track FSM data
record TrafficPayload do
  cycles_completed: Int
  timer_events: Int
  emergency_stops: Int
end

# FSM with initial payload values
fsm TrafficPayload{cycles_completed: 0, timer_events: 0, emergency_stops: 0} do
  Red --> |timer| Green
  Red --> |emergency| Red      # Self-transition
  Green --> |timer| Yellow
  Green --> |emergency| Red
  Yellow --> |timer| Red
  Yellow --> |emergency| Red
end
</code></pre>

<strong>Key Points</strong>:
<ul>
<li>First state in transitions is the initial state (Red in this example)</li>
<li>Transitions use <code>--></code> arrow with <code>|event|</code> syntax</li>
<li>Must define a payload record even if fields are unused</li>
</ul>

<h3>FSM Runtime Operations</h3>

<p>FSMs compile to BEAM <code>gen_statem</code> processes:</p>

<pre><code>import Std.Fsm [fsm_spawn/2, fsm_cast/2, fsm_advertise/2, fsm_state/1]
import Std.Pair [pair/2]

# Spawn an FSM instance with initial data
let initial_data = TrafficPayload{cycles_completed: 0, timer_events: 0, emergency_stops: 0}
let fsm_pid = fsm_spawn(:TrafficPayload, initial_data)

# Give the FSM a name for easy reference
let adv_result = fsm_advertise(fsm_pid, :traffic_light)

# Send events to the FSM
let empty_list = []
let event = pair(:timer, empty_list)
let cast_result = fsm_cast(:traffic_light, event)

# Query current state
let current_state = fsm_state(:traffic_light)  # Returns current state atom
</code></pre>

<h3>FSM Implementation Notes</h3>

<p>Cure FSMs compile to Erlang <code>gen_statem</code> behaviors with the following features:</p>

<strong>Compile-Time Verification</strong>:
<ul>
<li>State machine structure validated at compile time</li>
<li>Transition completeness checked</li>
<li>Event type checking</li>
</ul>

<strong>Runtime Integration</strong>:
<ul>
<li>Native BEAM process integration</li>
<li>Mailbox-based event handling</li>
<li>OTP supervision tree compatible</li>
<li>Hot code reloading support</li>
</ul>

<strong>Current Implementation</strong>:
<ul>
<li>Simple arrow-based transition syntax (<code>State1 --> |event| State2</code>)</li>
<li>Record-based payload data tracking</li>
<li>Event casting with atom-based event names</li>
<li>State querying via FSM references</li>
</ul>


<h2>Records and Dependent Types</h2>

<h3>Record Definitions</h3>
<pre><code>record Person do
  name: String
  age: Nat
  email: String
end

# Creating records
let person = Person{name: "Alice", age: 30, email: "alice@example.com"}

# Pattern matching on records
match person do
  Person{name: name, age: age} when age >= 18 ->
    "Hello, adult " <> name <> "!"
  Person{name: name} ->
    "Hello, young " <> name <> "!"
end
</code></pre>

<h3>Dependent Types</h3>
<pre><code># Length-indexed types
Vector(T, n: Nat)      # Fixed-length vector
List(T, n: Nat)        # List with known length
Range(min: Int, max: Int)  # Integer range type

# Matrix with dimension checking
record Matrix(rows: Nat, cols: Nat, T) do
  data: Vector(Vector(T, cols), rows)
end

# Refinement types
type NonEmptyList(T) = List(T, n) when n > 0

def head(list: NonEmptyList(T)): T =
  match list do
    [x|_] -> x
    # No need for empty case - type system guarantees non-empty
  end
</code></pre>

<h2>Advanced Features</h2>

<h3>Function Imports with Arity</h3>
<pre><code>import ModuleName [
  function1/1,    # Function with 1 parameter
  function2/2,    # Function with 2 parameters
  TypeName,       # Type import
  constructor     # Constructor import
]
</code></pre>

<h3>Complex Nested Expressions</h3>
<pre><code># Nested lambdas in higher-order functions
processed = data
  |> filter(fn(item) -> not(is_empty(item)) end)
  |> map(fn(item) -> 
      process_item(item)
        |> validate()
        |> transform()
     end)
  |> collect_results()
</code></pre>

<h3>Match vs Case</h3>

<p>Both <code>match</code> and <code>case</code> are supported and functionally equivalent:</p>

<pre><code># Case expression with 'of' keyword (alternative to match)
case expression of
  Ok(value) -> handle_success(value)
  Error(msg) -> handle_error(msg)
end

case list of
  [] -> "empty"
  [x] -> "single: " <> show(x)
  [x | rest] -> "head: " <> show(x)
end
</code></pre>

<h3>Pattern Matching with Guards</h3>
<pre><code>match value do
  x when x > 0 -> "positive"
  x when x < 0 -> "negative"
  _ -> "zero"
end

# Guards in case expressions
case number do
  n when n > 100 -> "large"
  n when n > 10 -> "medium" 
  _ -> "small"
end
</code></pre>

<h2>Error Handling Patterns</h2>

<h3>Result Types</h3>
<pre><code>def safe_operation(input: Int): Result(Int, String) =
  match input < 0 do
    true -> error("Negative input not allowed")
    false -> ok(input * 2)
  end
</code></pre>

<h3>Option Types</h3>
<pre><code>def find_item(list: List(String), target: String): Option(String) =
  match search(list, target) do
    found when found != "" -> Some(found)
    _ -> None
  end
</code></pre>

<h2>Best Practices</h2>

<h3>Function Composition</h3>
<p>Use pipe operators for readable data transformations:</p>
<pre><code>result = input
  |> validate_input()
  |> process_data()
  |> format_output()
</code></pre>

<h3>Error Handling</h3>
<p>Use Result types for operations that can fail:</p>
<pre><code>def divide(x: Float, y: Float): Result(Float, String) =
  match y == 0.0 do
    true -> error("Division by zero")
    false -> ok(x / y)
  end
</code></pre>

<h3>Pattern Matching</h3>
<p>Prefer pattern matching for control flow:</p>
<pre><code># Good - using pattern matching
match result do
  Ok(value) -> use_value(value)
  Error(msg) -> handle_error(msg)
end

# Also good - using case
case result of
  Ok(value) -> use_value(value)
  Error(msg) -> handle_error(msg)
end
</code></pre>

<h2>Type Classes and Constraints</h2>

<p>Cure supports type classes for ad-hoc polymorphism and constraint-based programming.</p>

<h3>Type Class Definition</h3>
<pre><code>typeclass Ord(T) where
  def compare(x: T, y: T): Ordering
  def (<)(x: T, y: T): Bool = compare(x, y) == LT
  def (<=)(x: T, y: T): Bool = compare(x, y) != GT
end

typeclass Show(T) where
  def show(x: T): String
end

typeclass Functor(F) where
  def map(f: A -> B, fa: F(A)): F(B)
end
</code></pre>

<h3>Type Class Instances</h3>
<pre><code># Manual instances
instance Ord(Int) where
  def compare(x, y) =
    if x < y then LT
    else if x > y then GT
    else EQ
    end
end

# Automatic derivation
derive Ord for List(T) when Ord(T)
derive Show for Option(T) when Show(T)
derive Functor for List
derive Functor for Option
</code></pre>

<h3>Constraint-Based Programming</h3>
<pre><code># Generic sorting with constraints
def sort(xs: List(T)): List(T) where Ord(T) =
  quicksort_impl(xs)

# Pretty printing with constraints  
def debug_print(x: T): Unit where Show(T) =
  print(show(x))

# Functor mapping
def transform(f: A -> B, container: F(A)): F(B) where Functor(F) =
  map(f, container)
</code></pre>

<h2>Advanced Features</h2>

<h3>Pi Types (Dependent Functions)</h3>
<pre><code># Function types that depend on their arguments
def replicate(n: Nat, x: T): List(T, n) = 
  if n == 0 then [] else x :: replicate(n-1, x)
</code></pre>

<h3>Sigma Types (Dependent Pairs)</h3>
<pre><code># Pairs where the second type depends on the first value
{x: Nat, Vector(Int, x)}  # Pair of number and vector of that length
</code></pre>

<h3>Refinement Types</h3>
<pre><code># Types with predicates
{x: Int | x > 0}          # Positive integers
{x: List(T) | length(x) > 0}  # Non-empty lists
</code></pre>

<h3>Indexed Types</h3>
<pre><code># Types parameterized by values
Vector(T, n: Nat)         # Vector of type T with length n
Matrix(rows: Nat, cols: Nat, T)  # Matrix with compile-time dimensions
</code></pre>

<h2>CLI and Build System</h2>

<p>Cure provides a sophisticated command-line interface with wrapper script automation and intelligent build management.</p>

<h3>Wrapper Script Commands</h3>
<pre><code># Special wrapper script commands
cure build      # Execute 'make all' to build compiler
cure test       # Execute 'make test' to run test suite
cure clean      # Execute 'make clean' to clean build artifacts
cure shell      # Start Erlang development shell with modules loaded
</code></pre>

<h3>File Compilation</h3>
<pre><code># Basic compilation
cure input.cure                    # Compile with defaults
cure input.cure -o output.beam     # Specify output file
cure input.cure --verbose          # Verbose compilation
cure input.cure --no-optimize      # Disable optimizations
</code></pre>

<h3>Automatic Standard Library Management</h3>
<ul>
<li><strong>Import Detection</strong>: Automatically detects if source files need stdlib imports</li>
<li><strong>Smart Imports</strong>: Adds common stdlib imports to files without explicit module/import declarations</li>
<li><strong>Conflict Avoidance</strong>: Skips automatic imports for files with explicit module definitions or imports</li>
<li><strong>Partial Failure Handling</strong>: Reports detailed errors when stdlib compilation partially fails</li>
</ul>

<h3>Module Detection and Validation</h3>
<ul>
<li><strong>Required Modules Check</strong>: Validates presence of all required BEAM compiler modules</li>
<li><strong>Missing Module Reporting</strong>: Provides detailed error messages for missing components</li>
<li><strong>Build Automation</strong>: Automatically triggers 'make all' when modules are missing</li>
<li><strong>Error Recovery</strong>: Graceful error handling with instructions for resolution</li>
</ul>

<h3>Standard Library Compilation</h3>
<ul>
<li><strong>Automatic Compilation</strong>: Compiles stdlib modules as needed during user file compilation</li>
<li><strong>Dependency Resolution</strong>: Handles stdlib dependencies and compilation order</li>
<li><strong>Partial Failure Recovery</strong>: Attempts individual file compilation when batch compilation fails</li>
<li><strong>Path Conversion</strong>: Converts BEAM paths to source paths for error reporting</li>
</ul>

<h2>Standard Library Integration</h2>

<p>Cure includes a comprehensive standard library implemented in Cure itself with Erlang runtime support.</p>

<h3>Core Standard Library Modules</h3>
<pre><code># Import common types and functions
import Std [Result, Option, ok, error, some, none]
import Std [map/2, filter/2, fold_left/3, fold_right/3]

# Mathematical operations
import Std.Math [abs/1, sqrt/1, sin/1, cos/1, pi, e]

# String operations
import Std.String [length/1, concat/2, split/2, trim/1]

# FSM utilities
import Std.FSM [create/2, send_event/2, get_state/1]
</code></pre>

<h3>Result and Option Types</h3>
<pre><code># Chainable error handling
result = safe_divide(x, y)
  |> map_ok(fn(val) -> val * 2 end)
  |> and_then(fn(doubled) -> safe_sqrt(doubled) end)

match result do
  Ok(final_value) -> println("Success: " <> show(final_value))
  Error(msg) -> println("Error: " <> msg)
end

# Optional value handling
opt_value = find_in_list(items, predicate)
  |> map(fn(item) -> process(item) end)
  |> filter(fn(processed) -> is_valid(processed) end)
</code></pre>

<h2>Testing Infrastructure</h2>

<p>Cure includes comprehensive testing infrastructure covering all aspects of the compiler and standard library.</p>

<h3>Comprehensive Test Suites</h3>
<pre><code># Master test runner for all new CLI and stdlib tests
erl -pa _build/ebin -pa test -s run_all_new_tests run -s init stop

# Individual comprehensive test suites
erl -pa _build/ebin -pa test -s cli_wrapper_comprehensive_test run -s init stop
erl -pa _build/ebin -pa test -s cure_wrapper_script_test run -s init stop
</code></pre>

<h3>CLI and Wrapper Testing</h3>
<ul>
<li><strong>Build Command Testing</strong>: Verifies wrapper script correctly executes 'make all' for build command</li>
<li><strong>Missing Module Detection</strong>: Tests wrapper script detection and reporting of missing BEAM modules</li>
<li><strong>Error Message Validation</strong>: Ensures proper error reporting with helpful instructions</li>
<li><strong>Script Logic Verification</strong>: Tests all wrapper script conditional logic and edge cases</li>
</ul>

<h3>Standard Library Testing</h3>
<ul>
<li><strong>Automatic Import Testing</strong>: Validates CLI automatic stdlib import addition and detection</li>
<li><strong>Import Conflict Detection</strong>: Tests detection of explicit modules/imports to prevent conflicts</li>
<li><strong>Compilation Failure Testing</strong>: Tests stdlib compilation partial failure reporting</li>
<li><strong>Performance Testing</strong>: Benchmarks Std.List.length function with large datasets (up to 50k elements)</li>
</ul>

<h3>Test Coverage Areas</h3>
<ul>
<li><strong>Lexical Analysis</strong>: Token recognition and error handling</li>
<li><strong>Parsing</strong>: AST construction and syntax validation</li>
<li><strong>Type System</strong>: Inference, checking, and unification</li>
<li><strong>Code Generation</strong>: BEAM instruction generation</li>
<li><strong>FSM Runtime</strong>: State transitions and event handling</li>
<li><strong>CLI Functionality</strong>: Complete wrapper script and CLI module coverage</li>
<li><strong>Error Handling</strong>: Comprehensive error message formatting and reporting</li>
</ul>

<h3>Testing Features</h3>
<ul>
<li><strong>EUnit Integration</strong>: All tests use EUnit assertions for reliable verification</li>
<li><strong>Performance Benchmarks</strong>: Tests include timing validation for large datasets</li>
<li><strong>Edge Case Coverage</strong>: Comprehensive testing of boundary conditions and error scenarios</li>
<li><strong>Master Test Runner</strong>: Orchestrated execution of all test suites with detailed reporting</li>
<li><strong>Component Isolation</strong>: Both comprehensive and focused component-specific test suites</li>
</ul>

<h2>Compilation and Runtime</h2>

<h3>Current Compilation Pipeline</h3>
<ol>
<li><strong>Source (.cure)</strong> ‚Üí <strong>Tokens</strong> (<code>cure_lexer.erl</code>)</li>
<li><strong>Tokens</strong> ‚Üí <strong>AST</strong> (<code>cure_parser.erl</code>)</li>
<li><strong>AST</strong> ‚Üí <strong>Typed AST</strong> (<code>cure_typechecker.erl</code>)</li>
<li><strong>Type Optimization</strong> (<code>cure<em>type</em>optimizer.erl</code>)</li>
</ol>
<ul>
<li>Monomorphization</li>
<li>Function specialization  </li>
<li>Inlining analysis</li>
<li>Dead code elimination</li>
</ul>
<ol>
<li><strong>BEAM Bytecode</strong> (<code>cure<em>codegen.erl</code>, <code>cure</em>beam_compiler.erl</code>)</li>
</ol>

<h3>BEAM Integration Features</h3>
<ul>
<li><strong>Native Processes</strong>: FSMs compile to BEAM processes with supervision</li>
<li><strong>gen<em>statem Integration</strong>: FSMs use OTP gen</em>statem behavior</li>
<li><strong>Pattern Matching</strong>: Leverages BEAM's efficient pattern matching</li>
<li><strong>Tail Call Optimization</strong>: Preserves BEAM's tail recursion optimization</li>
<li><strong>Hot Code Loading</strong>: Supports BEAM's live code upgrade</li>
<li><strong>Distributed Computing</strong>: Transparent distribution across BEAM nodes</li>
<li><strong>OTP Compatibility</strong>: Seamless integration with Erlang/Elixir ecosystems</li>
</ul>

<h2>Performance and Optimization</h2>

<h3>Type-Directed Optimizations</h3>
<p>Cure's type system enables aggressive optimizations:</p>

<pre><code># Before optimization (polymorphic)
def map(f: T -> U, xs: List(T)): List(U) = ...

# After monomorphization (specialized for Int -> String)
def map_Int_String(f: Int -> String, xs: List(Int)): List(String) = 
  # Optimized implementation for specific types
  specialized_map_impl(f, xs)
</code></pre>

<h3>Performance Characteristics</h3>
<ul>
<li><strong>Function calls</strong>: ~10ns overhead (optimized)</li>
<li><strong>FSM events</strong>: ~1Œºs including message passing</li>
<li><strong>Type checking</strong>: Zero runtime overhead (compile-time only)</li>
<li><strong>Pattern matching</strong>: BEAM-native performance</li>
<li><strong>Memory usage</strong>: Comparable to equivalent Erlang code</li>
<li><strong>Optimizations</strong>: 25-60% performance improvement over unoptimized code</li>
</ul>

<h3>Compiler Performance</h3>
<ul>
<li>Small files (<100 lines): <1 second compilation</li>
<li>Medium projects (1K-10K lines): 5-30 seconds</li>
<li>Large projects (100K+ lines): 30-300 seconds with incremental compilation</li>
<li>Type checking scales O(n¬≤) due to dependent types</li>
<li>SMT constraint solving typically sub-second for realistic programs</li>
</ul>

<p>---</p>

<h2>Implementation Status</h2>

<h3>‚úÖ <strong>Fully Implemented</strong></h3>
<ul>
<li>Core syntax and semantics</li>
<li>Dependent type system with SMT solving</li>
<li>FSM compilation and runtime</li>
<li>Type-directed optimizations</li>
<li>BEAM code generation</li>
<li>Standard library with runtime support</li>
<li>Advanced CLI with wrapper script automation</li>
<li>Automatic standard library import management</li>
<li>Comprehensive test suite with performance benchmarks</li>
<li>CLI wrapper functionality with missing module detection</li>
<li>Partial compilation failure handling and recovery</li>
</ul>

<h3>üöß <strong>Advanced Features</strong> </h3>
<ul>
<li>Complex type class hierarchies</li>
<li>Advanced dependent type features (proof obligations)</li>
<li>Linear types for resource management</li>
<li>Distributed FSM coordination</li>
</ul>

<p>This reference covers all currently implemented language features and provides insight into Cure's unique combination of dependent types, native FSM support, and BEAM integration.</p>

    </div>

    <!-- Pill Decoration -->
    <img src="../media/pill-512x512.png" alt="" class="pill-decoration">

    <!-- Footer -->
    <footer class="site-footer">
        <div class="footer-content">
            <div class="footer-section">
                <h4>Documentation</h4>
                <ul>
                    <li><a href="../docs.html">Getting Started</a></li>
                    <li><a href="language-spec.html">Language Specification</a></li>
                    <li><a href="type-system.html">Type System</a></li>
                    <li><a href="fsm-usage.html">FSM Guide</a></li>
                </ul>
            </div>

            <div class="footer-section">
                <h4>Reference</h4>
                <ul>
                    <li><a href="../api/index.html">API Reference</a></li>
                    <li><a href="std-summary.html">Standard Library</a></li>
                    <li><a href="feature-reference.html">Feature Reference</a></li>
                    <li><a href="cli-usage.html">CLI Usage</a></li>
                </ul>
            </div>

            <div class="footer-section">
                <h4>Resources</h4>
                <ul>
                    <li><a href="editor-setup.html">Editor Setup</a></li>
                    <li><a href="project-overview.html">Project Overview</a></li>
                    <li><a href="cure-ultimate-description.html">Ultimate Guide</a></li>
                </ul>
            </div>
        </div>

        <div class="footer-bottom">
            <p>&copy; 2025 Cure Programming Language. Verification-first programming for the BEAM.</p>
        </div>
    </footer>
</body>
</html>
