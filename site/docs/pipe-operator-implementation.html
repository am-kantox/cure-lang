<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Pipe Operator Implementation Summary - Cure Documentation</title>
    <meta name="description" content="This document summarizes the comprehensive analysis and enhancement of the pipe operator (|>) implementation in the Cure programming language.">
    <link rel="icon" type="image/png" href="../media/logo-128x128.png">
    <link rel="stylesheet" href="../css/style.css">
</head>
<body>
    <!-- Header -->
    <header class="site-header">
        <div class="nav-container">
            <div class="logo-section">
                <img src="../media/logo-128x128.png" alt="Cure Logo" class="logo">
                <div>
                    <h1 class="site-title">Cure</h1>
                    <p class="site-tagline">Verification-First Programming</p>
                </div>
            </div>
            <nav class="main-nav">
                <ul>
                    <li><a href="../index.html">Home</a></li>
                    <li><a href="../docs.html">Documentation</a></li>
                    <li><a href="../api/index.html">API Reference</a></li>
                </ul>
            </nav>
        </div>
    </header>

    <!-- Main Content -->
    <div class="doc-page">
        <div class="doc-nav">
            <a href="../docs.html">← Back to Documentation</a>
        </div>
        
        <h1>Pipe Operator Implementation Summary</h1>

<p>This document summarizes the comprehensive analysis and enhancement of the pipe operator (<code>|></code>) implementation in the Cure programming language.</p>

<h2>Status: ✅ Complete</h2>

<p>The pipe operator is <strong>fully implemented</strong> with monadic semantics for automatic error handling and Result type management.</p>

<h2>Architecture Overview</h2>

<pre><code>Cure Source Code
<p>       ↓</p>
<p>  [Lexer]  ← Tokenizes |> operator</p>
<p>       ↓</p>
<p>  [Parser] ← Parses with precedence 1 (lowest), left associativity</p>
<p>       ↓</p>
<p>[Type Checker] ← Verifies type correctness and Result type propagation</p>
<p>       ↓</p>
<p>  [Codegen] ← Generates monadic<em>pipe</em>call instructions</p>
<p>       ↓</p>
<p>[BEAM Compiler] ← Translates to cure_std:pipe/2 calls</p>
<p>       ↓</p>
<p>  [Runtime] ← Executes monadic pipe semantics</p>
</code></pre>

<h2>Implementation Components</h2>

<h3>1. Lexer (<code>cure_lexer.erl</code>)</h3>

<strong>Status</strong>: ✅ Complete

<ul>
<li>Token: <code>|></code> mapped to atom <code>'|>'</code></li>
<li>Location: Line 271 in operators map</li>
<li>Multi-character operator recognition working correctly</li>
</ul>

<h3>2. Parser (<code>cure_parser.erl</code>)</h3>

<strong>Status</strong>: ✅ Complete

<ul>
<li>Precedence: 1 (lowest precedence in the language)</li>
<li>Associativity: Left</li>
<li>Location: Lines 2859-2869 (operator precedence table)</li>
<li>Parsed as binary operator expression in AST</li>
</ul>

<h3>3. Type Checker (<code>cure_typechecker.erl</code>)</h3>

<strong>Status</strong>: ✅ Verified

<ul>
<li>Binary operators handled in expression type inference</li>
<li>Result types properly propagated through pipe chains</li>
<li>Type constraints verified at compile time</li>
</ul>

<h3>4. Code Generator (<code>cure_codegen.erl</code>)</h3>

<strong>Status</strong>: ✅ Complete

<ul>
<li>Location: Lines 1505-1548</li>
<li>Generates <code>monadic<em>pipe</em>call</code> instruction</li>
<li>Two modes:</li>
<li>Simple function pipe: <code>x |> f</code></li>
<li>Function call pipe: <code>x |> f(y, z)</code></li>
<li>Stack ordering: Function, Value, Args</li>
</ul>

<h3>5. BEAM Compiler (<code>cure<em>beam</em>compiler.erl</code>)</h3>

<strong>Status</strong>: ✅ Complete

<ul>
<li>Location: Lines 602-637</li>
<li>Translates <code>monadic<em>pipe</em>call</code> to Erlang forms</li>
<li>Generates calls to <code>cure_std:pipe/2</code></li>
<li>Wraps piped value with <code>ok()</code> if not already Result</li>
<li>Creates lambda for function application</li>
</ul>

<h3>6. Runtime (<code>cure_std.erl</code>)</h3>

<strong>Status</strong>: ✅ Complete

<ul>
<li>Location: Lines 221-245</li>
<li>Function: <code>pipe/2</code></li>
<li>Implements three semantic rules:</li>
</ul>
<ol>
<li><strong>Error Propagation</strong>: <code>Error(x) |> f = Error(x)</code></li>
<li><strong>Ok Unwrapping</strong>: <code>Ok(x) |> f = f(x)</code> (result wrapped)</li>
<li><strong>Value Passing</strong>: <code>x |> f = f(x)</code> (result wrapped)</li>
</ol>
<ul>
<li>Exception handling: Catches errors and wraps as <code>Error()</code></li>
</ul>

<h2>Semantic Rules</h2>

<h3>Rule 1: Error Propagation</h3>

<pre><code>Error("reason") |> function
<h1>=> Error("reason")  # function is NOT called</h1>
</code></pre>

<p>Errors short-circuit the pipeline without calling subsequent functions.</p>

<h3>Rule 2: Ok Unwrapping</h3>

<pre><code>Ok(5) |> double
<h1>=> Ok(10)  # 5 is unwrapped, passed to double, result wrapped</h1>
</code></pre>

<code>Ok</code> values are unwrapped before function application, result is wrapped unless already monadic.

<h3>Rule 3: Value Passing</h3>

<pre><code>5 |> double
<h1>=> Ok(10)  # 5 is passed directly, result wrapped</h1>
</code></pre>

<p>Plain values are passed to functions and results are wrapped in <code>Ok()</code>.</p>

<h3>Exception Handling</h3>

<pre><code>Ok(0) |> (fun(x) -> 1 / x)
<h1>=> Error({pipe<em>runtime</em>error, error, badarith})</h1>
</code></pre>

<p>Runtime exceptions are caught and converted to <code>Error()</code> values.</p>

<h2>Enhancements Made</h2>

<h3>1. Comprehensive Test Suite</h3>

<strong>File</strong>: <code>test/pipe<em>operator</em>test.erl</code>

<p>Test coverage includes:</p>
<ul>
<li>Lexer tokenization tests (3 tests)</li>
<li>Parser AST generation tests (4 tests)</li>
<li>Runtime semantics tests (5 tests)</li>
<li>Code generation tests (2 tests)</li>
<li>Integration tests (2 tests)</li>
</ul>

<strong>Total</strong>: 16 comprehensive tests covering all aspects of the implementation.

<h3>2. Example Code</h3>

<strong>File</strong>: <code>examples/pipe_demo.cure</code>

<p>Demonstrates:</p>
<ul>
<li>Basic piping</li>
<li>Error handling</li>
<li>Pipe chains</li>
<li>Piping with arguments</li>
<li>Real-world data transformation</li>
<li>Error recovery patterns</li>
<li>Combining with other operators</li>
</ul>

<h3>3. Documentation</h3>

<strong>File</strong>: <code>docs/pipe_operator.md</code>

<p>Comprehensive documentation including:</p>
<ul>
<li>Overview and key features</li>
<li>Syntax and semantics</li>
<li>Type system integration</li>
<li>Usage examples</li>
<li>Implementation details</li>
<li>Best practices</li>
<li>Performance considerations</li>
<li>Comparison with other languages (Elixir, Rust, Haskell)</li>
</ul>

<h3>4. Optimizations</h3>

<strong>File</strong>: <code>src/types/cure<em>pipe</em>optimizer.erl</code>

<p>Pipe-specific optimizations:</p>
<ul>
<li>Error-free chain detection</li>
<li>Inlining of provably pure pipe chains</li>
<li>Elimination of redundant wrapping/unwrapping</li>
<li>Statistics tracking for optimization effectiveness</li>
</ul>

<h2>Type System Integration</h2>

<p>The pipe operator integrates seamlessly with Cure's type system:</p>

<pre><code>def process_data(input: String) -> Result(Int, String) do
<p>  input</p>
<p>    |> parse_int       # String -> Result(Int, String)</p>
<p>    |> validate_range  # Int -> Result(Int, String)</p>
<p>    |> double          # Int -> Int (automatically wrapped)</p>
<p>end</p>
</code></pre>

<p>Type inference ensures:</p>
<ul>
<li>Piped value type matches function's first parameter</li>
<li>Result types propagate correctly</li>
<li>Non-monadic returns are wrapped in <code>Result<T></code></li>
</ul>

<h2>Performance Characteristics</h2>

<ol>
<li><strong>Compile-time</strong>: O(1) parsing and AST construction per pipe</li>
<li><strong>Runtime</strong>: One function call to <code>cure_std:pipe/2</code> per operation</li>
<li><strong>Optimization</strong>: Inlining possible for provably error-free chains</li>
</ol>

<p>Overhead is minimal and comparable to direct function calls with manual error handling.</p>

<h2>Testing</h2>

<p>Run the comprehensive test suite:</p>

<pre><code>% From Erlang shell
<p>c("test/pipe<em>operator</em>test.erl").</p>
<p>pipe<em>operator</em>test:run().</p>
</code></pre>

<p>Expected output:</p>
<pre><code>=== Pipe Operator Tests ===

<p>--- Lexer Tests ---</p>
<p>  Testing: Tokenize pipe operator... ✓</p>
<p>  Testing: Pipe in expression... ✓</p>
<p>  Testing: Multiple pipes... ✓</p>
<p>  Subtotal: 3/3 passed</p>

<p>--- Parser Tests ---</p>
<p>  Testing: Parse simple pipe... ✓</p>
<p>  Testing: Parse pipe chain... ✓</p>
<p>  Testing: Parse pipe with function call... ✓</p>
<p>  Testing: Pipe operator precedence... ✓</p>
<p>  Subtotal: 4/4 passed</p>

<p>... (additional test groups)</p>

<p>=== Test Summary ===</p>
<p>Total: 16, Passed: 16, Failed: 0</p>

<p>✓ All tests passed!</p>
</code></pre>

<h2>Examples</h2>

<h3>Basic Usage</h3>

<pre><code># Simple value transformation
<p>5 |> double |> increment</p>
<h1>Result: Ok(11)</h1>

<h1>Error handling</h1>
<p>"invalid" |> parse |> validate |> process</p>
<h1>Result: Error("Parse error")  (stopped at parse)</h1>

<h1>With function arguments</h1>
<p>10 |> add(5) |> multiply(3)</p>
<h1>Result: Ok(45)  # add(10, 5) => 15, multiply(15, 3) => 45</h1>
</code></pre>

<h3>Real-World Pipeline</h3>

<pre><code>def process<em>user</em>input(input: String) -> Result(User, String) do
<p>  input</p>
<p>    |> trim_whitespace</p>
<p>    |> validate_email</p>
<p>    |> normalize_email</p>
<p>    |> check<em>not</em>taken</p>
<p>    |> create_user</p>
<p>end</p>
</code></pre>

<h2>Comparison with Other Languages</h2>

<p>| Feature | Cure <code>|></code> | Elixir <code>|></code> | Rust <code>?</code> | Haskell <code>>>=</code> |</p>
<p>|---------|-----------|-------------|----------|---------------|</p>
<p>| Syntax | Infix | Infix | Postfix | Infix |</p>
<p>| Error Handling | Automatic | Manual | Automatic | Automatic |</p>
<p>| Type | Monadic | Syntactic | Monadic | Monadic |</p>
<p>| Precedence | Lowest | Lowest | N/A | Higher |</p>
<p>| Use Case | Pipelines | Pipelines | Early return | Composition |</p>

<h2>Future Enhancements</h2>

<p>Potential improvements for future versions:</p>

<ol>
<li><strong>Option Type Support</strong>: Extend pipe semantics to <code>Some</code>/<code>None</code></li>
<li><strong>Custom Monadic Types</strong>: Support user-defined monadic types via traits</li>
<li><strong>Async Integration</strong>: <code>async |></code> for asynchronous pipelines</li>
<li><strong>Type-Level Optimization</strong>: More aggressive inlining based on type proofs</li>
<li><strong>Debug Mode</strong>: Special debugging support for pipe chains</li>
</ol>

<h2>References</h2>

<ul>
<li><a href="docs/pipe_operator.md">Documentation</a></li>
<li><a href="examples/pipe_demo.cure">Example Code</a></li>
<li><a href="test/pipe<em>operator</em>test.erl">Test Suite</a></li>
<li><a href="src/types/cure<em>pipe</em>optimizer.erl">Optimizer</a></li>
</ul>

<h2>Credits</h2>

<p>Implementation based on:</p>
<ul>
<li>Elixir's pipe operator (syntax inspiration)</li>
<li>Rust's <code>?</code> operator (error handling semantics)</li>
<li>Haskell's bind operator (monadic composition theory)</li>
</ul>

<p>Adapted for Cure's type system and BEAM runtime.</p>

<p>---</p>

<strong>Implementation Date</strong>: 2025-11-02  
<strong>Status</strong>: Production Ready ✅  
<strong>Test Coverage</strong>: 16 tests, all passing

    </div>

    <!-- Pill Decoration -->
    <img src="../media/pill-512x512.png" alt="" class="pill-decoration">

    <!-- Footer -->
    <footer class="site-footer">
        <div class="footer-content">
            <div class="footer-section">
                <h4>Documentation</h4>
                <ul>
                    <li><a href="../docs.html">Getting Started</a></li>
                    <li><a href="language-spec.html">Language Specification</a></li>
                    <li><a href="type-system.html">Type System</a></li>
                    <li><a href="fsm-usage.html">FSM Guide</a></li>
                </ul>
            </div>

            <div class="footer-section">
                <h4>Reference</h4>
                <ul>
                    <li><a href="../api/index.html">API Reference</a></li>
                    <li><a href="std-summary.html">Standard Library</a></li>
                    <li><a href="feature-reference.html">Feature Reference</a></li>
                    <li><a href="cli-usage.html">CLI Usage</a></li>
                </ul>
            </div>

            <div class="footer-section">
                <h4>Resources</h4>
                <ul>
                    <li><a href="editor-setup.html">Editor Setup</a></li>
                    <li><a href="project-overview.html">Project Overview</a></li>
                    <li><a href="cure-ultimate-description.html">Ultimate Guide</a></li>
                </ul>
            </div>
        </div>

        <div class="footer-bottom">
            <p>&copy; 2025 Cure Programming Language. Verification-first programming for the BEAM.</p>
        </div>
    </footer>
</body>
</html>
