<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Dependent Type System Design for Cure - Cure Documentation</title>
    <meta name="description" content="Version: 1.0  
Date: 2025-11-19  
Status: Design Phase  
Author: SMT Integration Team">
    <link rel="icon" type="image/png" href="../media/logo-128x128.png">
    <link rel="stylesheet" href="../css/style.css">
    <link rel="stylesheet" href="../css/cure-theme.css">
</head>
<body>
    <!-- Header -->
    <header class="site-header">
        <div class="nav-container">
            <div class="logo-section">
                <img src="../media/logo-128x128.png" alt="Cure Logo" class="logo">
                <div>
                    <h1 class="site-title">Cure</h1>
                    <p class="site-tagline">Verification-First Programming</p>
                </div>
            </div>
            <nav class="main-nav">
                <ul>
                    <li><a href="../index.html">Home</a></li>
                    <li><a href="../docs.html">Documentation</a></li>
                    <li><a href="../api/index.html">API Reference</a></li>
                </ul>
            </nav>
        </div>
    </header>

    <!-- Main Content -->
    <div class="doc-page">
        <div class="doc-nav">
            <a href="../docs.html">← Back to Documentation</a>
        </div>
        
        <h1 id="dependent-type-system-design-for-cure">Dependent Type System Design for Cure</h1>
<p><strong>Version</strong>: 1.0<br />
<strong>Date</strong>: 2025-11-19<br />
<strong>Status</strong>: Design Phase<br />
<strong>Author</strong>: SMT Integration Team</p>
<hr />
<h2 id="table-of-contents">Table of Contents</h2>
<ol>
<li><a href="#overview">Overview</a></li>
<li><a href="#motivation">Motivation</a></li>
<li><a href="#design-principles">Design Principles</a></li>
<li><a href="#syntax">Syntax</a></li>
<li><a href="#type-system-architecture">Type System Architecture</a></li>
<li><a href="#smt-encoding-strategy">SMT Encoding Strategy</a></li>
<li><a href="#type-inference">Type Inference</a></li>
<li><a href="#integration-with-existing-system">Integration with Existing System</a></li>
<li><a href="#implementation-plan">Implementation Plan</a></li>
<li><a href="#examples">Examples</a></li>
</ol>
<hr />
<h2 id="overview">Overview</h2>
<p>This document outlines the design of dependent types for the Cure programming language. Dependent types allow types to depend on values, enabling compile-time verification of properties like array bounds, list lengths, and numerical constraints.</p>
<h3 id="goals">Goals</h3>
<ol>
<li><strong>Safety</strong>: Eliminate runtime bounds checks through compile-time verification</li>
<li><strong>Expressiveness</strong>: Enable precise specifications (e.g., <code>Vector(T, n)</code> with length <code>n</code>)</li>
<li><strong>SMT Integration</strong>: Leverage existing SMT infrastructure for verification</li>
<li><strong>Backward Compatibility</strong>: Maintain compatibility with existing type system</li>
<li><strong>Practicality</strong>: Focus on useful cases (lengths, bounds) before full dependent types</li>
</ol>
<h3 id="non-goals">Non-Goals</h3>
<ol>
<li>Full dependent type theory (à la Coq/Agda) - too complex</li>
<li>Dependent pattern matching initially - add later if needed</li>
<li>Type-level computation beyond arithmetic - keep simple</li>
</ol>
<hr />
<h2 id="motivation">Motivation</h2>
<h3 id="problem-array-bounds-checks">Problem: Array Bounds Checks</h3>
<p>Current Cure code requires runtime checks:</p>
<div class="codehilite"><pre><span></span><code><span class="n">def</span><span class="w"> </span><span class="n">head</span><span class="p">(</span><span class="n">xs</span><span class="o">:</span><span class="w"> </span><span class="n">List</span><span class="p">(</span><span class="n">Int</span><span class="p">))</span><span class="o">:</span><span class="w"> </span><span class="n">Int</span><span class="w"> </span><span class="o">=</span>
<span class="w">    </span><span class="n">match</span><span class="w"> </span><span class="n">xs</span><span class="w"> </span><span class="n">with</span>
<span class="w">    </span><span class="o">|</span><span class="w"> </span><span class="p">[</span><span class="n">x</span><span class="w"> </span><span class="o">|</span><span class="w"> </span><span class="n">_</span><span class="p">]</span><span class="w"> </span><span class="o">-&gt;</span><span class="w"> </span><span class="n">x</span>
<span class="w">    </span><span class="o">|</span><span class="w"> </span><span class="p">[]</span><span class="w"> </span><span class="o">-&gt;</span><span class="w"> </span><span class="nf">error</span><span class="p">(</span><span class="s">&quot;empty list&quot;</span><span class="p">)</span><span class="w">  </span><span class="o">%</span><span class="w"> </span><span class="n">Runtime</span><span class="w"> </span><span class="nf">error</span><span class="o">!</span>
<span class="w">    </span><span class="kd">end</span>
</code></pre></div>

<h3 id="solution-length-indexed-types">Solution: Length-Indexed Types</h3>
<p>With dependent types, prove safety at compile-time:</p>
<div class="codehilite"><pre><span></span><code><span class="n">def</span><span class="w"> </span><span class="s">head&lt;T,</span><span class="w"> </span><span class="s">n:</span><span class="w"> </span><span class="s">Nat&gt;(xs:</span><span class="w"> </span><span class="s">Vector(T,</span><span class="w"> </span><span class="s">n+1)):</span><span class="w"> </span><span class="s">T</span><span class="w"> </span><span class="p">=</span>
<span class="w">    </span><span class="n">match</span><span class="w"> </span><span class="n">xs</span><span class="w"> </span><span class="n">with</span>
<span class="w">    </span><span class="o">|</span><span class="w"> </span><span class="p">[</span><span class="n">x</span><span class="w"> </span><span class="o">|</span><span class="w"> </span><span class="n">_</span><span class="p">]</span><span class="w"> </span><span class="o">-&gt;</span><span class="w"> </span><span class="n">x</span>
<span class="w">    </span><span class="k">end</span>
<span class="w">    </span><span class="c">% No error case needed - type system proves xs is non-empty</span>
</code></pre></div>

<h3 id="benefits">Benefits</h3>
<ul>
<li><strong>No runtime checks</strong>: Compiler proves safety</li>
<li><strong>Better documentation</strong>: Types express invariants</li>
<li><strong>Optimization</strong>: Compiler can optimize away checks</li>
<li><strong>Error prevention</strong>: Catch bugs at compile time</li>
</ul>
<hr />
<h2 id="design-principles">Design Principles</h2>
<h3 id="1-start-simple">1. Start Simple</h3>
<p>Focus on <strong>refinement-based dependent types</strong>:<br />
- Types parametrized by values (e.g., <code>Vector(T, n)</code>)<br />
- Constraints verified by SMT<br />
- No full type-level computation initially</p>
<h3 id="2-leverage-existing-infrastructure">2. Leverage Existing Infrastructure</h3>
<ul>
<li>Build on refinement types (<code>cure_refinement_types.erl</code>)</li>
<li>Use SMT for verification (<code>cure_smt_translator.erl</code>)</li>
<li>Extend type checker, don't replace it</li>
</ul>
<h3 id="3-gradual-typing">3. Gradual Typing</h3>
<ul>
<li>Optional: Use dependent types only where needed</li>
<li>Fallback: Regular types still work</li>
<li>Mixed: Can combine dependent and non-dependent code</li>
</ul>
<h3 id="4-practical-focus">4. Practical Focus</h3>
<p>Prioritize common use cases:<br />
1. Length-indexed lists/vectors<br />
2. Bounded integers (e.g., <code>0 ≤ x &lt; n</code>)<br />
3. Non-null types<br />
4. FSM state invariants</p>
<hr />
<h2 id="syntax">Syntax</h2>
<h3 id="type-level-parameters">Type-Level Parameters</h3>
<div class="codehilite"><pre><span></span><code><span class="k">type</span><span class="w"> </span><span class="nx">Vector</span><span class="p">(</span><span class="nx">T</span><span class="p">,</span><span class="w"> </span><span class="nx">n</span><span class="p">:</span><span class="w"> </span><span class="nx">Nat</span><span class="p">)</span><span class="w"> </span><span class="p">=</span><span class="w"> </span><span class="nx">List</span><span class="p">(</span><span class="nx">T</span><span class="p">)</span><span class="w"> </span><span class="nx">when</span><span class="w"> </span><span class="nx">length</span><span class="p">(</span><span class="nx">this</span><span class="p">)</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="nx">n</span>
<span class="k">type</span><span class="w"> </span><span class="nx">BoundedInt</span><span class="p">(</span><span class="nx">min</span><span class="p">:</span><span class="w"> </span><span class="nx">Int</span><span class="p">,</span><span class="w"> </span><span class="nx">max</span><span class="p">:</span><span class="w"> </span><span class="nx">Int</span><span class="p">)</span><span class="w"> </span><span class="p">=</span><span class="w"> </span><span class="nx">Int</span><span class="w"> </span><span class="nx">when</span><span class="w"> </span><span class="nx">min</span><span class="w"> </span><span class="o">&lt;=</span><span class="w"> </span><span class="nx">this</span><span class="w"> </span><span class="o">&lt;=</span><span class="w"> </span><span class="nx">max</span>
<span class="k">type</span><span class="w"> </span><span class="nx">Matrix</span><span class="p">(</span><span class="nx">T</span><span class="p">,</span><span class="w"> </span><span class="nx">rows</span><span class="p">:</span><span class="w"> </span><span class="nx">Nat</span><span class="p">,</span><span class="w"> </span><span class="nx">cols</span><span class="p">:</span><span class="w"> </span><span class="nx">Nat</span><span class="p">)</span><span class="w"> </span><span class="p">=</span><span class="w"> </span><span class="nx">Vector</span><span class="p">(</span><span class="nx">Vector</span><span class="p">(</span><span class="nx">T</span><span class="p">,</span><span class="w"> </span><span class="nx">cols</span><span class="p">),</span><span class="w"> </span><span class="nx">rows</span><span class="p">)</span>
</code></pre></div>

<p><strong>Grammar Addition</strong>:</p>
<div class="codehilite"><pre><span></span><code><span class="nx">type_def</span><span class="w"> </span><span class="o">::</span><span class="p">=</span><span class="w"> </span><span class="err">&#39;</span><span class="k">type</span><span class="err">&#39;</span><span class="w"> </span><span class="nx">identifier</span><span class="w"> </span><span class="nx">type_params</span><span class="w"> </span><span class="sc">&#39;=&#39;</span><span class="w"> </span><span class="nx">type_expr</span><span class="w"> </span><span class="nx">constraints</span>
<span class="nx">type_params</span><span class="w"> </span><span class="o">::</span><span class="p">=</span><span class="w"> </span><span class="sc">&#39;(&#39;</span><span class="w"> </span><span class="nx">param_list</span><span class="w"> </span><span class="sc">&#39;)&#39;</span>
<span class="nx">param_list</span><span class="w"> </span><span class="o">::</span><span class="p">=</span><span class="w"> </span><span class="nx">param</span><span class="w"> </span><span class="o">|</span><span class="w"> </span><span class="nx">param</span><span class="w"> </span><span class="sc">&#39;,&#39;</span><span class="w"> </span><span class="nx">param_list</span>
<span class="nx">param</span><span class="w"> </span><span class="o">::</span><span class="p">=</span><span class="w"> </span><span class="nx">identifier</span><span class="w"> </span><span class="sc">&#39;:&#39;</span><span class="w"> </span><span class="k">type</span><span class="w">  </span><span class="o">%</span><span class="w"> </span><span class="nx">Value</span><span class="w"> </span><span class="nx">parameter</span>
<span class="w">        </span><span class="o">|</span><span class="w"> </span><span class="nx">identifier</span><span class="w">           </span><span class="o">%</span><span class="w"> </span><span class="nx">Type</span><span class="w"> </span><span class="nx">parameter</span>
</code></pre></div>

<h3 id="dependent-function-types">Dependent Function Types</h3>
<div class="codehilite"><pre><span></span><code>def concat&lt;T, m: Nat, n: Nat&gt;(
    v1: Vector(T, m),
    v2: Vector(T, n)
): Vector(T, m + n) =
    v1 ++ v2

def safe_index&lt;T, n: Nat&gt;(
    v: Vector(T, n),
    i: Nat where i &lt; n
): T =
    nth(v, i)  % No bounds check needed!
</code></pre></div>

<p><strong>Grammar Addition</strong>:</p>
<div class="codehilite"><pre><span></span><code><span class="n">function_def</span><span class="w"> </span><span class="s">::=</span><span class="w"> </span><span class="s">&#39;def&#39;</span><span class="w"> </span><span class="s">identifier</span><span class="w"> </span><span class="s">type_params</span><span class="w"> </span><span class="s">&#39;(&#39;</span><span class="w"> </span><span class="s">param_list</span><span class="w"> </span><span class="s">&#39;)&#39;</span><span class="w"> </span><span class="s">type_annotation</span><span class="w"> </span><span class="s">&#39;=&#39;</span><span class="w"> </span><span class="s">expr</span>
<span class="n">type_params</span><span class="w"> </span><span class="s">::=</span><span class="w"> </span><span class="s">&#39;&lt;&#39;</span><span class="w"> </span><span class="s">type_param_list</span><span class="w"> </span><span class="s">&#39;&gt;&#39;</span>
<span class="n">type_param</span><span class="w"> </span><span class="s">::=</span><span class="w"> </span><span class="s">identifier</span><span class="w">                   </span><span class="s">%</span><span class="w"> </span><span class="s">Type</span><span class="w"> </span><span class="s">parameter</span>
<span class="w">             </span><span class="o">|</span><span class="w"> </span><span class="n">identifier</span><span class="w"> </span><span class="s">&#39;:&#39;</span><span class="w"> </span><span class="n">type_expr</span><span class="w">      </span><span class="c">% Value parameter with type</span>
<span class="w">             </span><span class="o">|</span><span class="w"> </span><span class="n">identifier</span><span class="w"> </span><span class="s">&#39;:&#39;</span><span class="w"> </span><span class="nb">type</span><span class="w"> </span><span class="s">&#39;where&#39;</span><span class="w"> </span><span class="n">expr</span><span class="w">  </span><span class="c">% Constrained value parameter</span>
</code></pre></div>

<h3 id="type-level-expressions">Type-Level Expressions</h3>
<p>Supported operations:<br />
- <strong>Arithmetic</strong>: <code>m + n</code>, <code>m - n</code>, <code>m * n</code>, <code>m / n</code><br />
- <strong>Comparison</strong>: <code>m == n</code>, <code>m &lt; n</code>, <code>m &lt;= n</code><br />
- <strong>Boolean</strong>: <code>and</code>, <code>or</code>, <code>not</code></p>
<div class="codehilite"><pre><span></span><code><span class="k">type</span><span class="w"> </span><span class="nx">AddResult</span><span class="p">(</span><span class="nx">m</span><span class="p">:</span><span class="w"> </span><span class="nx">Nat</span><span class="p">,</span><span class="w"> </span><span class="nx">n</span><span class="p">:</span><span class="w"> </span><span class="nx">Nat</span><span class="p">)</span><span class="w"> </span><span class="p">=</span><span class="w"> </span><span class="nx">Int</span><span class="w"> </span><span class="k">where</span><span class="w"> </span><span class="nx">this</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="nx">m</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="nx">n</span>
<span class="k">type</span><span class="w"> </span><span class="nx">InRange</span><span class="p">(</span><span class="nx">lo</span><span class="p">:</span><span class="w"> </span><span class="nx">Int</span><span class="p">,</span><span class="w"> </span><span class="nx">hi</span><span class="p">:</span><span class="w"> </span><span class="nx">Int</span><span class="p">)</span><span class="w"> </span><span class="p">=</span><span class="w"> </span><span class="nx">Int</span><span class="w"> </span><span class="k">where</span><span class="w"> </span><span class="nx">lo</span><span class="w"> </span><span class="o">&lt;=</span><span class="w"> </span><span class="nx">this</span><span class="w"> </span><span class="o">&lt;=</span><span class="w"> </span><span class="nx">hi</span>
<span class="k">type</span><span class="w"> </span><span class="nx">NonEmpty</span><span class="p">(</span><span class="nx">T</span><span class="p">)</span><span class="w"> </span><span class="p">=</span><span class="w"> </span><span class="nx">Vector</span><span class="p">(</span><span class="nx">T</span><span class="p">,</span><span class="w"> </span><span class="nx">n</span><span class="p">)</span><span class="w"> </span><span class="k">where</span><span class="w"> </span><span class="nx">n</span><span class="w"> </span><span class="p">&gt;</span><span class="w"> </span><span class="mi">0</span>
</code></pre></div>

<h3 id="constraint-propagation">Constraint Propagation</h3>
<div class="codehilite"><pre><span></span><code><span class="n">def</span><span class="w"> </span><span class="s">append&lt;T,</span><span class="w"> </span><span class="s">m:</span><span class="w"> </span><span class="s">Nat,</span><span class="w"> </span><span class="s">n:</span><span class="w"> </span><span class="s">Nat&gt;(</span>
<span class="w">    </span><span class="n">v1</span><span class="p">:</span><span class="w"> </span><span class="n">Vector</span><span class="p">(</span><span class="n">T</span><span class="p">,</span><span class="w"> </span><span class="n">m</span><span class="p">),</span>
<span class="w">    </span><span class="n">v2</span><span class="p">:</span><span class="w"> </span><span class="n">Vector</span><span class="p">(</span><span class="n">T</span><span class="p">,</span><span class="w"> </span><span class="n">n</span><span class="p">)</span>
<span class="p">):</span><span class="w"> </span><span class="n">Vector</span><span class="p">(</span><span class="n">T</span><span class="p">,</span><span class="w"> </span><span class="n">m</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">n</span><span class="p">)</span><span class="w"> </span><span class="p">=</span>
<span class="w">    </span><span class="c">% Compiler must prove:</span>
<span class="w">    </span><span class="c">%   length(v1) == m (from v1&#39;s type)</span>
<span class="w">    </span><span class="c">%   length(v2) == n (from v2&#39;s type)</span>
<span class="w">    </span><span class="c">%   length(v1 ++ v2) == m + n (return type requirement)</span>
<span class="w">    </span><span class="n">v1</span><span class="w"> </span><span class="o">++</span><span class="w"> </span><span class="n">v2</span>
</code></pre></div>

<hr />
<h2 id="type-system-architecture">Type System Architecture</h2>
<h3 id="type-representation">Type Representation</h3>
<p><strong>AST Records</strong> (<code>cure_ast.hrl</code>):</p>
<div class="codehilite"><pre><span></span><code><span class="c">%% Dependent type with value parameters</span>
<span class="p">-</span><span class="ni">record</span><span class="p">(</span><span class="nl">dependent_type</span><span class="p">,</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="n">name</span><span class="p">,</span><span class="w">           </span><span class="c">% Type constructor name (e.g., &#39;Vector&#39;)</span>
<span class="w">    </span><span class="n">type_params</span><span class="p">,</span><span class="w">    </span><span class="c">% Type parameters [T, U, ...]</span>
<span class="w">    </span><span class="n">value_params</span><span class="p">,</span><span class="w">   </span><span class="c">% Value parameters [{n, nat}, {m, nat}, ...]</span>
<span class="w">    </span><span class="n">constraints</span><span class="p">,</span><span class="w">    </span><span class="c">% Refinement constraints [expr()]</span>
<span class="w">    </span><span class="n">location</span>
<span class="p">}).</span>

<span class="c">%% Dependent function type</span>
<span class="p">-</span><span class="ni">record</span><span class="p">(</span><span class="nl">dependent_function_type</span><span class="p">,</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="n">type_params</span><span class="p">,</span><span class="w">    </span><span class="c">% Type-level parameters [{T, kind}, {n, nat}, ...]</span>
<span class="w">    </span><span class="n">params</span><span class="p">,</span><span class="w">         </span><span class="c">% Function parameters [#param{}]</span>
<span class="w">    </span><span class="n">return_type</span><span class="p">,</span><span class="w">    </span><span class="c">% Return type (may depend on value params)</span>
<span class="w">    </span><span class="n">constraints</span><span class="p">,</span><span class="w">    </span><span class="c">% Where clauses [expr()]</span>
<span class="w">    </span><span class="n">location</span>
<span class="p">}).</span>

<span class="c">%% Type-level expression</span>
<span class="p">-</span><span class="ni">record</span><span class="p">(</span><span class="nl">type_level_expr</span><span class="p">,</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="n">op</span><span class="p">,</span><span class="w">             </span><span class="c">% +, -, *, /, ==, &lt;, &lt;=, etc.</span>
<span class="w">    </span><span class="n">operands</span><span class="p">,</span><span class="w">       </span><span class="c">% [expr() | identifier]</span>
<span class="w">    </span><span class="n">location</span>
<span class="p">}).</span>
</code></pre></div>

<h3 id="type-environment">Type Environment</h3>
<p>Extended to track type-level variables:</p>
<div class="codehilite"><pre><span></span><code><span class="p">-</span><span class="ni">record</span><span class="p">(</span><span class="nl">type_env</span><span class="p">,</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="n">term_vars</span><span class="p">,</span><span class="w">      </span><span class="c">% #{VarName =&gt; Type} - term-level variables</span>
<span class="w">    </span><span class="n">type_vars</span><span class="p">,</span><span class="w">      </span><span class="c">% #{TVar =&gt; Kind} - type variables (T, U, etc.)</span>
<span class="w">    </span><span class="n">value_params</span><span class="p">,</span><span class="w">   </span><span class="c">% #{Param =&gt; Type} - value parameters (n: Nat, etc.)</span>
<span class="w">    </span><span class="n">constraints</span><span class="p">,</span><span class="w">    </span><span class="c">% [Constraint] - accumulated constraints</span>
<span class="w">    </span><span class="n">smt_env</span><span class="w">         </span><span class="c">% SMT environment for verification</span>
<span class="p">}).</span>
</code></pre></div>

<h3 id="type-checking-phases">Type Checking Phases</h3>
<ol>
<li><strong>Parsing</strong>: Recognize dependent type syntax</li>
<li><strong>Elaboration</strong>: Convert to internal representation</li>
<li><strong>Constraint Generation</strong>: Extract verification conditions</li>
<li><strong>SMT Verification</strong>: Prove constraints via Z3</li>
<li><strong>Error Reporting</strong>: Show counterexamples if verification fails</li>
</ol>
<hr />
<h2 id="smt-encoding-strategy">SMT Encoding Strategy</h2>
<h3 id="encoding-length-constraints">Encoding Length Constraints</h3>
<p><strong>Cure Code</strong>:</p>
<div class="codehilite"><pre><span></span><code><span class="k">type</span><span class="w"> </span><span class="nx">Vector</span><span class="p">(</span><span class="nx">T</span><span class="p">,</span><span class="w"> </span><span class="nx">n</span><span class="p">:</span><span class="w"> </span><span class="nx">Nat</span><span class="p">)</span><span class="w"> </span><span class="p">=</span><span class="w"> </span><span class="nx">List</span><span class="p">(</span><span class="nx">T</span><span class="p">)</span><span class="w"> </span><span class="nx">when</span><span class="w"> </span><span class="nx">length</span><span class="p">(</span><span class="nx">this</span><span class="p">)</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="nx">n</span>
</code></pre></div>

<p><strong>SMT Encoding</strong>:</p>
<div class="codehilite"><pre><span></span><code><span class="p">(</span><span class="n">declare</span><span class="o">-</span><span class="n">sort</span><span class="w"> </span><span class="n">T</span><span class="p">)</span>
<span class="p">(</span><span class="n">declare</span><span class="o">-</span><span class="n">sort</span><span class="w"> </span><span class="n">List</span><span class="p">)</span>
<span class="p">(</span><span class="n">declare</span><span class="o">-</span><span class="n">fun</span><span class="w"> </span><span class="n">length</span><span class="w"> </span><span class="p">(</span><span class="n">List</span><span class="p">)</span><span class="w"> </span><span class="n">Int</span><span class="p">)</span>

<span class="p">;</span><span class="w"> </span><span class="n">Axioms</span><span class="w"> </span><span class="k">for</span><span class="w"> </span><span class="n">length</span>
<span class="p">(</span><span class="nb">assert</span><span class="w"> </span><span class="p">(</span><span class="o">=</span><span class="w"> </span><span class="p">(</span><span class="n">length</span><span class="w"> </span><span class="n">nil</span><span class="p">)</span><span class="w"> </span><span class="mi">0</span><span class="p">))</span>
<span class="p">(</span><span class="nb">assert</span><span class="w"> </span><span class="p">(</span><span class="n">forall</span><span class="w"> </span><span class="p">((</span><span class="n">x</span><span class="w"> </span><span class="n">T</span><span class="p">)</span><span class="w"> </span><span class="p">(</span><span class="n">xs</span><span class="w"> </span><span class="n">List</span><span class="p">))</span>
<span class="w">    </span><span class="p">(</span><span class="o">=</span><span class="w"> </span><span class="p">(</span><span class="n">length</span><span class="w"> </span><span class="p">(</span><span class="n">cons</span><span class="w"> </span><span class="n">x</span><span class="w"> </span><span class="n">xs</span><span class="p">))</span><span class="w"> </span><span class="p">(</span><span class="o">+</span><span class="w"> </span><span class="mi">1</span><span class="w"> </span><span class="p">(</span><span class="n">length</span><span class="w"> </span><span class="n">xs</span><span class="p">)))))</span>

<span class="p">;</span><span class="w"> </span><span class="n">Constraint</span><span class="w"> </span><span class="k">for</span><span class="w"> </span><span class="n">Vector</span><span class="p">(</span><span class="n">T</span><span class="p">,</span><span class="w"> </span><span class="n">n</span><span class="p">)</span>
<span class="p">(</span><span class="n">declare</span><span class="o">-</span><span class="k">const</span><span class="w"> </span><span class="n">v</span><span class="w"> </span><span class="n">List</span><span class="p">)</span>
<span class="p">(</span><span class="n">declare</span><span class="o">-</span><span class="k">const</span><span class="w"> </span><span class="n">n</span><span class="w"> </span><span class="n">Int</span><span class="p">)</span>
<span class="p">(</span><span class="nb">assert</span><span class="w"> </span><span class="p">(</span><span class="o">&gt;=</span><span class="w"> </span><span class="n">n</span><span class="w"> </span><span class="mi">0</span><span class="p">))</span><span class="w">  </span><span class="p">;</span><span class="w"> </span><span class="n">n</span><span class="w"> </span><span class="k">is</span><span class="w"> </span><span class="n">Nat</span>
<span class="p">(</span><span class="nb">assert</span><span class="w"> </span><span class="p">(</span><span class="o">=</span><span class="w"> </span><span class="p">(</span><span class="n">length</span><span class="w"> </span><span class="n">v</span><span class="p">)</span><span class="w"> </span><span class="n">n</span><span class="p">))</span>
</code></pre></div>

<h3 id="encoding-arithmetic">Encoding Arithmetic</h3>
<p><strong>Cure Code</strong>:</p>
<div class="codehilite"><pre><span></span><code>def concat&lt;T, m: Nat, n: Nat&gt;(
    v1: Vector(T, m),
    v2: Vector(T, n)
): Vector(T, m + n)
</code></pre></div>

<p><strong>Verification Condition</strong>:</p>
<div class="codehilite"><pre><span></span><code><span class="n">Given</span><span class="o">:</span>
<span class="w">  </span><span class="n">length</span><span class="o">(</span><span class="n">v1</span><span class="o">)</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="n">m</span>
<span class="w">  </span><span class="n">length</span><span class="o">(</span><span class="n">v2</span><span class="o">)</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="n">n</span>
<span class="n">Prove</span><span class="o">:</span>
<span class="w">  </span><span class="n">length</span><span class="o">(</span><span class="n">v1</span><span class="w"> </span><span class="o">++</span><span class="w"> </span><span class="n">v2</span><span class="o">)</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="n">m</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">n</span>
</code></pre></div>

<p><strong>SMT Query</strong>:</p>
<div class="codehilite"><pre><span></span><code><span class="p">(</span><span class="n">declare</span><span class="o">-</span><span class="k">const</span><span class="w"> </span><span class="n">v1</span><span class="w"> </span><span class="n">List</span><span class="p">)</span>
<span class="p">(</span><span class="n">declare</span><span class="o">-</span><span class="k">const</span><span class="w"> </span><span class="n">v2</span><span class="w"> </span><span class="n">List</span><span class="p">)</span>
<span class="p">(</span><span class="n">declare</span><span class="o">-</span><span class="k">const</span><span class="w"> </span><span class="n">m</span><span class="w"> </span><span class="n">Int</span><span class="p">)</span>
<span class="p">(</span><span class="n">declare</span><span class="o">-</span><span class="k">const</span><span class="w"> </span><span class="n">n</span><span class="w"> </span><span class="n">Int</span><span class="p">)</span>

<span class="p">;</span><span class="w"> </span><span class="n">Given</span>
<span class="p">(</span><span class="nb">assert</span><span class="w"> </span><span class="p">(</span><span class="o">&gt;=</span><span class="w"> </span><span class="n">m</span><span class="w"> </span><span class="mi">0</span><span class="p">))</span>
<span class="p">(</span><span class="nb">assert</span><span class="w"> </span><span class="p">(</span><span class="o">&gt;=</span><span class="w"> </span><span class="n">n</span><span class="w"> </span><span class="mi">0</span><span class="p">))</span>
<span class="p">(</span><span class="nb">assert</span><span class="w"> </span><span class="p">(</span><span class="o">=</span><span class="w"> </span><span class="p">(</span><span class="n">length</span><span class="w"> </span><span class="n">v1</span><span class="p">)</span><span class="w"> </span><span class="n">m</span><span class="p">))</span>
<span class="p">(</span><span class="nb">assert</span><span class="w"> </span><span class="p">(</span><span class="o">=</span><span class="w"> </span><span class="p">(</span><span class="n">length</span><span class="w"> </span><span class="n">v2</span><span class="p">)</span><span class="w"> </span><span class="n">n</span><span class="p">))</span>

<span class="p">;</span><span class="w"> </span><span class="n">Append</span><span class="w"> </span><span class="n">axiom</span>
<span class="p">(</span><span class="nb">assert</span><span class="w"> </span><span class="p">(</span><span class="n">forall</span><span class="w"> </span><span class="p">((</span><span class="n">xs</span><span class="w"> </span><span class="n">List</span><span class="p">)</span><span class="w"> </span><span class="p">(</span><span class="n">ys</span><span class="w"> </span><span class="n">List</span><span class="p">))</span>
<span class="w">    </span><span class="p">(</span><span class="o">=</span><span class="w"> </span><span class="p">(</span><span class="n">length</span><span class="w"> </span><span class="p">(</span><span class="n">append</span><span class="w"> </span><span class="n">xs</span><span class="w"> </span><span class="n">ys</span><span class="p">))</span><span class="w"> </span><span class="p">(</span><span class="o">+</span><span class="w"> </span><span class="p">(</span><span class="n">length</span><span class="w"> </span><span class="n">xs</span><span class="p">)</span><span class="w"> </span><span class="p">(</span><span class="n">length</span><span class="w"> </span><span class="n">ys</span><span class="p">)))))</span>

<span class="p">;</span><span class="w"> </span><span class="n">Prove</span><span class="p">:</span><span class="w"> </span><span class="n">length</span><span class="p">(</span><span class="n">append</span><span class="w"> </span><span class="n">v1</span><span class="w"> </span><span class="n">v2</span><span class="p">)</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="n">m</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">n</span>
<span class="p">(</span><span class="nb">assert</span><span class="w"> </span><span class="p">(</span><span class="ow">not</span><span class="w"> </span><span class="p">(</span><span class="o">=</span><span class="w"> </span><span class="p">(</span><span class="n">length</span><span class="w"> </span><span class="p">(</span><span class="n">append</span><span class="w"> </span><span class="n">v1</span><span class="w"> </span><span class="n">v2</span><span class="p">))</span><span class="w"> </span><span class="p">(</span><span class="o">+</span><span class="w"> </span><span class="n">m</span><span class="w"> </span><span class="n">n</span><span class="p">))))</span>
<span class="p">(</span><span class="n">check</span><span class="o">-</span><span class="n">sat</span><span class="p">)</span>
<span class="p">;</span><span class="w"> </span><span class="n">Expected</span><span class="p">:</span><span class="w"> </span><span class="n">unsat</span><span class="w"> </span><span class="p">(</span><span class="n">proof</span><span class="w"> </span><span class="n">succeeds</span><span class="p">)</span>
</code></pre></div>

<h3 id="encoding-bounds">Encoding Bounds</h3>
<p><strong>Cure Code</strong>:</p>
<div class="codehilite"><pre><span></span><code>def safe_index&lt;T, n: Nat&gt;(v: Vector(T, n), i: Nat where i &lt; n): T
</code></pre></div>

<p><strong>Verification Condition</strong>:</p>
<div class="codehilite"><pre><span></span><code><span class="n">Given</span><span class="o">:</span>
<span class="w">  </span><span class="n">length</span><span class="o">(</span><span class="n">v</span><span class="o">)</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="n">n</span>
<span class="w">  </span><span class="n">i</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="n">n</span>
<span class="w">  </span><span class="n">i</span><span class="w"> </span><span class="o">&gt;=</span><span class="w"> </span><span class="mi">0</span>
<span class="n">Prove</span><span class="o">:</span>
<span class="w">  </span><span class="mi">0</span><span class="w"> </span><span class="o">&lt;=</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="n">length</span><span class="o">(</span><span class="n">v</span><span class="o">)</span><span class="w">  </span><span class="o">(</span><span class="n">safe</span><span class="w"> </span><span class="n">indexing</span><span class="o">)</span>
</code></pre></div>

<p><strong>SMT Query</strong>:</p>
<div class="codehilite"><pre><span></span><code><span class="p">(</span><span class="n">declare</span><span class="o">-</span><span class="k">const</span><span class="w"> </span><span class="n">n</span><span class="w"> </span><span class="n">Int</span><span class="p">)</span>
<span class="p">(</span><span class="n">declare</span><span class="o">-</span><span class="k">const</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="n">Int</span><span class="p">)</span>

<span class="p">(</span><span class="nb">assert</span><span class="w"> </span><span class="p">(</span><span class="o">&gt;=</span><span class="w"> </span><span class="n">n</span><span class="w"> </span><span class="mi">0</span><span class="p">))</span>
<span class="p">(</span><span class="nb">assert</span><span class="w"> </span><span class="p">(</span><span class="o">&gt;=</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="mi">0</span><span class="p">))</span>
<span class="p">(</span><span class="nb">assert</span><span class="w"> </span><span class="p">(</span><span class="o">&lt;</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="n">n</span><span class="p">))</span>

<span class="p">;</span><span class="w"> </span><span class="n">Prove</span><span class="p">:</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="k">is</span><span class="w"> </span><span class="n">valid</span><span class="w"> </span><span class="n">index</span>
<span class="p">(</span><span class="nb">assert</span><span class="w"> </span><span class="p">(</span><span class="ow">not</span><span class="w"> </span><span class="p">(</span><span class="ow">and</span><span class="w"> </span><span class="p">(</span><span class="o">&gt;=</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="mi">0</span><span class="p">)</span><span class="w"> </span><span class="p">(</span><span class="o">&lt;</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="n">n</span><span class="p">))))</span>
<span class="p">(</span><span class="n">check</span><span class="o">-</span><span class="n">sat</span><span class="p">)</span>
<span class="p">;</span><span class="w"> </span><span class="n">Expected</span><span class="p">:</span><span class="w"> </span><span class="n">unsat</span><span class="w"> </span><span class="p">(</span><span class="n">proof</span><span class="w"> </span><span class="n">succeeds</span><span class="p">)</span>
</code></pre></div>

<hr />
<h2 id="type-inference">Type Inference</h2>
<h3 id="inference-rules">Inference Rules</h3>
<h4 id="rule-1-length-propagation">Rule 1: Length Propagation</h4>
<div class="codehilite"><pre><span></span><code>Γ ⊢ e : List(T)    length(e) = n
─────────────────────────────────
Γ ⊢ e : Vector(T, n)
</code></pre></div>

<h4 id="rule-2-arithmetic-inference">Rule 2: Arithmetic Inference</h4>
<div class="codehilite"><pre><span></span><code>Γ ⊢ v1 : Vector(T, m)    Γ ⊢ v2 : Vector(T, n)
──────────────────────────────────────────────
Γ ⊢ v1 ++ v2 : Vector(T, m + n)
</code></pre></div>

<h4 id="rule-3-constraint-propagation">Rule 3: Constraint Propagation</h4>
<div class="codehilite"><pre><span></span><code>Γ ⊢ e : τ where φ    Γ ⊢ φ ⇒ ψ (via SMT)
────────────────────────────────────────
Γ ⊢ e : τ where ψ
</code></pre></div>

<h3 id="inference-algorithm">Inference Algorithm</h3>
<div class="codehilite"><pre><span></span><code><span class="nf">infer_dependent_type</span><span class="p">(</span><span class="nv">Expr</span><span class="p">,</span><span class="w"> </span><span class="nv">Env</span><span class="p">)</span><span class="w"> </span><span class="o">-&gt;</span>
<span class="w">    </span><span class="c">% 1. Infer base type</span>
<span class="w">    </span><span class="p">{</span><span class="nv">BaseType</span><span class="p">,</span><span class="w"> </span><span class="nv">Constraints1</span><span class="p">}</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">infer_type</span><span class="p">(</span><span class="nv">Expr</span><span class="p">,</span><span class="w"> </span><span class="nv">Env</span><span class="p">),</span>

<span class="w">    </span><span class="c">% 2. Extract value-level information</span>
<span class="w">    </span><span class="nv">ValueInfo</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">extract_value_info</span><span class="p">(</span><span class="nv">Expr</span><span class="p">,</span><span class="w"> </span><span class="nv">Env</span><span class="p">),</span>

<span class="w">    </span><span class="c">% 3. Generate dependent type</span>
<span class="w">    </span><span class="nv">DepType</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">case</span><span class="w"> </span><span class="p">{</span><span class="nv">BaseType</span><span class="p">,</span><span class="w"> </span><span class="nv">ValueInfo</span><span class="p">}</span><span class="w"> </span><span class="k">of</span>
<span class="w">        </span><span class="p">{{</span><span class="n">list</span><span class="p">,</span><span class="w"> </span><span class="nv">ElemType</span><span class="p">},</span><span class="w"> </span><span class="p">{</span><span class="nb">length</span><span class="p">,</span><span class="w"> </span><span class="nv">N</span><span class="p">}}</span><span class="w"> </span><span class="o">-&gt;</span>
<span class="w">            </span><span class="nl">#dependent_type</span><span class="p">{</span><span class="n">name</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">&#39;Vector&#39;</span><span class="p">,</span><span class="w"> </span><span class="n">type_params</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">[</span><span class="nv">ElemType</span><span class="p">],</span><span class="w"> </span><span class="n">value_params</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">[{</span><span class="n">n</span><span class="p">,</span><span class="w"> </span><span class="nv">N</span><span class="p">}]};</span>
<span class="w">        </span><span class="p">_</span><span class="w"> </span><span class="o">-&gt;</span>
<span class="w">            </span><span class="nv">BaseType</span>
<span class="w">    </span><span class="k">end</span><span class="p">,</span>

<span class="w">    </span><span class="c">% 4. Generate verification conditions</span>
<span class="w">    </span><span class="nv">VCs</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">generate_verification_conditions</span><span class="p">(</span><span class="nv">Expr</span><span class="p">,</span><span class="w"> </span><span class="nv">DepType</span><span class="p">,</span><span class="w"> </span><span class="nv">Env</span><span class="p">),</span>

<span class="w">    </span><span class="c">% 5. Verify via SMT</span>
<span class="w">    </span><span class="k">case</span><span class="w"> </span><span class="n">verify_constraints</span><span class="p">(</span><span class="nv">VCs</span><span class="p">,</span><span class="w"> </span><span class="nv">Env</span><span class="p">)</span><span class="w"> </span><span class="k">of</span>
<span class="w">        </span><span class="p">{</span><span class="n">ok</span><span class="p">,</span><span class="w"> </span><span class="p">_}</span><span class="w"> </span><span class="o">-&gt;</span><span class="w"> </span><span class="p">{</span><span class="nv">DepType</span><span class="p">,</span><span class="w"> </span><span class="nv">Constraints1</span><span class="w"> </span><span class="o">++</span><span class="w"> </span><span class="nv">VCs</span><span class="p">};</span>
<span class="w">        </span><span class="p">{</span><span class="n">error</span><span class="p">,</span><span class="w"> </span><span class="nv">Reason</span><span class="p">}</span><span class="w"> </span><span class="o">-&gt;</span><span class="w"> </span><span class="p">{</span><span class="n">error</span><span class="p">,</span><span class="w"> </span><span class="nv">Reason</span><span class="p">}</span>
<span class="w">    </span><span class="k">end</span><span class="p">.</span>
</code></pre></div>

<hr />
<h2 id="integration-with-existing-system">Integration with Existing System</h2>
<h3 id="phase-1-extend-refinement-types">Phase 1: Extend Refinement Types</h3>
<p>Dependent types as special refinement types:</p>
<div class="codehilite"><pre><span></span><code><span class="c">% Current refinement type</span>
<span class="nl">#refinement_type</span><span class="p">{</span>
<span class="w">    </span><span class="n">base_type</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">{</span><span class="n">primitive</span><span class="p">,</span><span class="w"> </span><span class="n">int</span><span class="p">},</span>
<span class="w">    </span><span class="n">predicate</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nl">#binary_op_expr</span><span class="p">{</span><span class="n">op</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">&#39;&gt;&#39;</span><span class="p">,</span><span class="w"> </span><span class="n">left</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nl">#identifier_expr</span><span class="p">{</span><span class="n">name</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">x</span><span class="p">},</span><span class="w"> </span><span class="n">right</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nl">#literal_expr</span><span class="p">{</span><span class="n">value</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">}}</span>
<span class="p">}</span>

<span class="c">% Extended for dependent types</span>
<span class="nl">#dependent_refinement_type</span><span class="p">{</span>
<span class="w">    </span><span class="n">base_type</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">{</span><span class="n">list</span><span class="p">,</span><span class="w"> </span><span class="nv">T</span><span class="p">},</span>
<span class="w">    </span><span class="n">value_params</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">[{</span><span class="n">n</span><span class="p">,</span><span class="w"> </span><span class="p">{</span><span class="n">primitive</span><span class="p">,</span><span class="w"> </span><span class="n">nat</span><span class="p">}}],</span>
<span class="w">    </span><span class="n">predicate</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nl">#binary_op_expr</span><span class="p">{</span>
<span class="w">        </span><span class="n">op</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">&#39;==&#39;</span><span class="p">,</span>
<span class="w">        </span><span class="n">left</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nl">#function_call_expr</span><span class="p">{</span><span class="n">function</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nb">length</span><span class="p">,</span><span class="w"> </span><span class="n">args</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">[</span><span class="n">this</span><span class="p">]},</span>
<span class="w">        </span><span class="n">right</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nl">#identifier_expr</span><span class="p">{</span><span class="n">name</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">n</span><span class="p">}</span>
<span class="w">    </span><span class="p">}</span>
<span class="p">}</span>
</code></pre></div>

<h3 id="phase-2-type-checker-integration">Phase 2: Type Checker Integration</h3>
<p>Extend <code>cure_typechecker.erl</code>:</p>
<div class="codehilite"><pre><span></span><code><span class="c">% Add to type checking</span>
<span class="nf">check_expr</span><span class="p">(</span><span class="nl">#function_call_expr</span><span class="p">{</span><span class="n">function</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nv">F</span><span class="p">,</span><span class="w"> </span><span class="n">args</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nv">Args</span><span class="p">},</span><span class="w"> </span><span class="nv">ExpectedType</span><span class="p">,</span><span class="w"> </span><span class="nv">Env</span><span class="p">)</span><span class="w"> </span><span class="o">-&gt;</span>
<span class="w">    </span><span class="nv">FType</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">lookup_function_type</span><span class="p">(</span><span class="nv">F</span><span class="p">,</span><span class="w"> </span><span class="nv">Env</span><span class="p">),</span>

<span class="w">    </span><span class="c">% Check if dependent function</span>
<span class="w">    </span><span class="k">case</span><span class="w"> </span><span class="nv">FType</span><span class="w"> </span><span class="k">of</span>
<span class="w">        </span><span class="nl">#dependent_function_type</span><span class="p">{}</span><span class="w"> </span><span class="o">-&gt;</span>
<span class="w">            </span><span class="n">check_dependent_application</span><span class="p">(</span><span class="nv">F</span><span class="p">,</span><span class="w"> </span><span class="nv">Args</span><span class="p">,</span><span class="w"> </span><span class="nv">FType</span><span class="p">,</span><span class="w"> </span><span class="nv">ExpectedType</span><span class="p">,</span><span class="w"> </span><span class="nv">Env</span><span class="p">);</span>
<span class="w">        </span><span class="p">_</span><span class="w"> </span><span class="o">-&gt;</span>
<span class="w">            </span><span class="n">check_regular_application</span><span class="p">(</span><span class="nv">F</span><span class="p">,</span><span class="w"> </span><span class="nv">Args</span><span class="p">,</span><span class="w"> </span><span class="nv">FType</span><span class="p">,</span><span class="w"> </span><span class="nv">ExpectedType</span><span class="p">,</span><span class="w"> </span><span class="nv">Env</span><span class="p">)</span>
<span class="w">    </span><span class="k">end</span><span class="p">.</span>

<span class="nf">check_dependent_application</span><span class="p">(</span><span class="nv">F</span><span class="p">,</span><span class="w"> </span><span class="nv">Args</span><span class="p">,</span><span class="w"> </span><span class="nv">FType</span><span class="p">,</span><span class="w"> </span><span class="nv">ExpectedType</span><span class="p">,</span><span class="w"> </span><span class="nv">Env</span><span class="p">)</span><span class="w"> </span><span class="o">-&gt;</span>
<span class="w">    </span><span class="c">% 1. Infer argument types and extract values</span>
<span class="w">    </span><span class="p">{</span><span class="nv">ArgTypes</span><span class="p">,</span><span class="w"> </span><span class="nv">ArgValues</span><span class="p">}</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nn">lists</span><span class="p">:</span><span class="nf">unzip</span><span class="p">([</span><span class="n">infer_arg</span><span class="p">(</span><span class="nv">A</span><span class="p">,</span><span class="w"> </span><span class="nv">Env</span><span class="p">)</span><span class="w"> </span><span class="p">||</span><span class="w"> </span><span class="nv">A</span><span class="w"> </span><span class="o">&lt;-</span><span class="w"> </span><span class="nv">Args</span><span class="p">]),</span>

<span class="w">    </span><span class="c">% 2. Instantiate dependent type with concrete values</span>
<span class="w">    </span><span class="nv">InstantiatedType</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">instantiate_dependent_type</span><span class="p">(</span><span class="nv">FType</span><span class="p">,</span><span class="w"> </span><span class="nv">ArgValues</span><span class="p">),</span>

<span class="w">    </span><span class="c">% 3. Check subtyping with SMT</span>
<span class="w">    </span><span class="n">check_subtype_smt</span><span class="p">(</span><span class="nv">InstantiatedType</span><span class="p">,</span><span class="w"> </span><span class="nv">ExpectedType</span><span class="p">,</span><span class="w"> </span><span class="nv">Env</span><span class="p">).</span>
</code></pre></div>

<h3 id="phase-3-smt-translator-extension">Phase 3: SMT Translator Extension</h3>
<p>Extend <code>cure_smt_translator.erl</code>:</p>
<div class="codehilite"><pre><span></span><code><span class="c">% Add dependent type translation</span>
<span class="nf">translate_type</span><span class="p">(</span><span class="nl">#dependent_type</span><span class="p">{</span><span class="n">name</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">&#39;Vector&#39;</span><span class="p">,</span><span class="w"> </span><span class="n">type_params</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">[</span><span class="nv">T</span><span class="p">],</span><span class="w"> </span><span class="n">value_params</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">[{</span><span class="n">n</span><span class="p">,</span><span class="w"> </span><span class="p">_}]},</span><span class="w"> </span><span class="nv">Env</span><span class="p">)</span><span class="w"> </span><span class="o">-&gt;</span>
<span class="w">    </span><span class="nv">TElemSort</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">translate_type</span><span class="p">(</span><span class="nv">T</span><span class="p">,</span><span class="w"> </span><span class="nv">Env</span><span class="p">),</span>
<span class="w">    </span><span class="p">[</span>
<span class="w">        </span><span class="s">&quot;(declare-sort &quot;</span><span class="p">,</span><span class="w"> </span><span class="nb">atom_to_list</span><span class="p">(</span><span class="nv">TElemSort</span><span class="p">),</span><span class="w"> </span><span class="s">&quot;)</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
<span class="w">        </span><span class="s">&quot;(declare-fun length (List) Int)</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
<span class="w">        </span><span class="s">&quot;(assert (= (length vec) &quot;</span><span class="p">,</span><span class="w"> </span><span class="n">translate_expr</span><span class="p">(</span><span class="n">n</span><span class="p">,</span><span class="w"> </span><span class="nv">Env</span><span class="p">),</span><span class="w"> </span><span class="s">&quot;))</span><span class="se">\n</span><span class="s">&quot;</span>
<span class="w">    </span><span class="p">].</span>
</code></pre></div>

<hr />
<h2 id="implementation-plan">Implementation Plan</h2>
<h3 id="phase-61-design-current">Phase 6.1: Design (Current)</h3>
<ul>
<li>✅ Design document</li>
<li>✅ Syntax specification</li>
<li>✅ Type system architecture</li>
<li>✅ SMT encoding strategy</li>
</ul>
<h3 id="phase-62-parser-support-week-13">Phase 6.2: Parser Support (Week 13)</h3>
<ul>
<li>Add dependent type syntax to lexer</li>
<li>Extend parser for value parameters</li>
<li>Create AST records</li>
<li>Unit tests for parsing</li>
</ul>
<h3 id="phase-63-type-checking-weeks-14-16">Phase 6.3: Type Checking (Weeks 14-16)</h3>
<ul>
<li>Extend type environment</li>
<li>Implement constraint generation</li>
<li>Add SMT verification</li>
<li>Error reporting with counterexamples</li>
</ul>
<h3 id="phase-64-standard-library-weeks-17-18">Phase 6.4: Standard Library (Weeks 17-18)</h3>
<ul>
<li>Implement <code>Vector</code> module</li>
<li>Add dependent types to <code>List</code> operations</li>
<li>Create examples and documentation</li>
</ul>
<hr />
<h2 id="examples">Examples</h2>
<h3 id="example-1-safe-head">Example 1: Safe Head</h3>
<div class="codehilite"><pre><span></span><code><span class="c">% Current: Runtime error possible</span>
<span class="n">def</span><span class="w"> </span><span class="s">head(xs:</span><span class="w"> </span><span class="s">List(Int)):</span><span class="w"> </span><span class="s">Int</span><span class="w"> </span><span class="p">=</span>
<span class="w">    </span><span class="n">match</span><span class="w"> </span><span class="n">xs</span><span class="w"> </span><span class="n">with</span>
<span class="w">    </span><span class="o">|</span><span class="w"> </span><span class="p">[</span><span class="n">x</span><span class="w"> </span><span class="o">|</span><span class="w"> </span><span class="n">_</span><span class="p">]</span><span class="w"> </span><span class="o">-&gt;</span><span class="w"> </span><span class="n">x</span>
<span class="w">    </span><span class="o">|</span><span class="w"> </span><span class="p">[]</span><span class="w"> </span><span class="o">-&gt;</span><span class="w"> </span><span class="nb">error</span><span class="p">(</span><span class="s">&quot;empty list&quot;</span><span class="p">)</span>
<span class="w">    </span><span class="k">end</span>

<span class="c">% With dependent types: Compile-time safety</span>
<span class="n">def</span><span class="w"> </span><span class="s">head&lt;T,</span><span class="w"> </span><span class="s">n:</span><span class="w"> </span><span class="s">Nat&gt;(xs:</span><span class="w"> </span><span class="s">Vector(T,</span><span class="w"> </span><span class="s">n+1)):</span><span class="w"> </span><span class="s">T</span><span class="w"> </span><span class="p">=</span>
<span class="w">    </span><span class="n">match</span><span class="w"> </span><span class="n">xs</span><span class="w"> </span><span class="n">with</span>
<span class="w">    </span><span class="o">|</span><span class="w"> </span><span class="p">[</span><span class="n">x</span><span class="w"> </span><span class="o">|</span><span class="w"> </span><span class="n">_</span><span class="p">]</span><span class="w"> </span><span class="o">-&gt;</span><span class="w"> </span><span class="n">x</span>
<span class="w">    </span><span class="k">end</span>
<span class="w">    </span><span class="c">% Type system proves xs is non-empty (n+1 &gt;= 1)</span>
</code></pre></div>

<h3 id="example-2-matrix-operations">Example 2: Matrix Operations</h3>
<div class="codehilite"><pre><span></span><code><span class="nb">type</span><span class="w"> </span><span class="n">Matrix</span><span class="p">(</span><span class="n">T</span><span class="p">,</span><span class="w"> </span><span class="n">rows</span><span class="p">:</span><span class="w"> </span><span class="n">Nat</span><span class="p">,</span><span class="w"> </span><span class="n">cols</span><span class="p">:</span><span class="w"> </span><span class="n">Nat</span><span class="p">)</span><span class="w"> </span><span class="p">=</span><span class="w"> </span><span class="n">Vector</span><span class="p">(</span><span class="n">Vector</span><span class="p">(</span><span class="n">T</span><span class="p">,</span><span class="w"> </span><span class="n">cols</span><span class="p">),</span><span class="w"> </span><span class="n">rows</span><span class="p">)</span>

<span class="n">def</span><span class="w"> </span><span class="s">transpose&lt;T,</span><span class="w"> </span><span class="s">m:</span><span class="w"> </span><span class="s">Nat,</span><span class="w"> </span><span class="s">n:</span><span class="w"> </span><span class="s">Nat&gt;(</span>
<span class="w">    </span><span class="n">matrix</span><span class="p">:</span><span class="w"> </span><span class="n">Matrix</span><span class="p">(</span><span class="n">T</span><span class="p">,</span><span class="w"> </span><span class="n">m</span><span class="p">,</span><span class="w"> </span><span class="n">n</span><span class="p">)</span>
<span class="p">):</span><span class="w"> </span><span class="n">Matrix</span><span class="p">(</span><span class="n">T</span><span class="p">,</span><span class="w"> </span><span class="n">n</span><span class="p">,</span><span class="w"> </span><span class="n">m</span><span class="p">)</span><span class="w"> </span><span class="p">=</span>
<span class="w">    </span><span class="c">% Compiler verifies dimensions are correct</span>
<span class="w">    </span><span class="k">...</span>

<span class="n">def</span><span class="w"> </span><span class="s">multiply&lt;T,</span><span class="w"> </span><span class="s">m:</span><span class="w"> </span><span class="s">Nat,</span><span class="w"> </span><span class="s">n:</span><span class="w"> </span><span class="s">Nat,</span><span class="w"> </span><span class="s">p:</span><span class="w"> </span><span class="s">Nat&gt;(</span>
<span class="w">    </span><span class="n">a</span><span class="p">:</span><span class="w"> </span><span class="n">Matrix</span><span class="p">(</span><span class="n">T</span><span class="p">,</span><span class="w"> </span><span class="n">m</span><span class="p">,</span><span class="w"> </span><span class="n">n</span><span class="p">),</span>
<span class="w">    </span><span class="n">b</span><span class="p">:</span><span class="w"> </span><span class="n">Matrix</span><span class="p">(</span><span class="n">T</span><span class="p">,</span><span class="w"> </span><span class="n">n</span><span class="p">,</span><span class="w"> </span><span class="n">p</span><span class="p">)</span>
<span class="p">):</span><span class="w"> </span><span class="n">Matrix</span><span class="p">(</span><span class="n">T</span><span class="p">,</span><span class="w"> </span><span class="n">m</span><span class="p">,</span><span class="w"> </span><span class="n">p</span><span class="p">)</span><span class="w"> </span><span class="p">=</span>
<span class="w">    </span><span class="c">% Compiler checks: a.cols == b.rows</span>
<span class="w">    </span><span class="k">...</span>
</code></pre></div>

<h3 id="example-3-bounded-integers">Example 3: Bounded Integers</h3>
<div class="codehilite"><pre><span></span><code><span class="k">type</span><span class="w"> </span><span class="nx">Percentage</span><span class="w"> </span><span class="p">=</span><span class="w"> </span><span class="nx">Int</span><span class="w"> </span><span class="k">where</span><span class="w"> </span><span class="mi">0</span><span class="w"> </span><span class="o">&lt;=</span><span class="w"> </span><span class="nx">this</span><span class="w"> </span><span class="o">&lt;=</span><span class="w"> </span><span class="mi">100</span>
<span class="k">type</span><span class="w"> </span><span class="nx">Index</span><span class="p">(</span><span class="nx">n</span><span class="p">:</span><span class="w"> </span><span class="nx">Nat</span><span class="p">)</span><span class="w"> </span><span class="p">=</span><span class="w"> </span><span class="nx">Int</span><span class="w"> </span><span class="k">where</span><span class="w"> </span><span class="mi">0</span><span class="w"> </span><span class="o">&lt;=</span><span class="w"> </span><span class="nx">this</span><span class="w"> </span><span class="p">&lt;</span><span class="w"> </span><span class="nx">n</span>

<span class="nx">def</span><span class="w"> </span><span class="nx">get_percentage</span><span class="p">(</span><span class="nx">value</span><span class="p">:</span><span class="w"> </span><span class="nx">Int</span><span class="p">,</span><span class="w"> </span><span class="nx">total</span><span class="p">:</span><span class="w"> </span><span class="nx">Int</span><span class="w"> </span><span class="k">where</span><span class="w"> </span><span class="nx">total</span><span class="w"> </span><span class="p">&gt;</span><span class="w"> </span><span class="mi">0</span><span class="p">):</span><span class="w"> </span><span class="nx">Percentage</span><span class="w"> </span><span class="p">=</span>
<span class="w">    </span><span class="p">(</span><span class="nx">value</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="mi">100</span><span class="p">)</span><span class="w"> </span><span class="o">/</span><span class="w"> </span><span class="nx">total</span><span class="w">  </span><span class="o">%</span><span class="w"> </span><span class="nx">Compiler</span><span class="w"> </span><span class="nx">proves</span><span class="w"> </span><span class="nx">result</span><span class="w"> </span><span class="k">is</span><span class="w"> </span><span class="k">in</span><span class="w"> </span><span class="p">[</span><span class="mi">0</span><span class="p">,</span><span class="w"> </span><span class="mi">100</span><span class="p">]</span>

<span class="nx">def</span><span class="w"> </span><span class="nx">safe_nth</span><span class="p">&lt;</span><span class="nx">T</span><span class="p">,</span><span class="w"> </span><span class="nx">n</span><span class="p">:</span><span class="w"> </span><span class="nx">Nat</span><span class="p">&gt;(</span><span class="nx">xs</span><span class="p">:</span><span class="w"> </span><span class="nx">Vector</span><span class="p">(</span><span class="nx">T</span><span class="p">,</span><span class="w"> </span><span class="nx">n</span><span class="p">),</span><span class="w"> </span><span class="nx">i</span><span class="p">:</span><span class="w"> </span><span class="nx">Index</span><span class="p">(</span><span class="nx">n</span><span class="p">)):</span><span class="w"> </span><span class="nx">T</span><span class="w"> </span><span class="p">=</span>
<span class="w">    </span><span class="nx">nth</span><span class="p">(</span><span class="nx">xs</span><span class="p">,</span><span class="w"> </span><span class="nx">i</span><span class="p">)</span><span class="w">  </span><span class="o">%</span><span class="w"> </span><span class="nx">No</span><span class="w"> </span><span class="nx">bounds</span><span class="w"> </span><span class="nx">check</span><span class="w"> </span><span class="nx">needed</span><span class="p">!</span>
</code></pre></div>

<h3 id="example-4-fsm-with-invariants">Example 4: FSM with Invariants</h3>
<div class="codehilite"><pre><span></span><code><span class="n">fsm</span><span class="w"> </span><span class="n">BankAccount</span><span class="w"> </span><span class="n">do</span>
<span class="w">    </span><span class="n">type</span><span class="w"> </span><span class="n">Balance</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">Int</span><span class="w"> </span><span class="n">where</span><span class="w"> </span><span class="n">this</span><span class="w"> </span><span class="o">&gt;=</span><span class="w"> </span><span class="mi">0</span>

<span class="w">    </span><span class="n">payload</span><span class="p">:</span><span class="w"> </span><span class="p">{</span><span class="n">balance</span><span class="p">:</span><span class="w"> </span><span class="n">Balance</span><span class="p">}</span>

<span class="w">    </span><span class="n">state</span><span class="w"> </span><span class="n">Active</span><span class="p">(</span><span class="n">balance</span><span class="p">:</span><span class="w"> </span><span class="n">Balance</span><span class="p">)</span><span class="w"> </span><span class="n">do</span>
<span class="w">        </span><span class="n">on</span><span class="w"> </span><span class="n">deposit</span><span class="p">(</span><span class="n">amount</span><span class="p">:</span><span class="w"> </span><span class="n">Int</span><span class="w"> </span><span class="n">where</span><span class="w"> </span><span class="n">amount</span><span class="w"> </span><span class="o">&gt;</span><span class="w"> </span><span class="mi">0</span><span class="p">)</span><span class="w"> </span><span class="o">-&gt;</span>
<span class="w">            </span><span class="n">Active</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="n">balance</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">balance</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">amount</span><span class="w"> </span><span class="p">}</span>
<span class="w">            </span><span class="o">%</span><span class="w"> </span><span class="n">Compiler</span><span class="w"> </span><span class="n">proves</span><span class="p">:</span><span class="w"> </span><span class="n">balance</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">amount</span><span class="w"> </span><span class="o">&gt;=</span><span class="w"> </span><span class="mi">0</span>

<span class="w">        </span><span class="n">on</span><span class="w"> </span><span class="n">withdraw</span><span class="p">(</span><span class="n">amount</span><span class="p">:</span><span class="w"> </span><span class="n">Int</span><span class="w"> </span><span class="n">where</span><span class="w"> </span><span class="n">amount</span><span class="w"> </span><span class="o">&lt;=</span><span class="w"> </span><span class="n">balance</span><span class="p">)</span><span class="w"> </span><span class="o">-&gt;</span>
<span class="w">            </span><span class="n">Active</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="n">balance</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">balance</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="n">amount</span><span class="w"> </span><span class="p">}</span>
<span class="w">            </span><span class="o">%</span><span class="w"> </span><span class="n">Compiler</span><span class="w"> </span><span class="n">proves</span><span class="p">:</span><span class="w"> </span><span class="n">balance</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="n">amount</span><span class="w"> </span><span class="o">&gt;=</span><span class="w"> </span><span class="mi">0</span>
<span class="w">    </span><span class="n">end</span>
<span class="n">end</span>
</code></pre></div>

<hr />
<h2 id="open-questions">Open Questions</h2>
<h3 id="q1-type-level-computation">Q1: Type-Level Computation</h3>
<p>How much computation do we allow at the type level?</p>
<p><strong>Options</strong>:<br />
1. <strong>Limited</strong> (current design): Only arithmetic and comparisons<br />
2. <strong>Extended</strong>: Allow arbitrary pure functions<br />
3. <strong>Full</strong>: Full dependent types with proof terms</p>
<p><strong>Decision</strong>: Start with Limited (Option 1), extend if needed.</p>
<h3 id="q2-inference-vs-annotation">Q2: Inference vs. Annotation</h3>
<p>How much type inference should we provide?</p>
<p><strong>Options</strong>:<br />
1. <strong>Explicit</strong>: All dependent types must be annotated<br />
2. <strong>Partial</strong>: Infer some cases (e.g., list append)<br />
3. <strong>Full</strong>: Infer all dependent types</p>
<p><strong>Decision</strong>: Start with Partial (Option 2) - infer simple cases, require annotations for complex ones.</p>
<h3 id="q3-subtyping">Q3: Subtyping</h3>
<p>How do dependent types interact with subtyping?</p>
<div class="codehilite"><pre><span></span><code><span class="c">% Is Vector(Int, 5) a subtype of Vector(Int, n) where n &gt;= 5?</span>
<span class="c">% Or Vector(Int, n) where n &gt; 0?</span>
</code></pre></div>

<p><strong>Decision</strong>: Use SMT to check subtyping constraints case-by-case.</p>
<hr />
<h2 id="success-criteria">Success Criteria</h2>
<ul>
<li>✅ Can express length-indexed vectors</li>
<li>✅ Compiler proves array bounds safety</li>
<li>✅ Can implement safe <code>head</code>, <code>tail</code>, <code>nth</code> operations</li>
<li>✅ Matrix dimensions verified at compile time</li>
<li>✅ 30+ dependent type tests passing</li>
<li>✅ Performance: &lt;1s verification for typical functions</li>
<li>✅ Documentation and examples complete</li>
</ul>
<hr />
<h2 id="references">References</h2>
<ol>
<li><strong>Liquid Types</strong>: Refinement types for Haskell (LiquidHaskell)</li>
<li><strong>Dependent Types</strong>: Full dependent types (Agda, Idris, Coq)</li>
<li><strong>Hybrid Types</strong>: Combining refinement and dependent types (F*)</li>
<li><strong>SMT-based Verification</strong>: Using Z3 for type checking</li>
</ol>
<hr />
<p><strong>Next Steps</strong>: Begin Phase 6.2 (Parser Support)</p>
    </div>

    <!-- Footer -->
    <footer class="site-footer">
        <div class="footer-content">
            <div class="footer-section">
                <h4>Documentation</h4>
                <ul>
                    <li><a href="../docs.html">Getting Started</a></li>
                    <li><a href="language-spec.html">Language Specification</a></li>
                    <li><a href="type-system.html">Type System</a></li>
                    <li><a href="fsm-usage.html">FSM Guide</a></li>
                </ul>
            </div>

            <div class="footer-section">
                <h4>Reference</h4>
                <ul>
                    <li><a href="../api/index.html">API Reference</a></li>
                    <li><a href="std-summary.html">Standard Library</a></li>
                    <li><a href="feature-reference.html">Feature Reference</a></li>
                    <li><a href="cli-usage.html">CLI Usage</a></li>
                </ul>
            </div>

            <div class="footer-section">
                <h4>Resources</h4>
                <ul>
                    <li><a href="editor-setup.html">Editor Setup</a></li>
                    <li><a href="project-overview.html">Project Overview</a></li>
                    <li><a href="cure-ultimate-description.html">Ultimate Guide</a></li>
                </ul>
            </div>
        </div>

        <div class="footer-bottom">
            <p>&copy; 2025 Cure Programming Language. Verification-first programming for the BEAM.</p>
        </div>
    </footer>
    <!-- Syntax Highlighting -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.11.1/highlight.min.js"></script>
    <script src="../js/cure-language.js"></script>
    <script>
        // Initialize highlight.js and highlight all code blocks
        hljs.highlightAll();
    </script>
</body>
</html>
