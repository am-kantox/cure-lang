<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Automatic Typeclass Derivation in Cure - Cure Documentation</title>
    <meta name="description" content=" Overview">
    <link rel="icon" type="image/png" href="../media/logo-128x128.png">
    <link rel="stylesheet" href="../css/style.css">
</head>
<body>
    <!-- Header -->
    <header class="site-header">
        <div class="nav-container">
            <div class="logo-section">
                <img src="../media/logo-128x128.png" alt="Cure Logo" class="logo">
                <div>
                    <h1 class="site-title">Cure</h1>
                    <p class="site-tagline">Verification-First Programming</p>
                </div>
            </div>
            <nav class="main-nav">
                <ul>
                    <li><a href="../index.html">Home</a></li>
                    <li><a href="../docs.html">Documentation</a></li>
                    <li><a href="../api/index.html">API Reference</a></li>
                </ul>
            </nav>
        </div>
    </header>

    <!-- Main Content -->
    <div class="doc-page">
        <div class="doc-nav">
            <a href="../docs.html">← Back to Documentation</a>
        </div>
        
        <h1 id="automatic-typeclass-derivation-in-cure">Automatic Typeclass Derivation in Cure</h1>
<h2 id="overview">Overview</h2>
<p>Cure supports automatic derivation of typeclass instances for user-defined types using the <code>derive</code> clause. This feature eliminates boilerplate code and ensures consistency across your codebase.</p>
<h2 id="syntax">Syntax</h2>
<h3 id="basic-derivation">Basic Derivation</h3>
<div class="codehilite"><pre><span></span><code><span class="nv">record</span><span class="w"> </span><span class="nv">Point</span><span class="w"> </span><span class="k">do</span>
<span class="w">    </span><span class="nv">x</span>:<span class="w"> </span><span class="nv">Int</span>
<span class="w">    </span><span class="nv">y</span>:<span class="w"> </span><span class="nv">Int</span>
<span class="k">end</span>
<span class="nv">derive</span><span class="w"> </span><span class="k">Show</span>,<span class="w"> </span><span class="nv">Eq</span>,<span class="w"> </span><span class="nv">Ord</span>
</code></pre></div>

<p>This automatically generates instances for <code>Show(Point)</code>, <code>Eq(Point)</code>, and <code>Ord(Point)</code>.</p>
<h3 id="derivation-with-type-parameters">Derivation with Type Parameters</h3>
<div class="codehilite"><pre><span></span><code><span class="nv">record</span><span class="w"> </span><span class="nv">Container</span><span class="ss">(</span><span class="nv">T</span><span class="ss">)</span><span class="w"> </span><span class="k">do</span>
<span class="w">    </span><span class="nv">value</span>:<span class="w"> </span><span class="nv">T</span>
<span class="w">    </span><span class="nv">name</span>:<span class="w"> </span><span class="nv">String</span>
<span class="k">end</span>
<span class="nv">derive</span><span class="w"> </span><span class="k">Show</span>,<span class="w"> </span><span class="nv">Eq</span>
</code></pre></div>

<p>When deriving for parameterized types, the compiler automatically adds constraints:</p>
<div class="codehilite"><pre><span></span><code><span class="c">% Generated instances:</span>
<span class="n">instance</span><span class="w"> </span><span class="s">Show(Container(T))</span><span class="w"> </span><span class="s">where</span><span class="w"> </span><span class="s">Show(T)</span><span class="w"> </span><span class="s">do</span>
<span class="w">    </span><span class="n">def</span><span class="w"> </span><span class="n">show</span><span class="p">(</span><span class="n">c</span><span class="p">:</span><span class="w"> </span><span class="n">Container</span><span class="p">(</span><span class="n">T</span><span class="p">)):</span><span class="w"> </span><span class="n">String</span><span class="w"> </span><span class="p">=</span><span class="w"> </span><span class="k">...</span>
<span class="k">end</span>

<span class="n">instance</span><span class="w"> </span><span class="s">Eq(Container(T))</span><span class="w"> </span><span class="s">where</span><span class="w"> </span><span class="s">Eq(T)</span><span class="w"> </span><span class="s">do</span>
<span class="w">    </span><span class="n">def</span><span class="w"> </span><span class="o">==</span><span class="p">(</span><span class="n">c1</span><span class="p">:</span><span class="w"> </span><span class="n">Container</span><span class="p">(</span><span class="n">T</span><span class="p">),</span><span class="w"> </span><span class="n">c2</span><span class="p">:</span><span class="w"> </span><span class="n">Container</span><span class="p">(</span><span class="n">T</span><span class="p">)):</span><span class="w"> </span><span class="n">Bool</span><span class="w"> </span><span class="p">=</span><span class="w"> </span><span class="k">...</span>
<span class="k">end</span>
</code></pre></div>

<h2 id="supported-typeclasses">Supported Typeclasses</h2>
<h3 id="show">Show</h3>
<p>Derives a string representation of the type:</p>
<div class="codehilite"><pre><span></span><code><span class="nb">record</span><span class="w"> </span><span class="n">Person</span><span class="w"> </span><span class="n">do</span>
<span class="w">    </span><span class="n">name</span><span class="p">:</span><span class="w"> </span><span class="n">String</span>
<span class="w">    </span><span class="n">age</span><span class="p">:</span><span class="w"> </span><span class="n">Int</span>
<span class="k">end</span>
<span class="n">derive</span><span class="w"> </span><span class="s">Show</span>

<span class="c">% Usage:</span>
<span class="n">let</span><span class="w"> </span><span class="s">p</span><span class="w"> </span><span class="p">=</span><span class="w"> </span><span class="n">Person</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="n">name</span><span class="p">:</span><span class="w"> </span><span class="s">&quot;Alice&quot;</span><span class="p">,</span><span class="w"> </span><span class="n">age</span><span class="p">:</span><span class="w"> </span><span class="mi">30</span><span class="w"> </span><span class="p">}</span>
<span class="n">show</span><span class="p">(</span><span class="n">p</span><span class="p">)</span><span class="w">  </span><span class="c">% &quot;Person { name: \&quot;Alice\&quot;, age: 30 }&quot;</span>
</code></pre></div>

<p><strong>Generated Implementation:</strong><br />
- Records: <code>TypeName { field1: show(value1), field2: show(value2), ... }</code><br />
- Shows all fields in declaration order</p>
<h3 id="eq">Eq</h3>
<p>Derives structural equality checking:</p>
<div class="codehilite"><pre><span></span><code><span class="nb">record</span><span class="w"> </span><span class="n">Point</span><span class="w"> </span><span class="n">do</span>
<span class="w">    </span><span class="n">x</span><span class="p">:</span><span class="w"> </span><span class="n">Int</span>
<span class="w">    </span><span class="n">y</span><span class="p">:</span><span class="w"> </span><span class="n">Int</span>
<span class="k">end</span>
<span class="n">derive</span><span class="w"> </span><span class="s">Eq</span>

<span class="c">% Usage:</span>
<span class="n">let</span><span class="w"> </span><span class="s">p1</span><span class="w"> </span><span class="p">=</span><span class="w"> </span><span class="n">Point</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="n">x</span><span class="p">:</span><span class="w"> </span><span class="mi">10</span><span class="p">,</span><span class="w"> </span><span class="n">y</span><span class="p">:</span><span class="w"> </span><span class="mi">20</span><span class="w"> </span><span class="p">}</span>
<span class="n">let</span><span class="w"> </span><span class="s">p2</span><span class="w"> </span><span class="p">=</span><span class="w"> </span><span class="n">Point</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="n">x</span><span class="p">:</span><span class="w"> </span><span class="mi">10</span><span class="p">,</span><span class="w"> </span><span class="n">y</span><span class="p">:</span><span class="w"> </span><span class="mi">20</span><span class="w"> </span><span class="p">}</span>
<span class="n">p1</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="n">p2</span><span class="w">  </span><span class="c">% true</span>
</code></pre></div>

<p><strong>Generated Implementation:</strong><br />
- Implements <code>==</code> operator<br />
- Default <code>!=</code> provided by typeclass<br />
- Compares all fields for equality</p>
<h3 id="ord">Ord</h3>
<p>Derives lexicographic ordering:</p>
<div class="codehilite"><pre><span></span><code><span class="nb">record</span><span class="w"> </span><span class="n">Person</span><span class="w"> </span><span class="n">do</span>
<span class="w">    </span><span class="n">name</span><span class="p">:</span><span class="w"> </span><span class="n">String</span>
<span class="w">    </span><span class="n">age</span><span class="p">:</span><span class="w"> </span><span class="n">Int</span>
<span class="k">end</span>
<span class="n">derive</span><span class="w"> </span><span class="s">Ord</span><span class="w">  </span><span class="s">%</span><span class="w"> </span><span class="s">Requires</span><span class="w"> </span><span class="s">Eq</span><span class="w"> </span><span class="s">as</span><span class="w"> </span><span class="s">superclass</span>

<span class="c">% Usage:</span>
<span class="n">let</span><span class="w"> </span><span class="s">alice</span><span class="w"> </span><span class="p">=</span><span class="w"> </span><span class="n">Person</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="n">name</span><span class="p">:</span><span class="w"> </span><span class="s">&quot;Alice&quot;</span><span class="p">,</span><span class="w"> </span><span class="n">age</span><span class="p">:</span><span class="w"> </span><span class="mi">30</span><span class="w"> </span><span class="p">}</span>
<span class="n">let</span><span class="w"> </span><span class="s">bob</span><span class="w"> </span><span class="p">=</span><span class="w"> </span><span class="n">Person</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="n">name</span><span class="p">:</span><span class="w"> </span><span class="s">&quot;Bob&quot;</span><span class="p">,</span><span class="w"> </span><span class="n">age</span><span class="p">:</span><span class="w"> </span><span class="mi">25</span><span class="w"> </span><span class="p">}</span>

<span class="n">match</span><span class="w"> </span><span class="s">compare(alice,</span><span class="w"> </span><span class="s">bob)</span><span class="w"> </span><span class="s">do</span>
<span class="w">    </span><span class="n">LT</span><span class="w"> </span><span class="o">-&gt;</span><span class="w"> </span><span class="s">&quot;Alice comes before Bob&quot;</span>
<span class="w">    </span><span class="n">EQ</span><span class="w"> </span><span class="o">-&gt;</span><span class="w"> </span><span class="s">&quot;Equal&quot;</span>
<span class="w">    </span><span class="n">GT</span><span class="w"> </span><span class="o">-&gt;</span><span class="w"> </span><span class="s">&quot;Alice comes after Bob&quot;</span>
<span class="k">end</span>
</code></pre></div>

<p><strong>Generated Implementation:</strong><br />
- Implements <code>compare</code> method returning <code>Ordering</code> (LT, EQ, or GT)<br />
- Compares fields in declaration order (lexicographic)<br />
- Automatically adds <code>Eq</code> constraint</p>
<h2 id="constraint-inference">Constraint Inference</h2>
<p>The derive mechanism automatically infers required constraints for parameterized types:</p>
<div class="codehilite"><pre><span></span><code><span class="nb">record</span><span class="w"> </span><span class="n">Pair</span><span class="p">(</span><span class="n">A</span><span class="p">,</span><span class="w"> </span><span class="n">B</span><span class="p">)</span><span class="w"> </span><span class="n">do</span>
<span class="w">    </span><span class="n">first</span><span class="p">:</span><span class="w"> </span><span class="n">A</span>
<span class="w">    </span><span class="nb">second</span><span class="p">:</span><span class="w"> </span><span class="n">B</span>
<span class="k">end</span>
<span class="n">derive</span><span class="w"> </span><span class="s">Show,</span><span class="w"> </span><span class="s">Eq</span>

<span class="c">% Compiler generates:</span>
<span class="c">% instance Show(Pair(A, B)) where Show(A), Show(B) do ... end</span>
<span class="c">% instance Eq(Pair(A, B)) where Eq(A), Eq(B) do ... end</span>
</code></pre></div>

<p><strong>Rules:</strong><br />
1. For each type variable in fields, add corresponding constraint<br />
2. Primitive types (Int, String, etc.) don't require constraints<br />
3. Nested parameterized types require constraints for their parameters</p>
<h2 id="when-to-use-manual-instances">When to Use Manual Instances</h2>
<p>While derivation is convenient, sometimes you need custom behavior:</p>
<h3 id="custom-show-format">Custom Show Format</h3>
<div class="codehilite"><pre><span></span><code><span class="nb">record</span><span class="w"> </span><span class="n">Temperature</span><span class="w"> </span><span class="n">do</span>
<span class="w">    </span><span class="n">celsius</span><span class="p">:</span><span class="w"> </span><span class="n">Float</span>
<span class="k">end</span>

<span class="c">% Manual instance for custom formatting</span>
<span class="n">instance</span><span class="w"> </span><span class="s">Show(Temperature)</span><span class="w"> </span><span class="s">do</span>
<span class="w">    </span><span class="n">def</span><span class="w"> </span><span class="n">show</span><span class="p">(</span><span class="n">t</span><span class="p">:</span><span class="w"> </span><span class="n">Temperature</span><span class="p">):</span><span class="w"> </span><span class="n">String</span><span class="w"> </span><span class="p">=</span>
<span class="w">        </span><span class="n">float_to_string</span><span class="p">(</span><span class="n">t</span><span class="p">.</span><span class="n">celsius</span><span class="p">)</span><span class="w"> </span><span class="o">++</span><span class="w"> </span><span class="s">&quot;°C&quot;</span>
<span class="k">end</span>
</code></pre></div>

<h3 id="custom-equality">Custom Equality</h3>
<div class="codehilite"><pre><span></span><code><span class="nb">record</span><span class="w"> </span><span class="n">Person</span><span class="w"> </span><span class="n">do</span>
<span class="w">    </span><span class="n">id</span><span class="p">:</span><span class="w"> </span><span class="n">Int</span>
<span class="w">    </span><span class="n">name</span><span class="p">:</span><span class="w"> </span><span class="n">String</span>
<span class="w">    </span><span class="n">metadata</span><span class="p">:</span><span class="w"> </span><span class="n">Map</span><span class="p">(</span><span class="n">String</span><span class="p">,</span><span class="w"> </span><span class="n">String</span><span class="p">)</span>
<span class="k">end</span>

<span class="c">% Derive Show but manually implement Eq (compare only by ID)</span>
<span class="n">derive</span><span class="w"> </span><span class="s">Show</span>

<span class="n">instance</span><span class="w"> </span><span class="s">Eq(Person)</span><span class="w"> </span><span class="s">do</span>
<span class="w">    </span><span class="n">def</span><span class="w"> </span><span class="o">==</span><span class="p">(</span><span class="n">p1</span><span class="p">:</span><span class="w"> </span><span class="n">Person</span><span class="p">,</span><span class="w"> </span><span class="n">p2</span><span class="p">:</span><span class="w"> </span><span class="n">Person</span><span class="p">):</span><span class="w"> </span><span class="n">Bool</span><span class="w"> </span><span class="p">=</span>
<span class="w">        </span><span class="n">p1</span><span class="p">.</span><span class="n">id</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="n">p2</span><span class="p">.</span><span class="n">id</span><span class="w">  </span><span class="c">% Ignore name and metadata</span>
<span class="k">end</span>
</code></pre></div>

<h3 id="custom-ordering">Custom Ordering</h3>
<div class="codehilite"><pre><span></span><code><span class="nb">record</span><span class="w"> </span><span class="n">Task</span><span class="w"> </span><span class="n">do</span>
<span class="w">    </span><span class="n">priority</span><span class="p">:</span><span class="w"> </span><span class="n">Int</span>
<span class="w">    </span><span class="n">name</span><span class="p">:</span><span class="w"> </span><span class="n">String</span>
<span class="w">    </span><span class="n">deadline</span><span class="p">:</span><span class="w"> </span><span class="n">Timestamp</span>
<span class="k">end</span>

<span class="n">derive</span><span class="w"> </span><span class="s">Show,</span><span class="w"> </span><span class="s">Eq</span>

<span class="c">% Custom ordering by priority, then deadline</span>
<span class="n">instance</span><span class="w"> </span><span class="s">Ord(Task)</span><span class="w"> </span><span class="s">do</span>
<span class="w">    </span><span class="n">def</span><span class="w"> </span><span class="n">compare</span><span class="p">(</span><span class="n">t1</span><span class="p">:</span><span class="w"> </span><span class="n">Task</span><span class="p">,</span><span class="w"> </span><span class="n">t2</span><span class="p">:</span><span class="w"> </span><span class="n">Task</span><span class="p">):</span><span class="w"> </span><span class="n">Ordering</span><span class="w"> </span><span class="p">=</span>
<span class="w">        </span><span class="n">match</span><span class="w"> </span><span class="n">compare</span><span class="p">(</span><span class="n">t1</span><span class="p">.</span><span class="n">priority</span><span class="p">,</span><span class="w"> </span><span class="n">t2</span><span class="p">.</span><span class="n">priority</span><span class="p">)</span><span class="w"> </span><span class="n">do</span>
<span class="w">            </span><span class="n">EQ</span><span class="w"> </span><span class="o">-&gt;</span><span class="w"> </span><span class="n">compare</span><span class="p">(</span><span class="n">t1</span><span class="p">.</span><span class="n">deadline</span><span class="p">,</span><span class="w"> </span><span class="n">t2</span><span class="p">.</span><span class="n">deadline</span><span class="p">)</span>
<span class="w">            </span><span class="n">result</span><span class="w"> </span><span class="o">-&gt;</span><span class="w"> </span><span class="n">result</span>
<span class="w">        </span><span class="k">end</span>
<span class="k">end</span>
</code></pre></div>

<h2 id="limitations-and-constraints">Limitations and Constraints</h2>
<h3 id="what-can-be-derived">What Can Be Derived</h3>
<ul>
<li>✅ Records with concrete field types</li>
<li>✅ Records with type parameters</li>
<li>✅ Nested records</li>
<li>✅ Empty records (unit types)</li>
</ul>
<h3 id="what-cannot-be-derived">What Cannot Be Derived</h3>
<ul>
<li>❌ Function types</li>
<li>❌ FSM types</li>
<li>❌ Recursive types (requires manual implementation)</li>
<li>❌ Types with existential quantification</li>
</ul>
<h3 id="typeclass-support">Typeclass Support</h3>
<p>Currently supported:<br />
- <code>Show</code> - String representation<br />
- <code>Eq</code> - Equality testing<br />
- <code>Ord</code> - Ordering/comparison</p>
<p>Not yet supported:<br />
- <code>Functor</code> - Requires higher-kinded types<br />
- <code>Monad</code> - Requires higher-kinded types<br />
- <code>Semigroup</code> / <code>Monoid</code> - Requires domain knowledge</p>
<h2 id="complete-examples">Complete Examples</h2>
<h3 id="basic-usage">Basic Usage</h3>
<div class="codehilite"><pre><span></span><code><span class="k">module</span> <span class="n">geometry</span>

<span class="n">record</span> <span class="n">Point</span> <span class="nb">do</span>
    <span class="o">x</span>: <span class="n">Float</span>
    <span class="n">y:</span> <span class="n">Float</span>
<span class="nb">end</span>
<span class="n">derive</span> <span class="n">Show</span>, <span class="n">Eq</span>

<span class="n">def</span> <span class="n">distance</span>(<span class="n">p1:</span> <span class="n">Point</span>, <span class="n">p2:</span> <span class="n">Point</span>): <span class="n">Float</span> =
    <span class="k">let</span> <span class="n">dx</span> = <span class="n">p1</span>.<span class="nb">x</span> - <span class="n">p2</span>.<span class="nb">x</span>
    <span class="k">let</span> <span class="n">dy</span> = <span class="n">p1</span>.<span class="n">y</span> - <span class="n">p2</span>.<span class="n">y</span>
    <span class="nb">sqrt</span>(<span class="n">dx</span> * <span class="n">dx</span> + <span class="n">dy</span> * <span class="n">dy</span>)

<span class="n">def</span> <span class="n">main</span>(): <span class="n">Unit</span> =
    <span class="k">let</span> <span class="n">origin</span> = <span class="n">Point</span> { <span class="o">x</span>: <span class="mf">0.0</span>, <span class="n">y:</span> <span class="mf">0.0</span> }
    <span class="k">let</span> <span class="n">p</span> = <span class="n">Point</span> { <span class="o">x</span>: <span class="mf">3.0</span>, <span class="n">y:</span> <span class="mf">4.0</span> }

    <span class="n">println</span>(<span class="n">show</span>(<span class="n">origin</span>))  % <span class="s">&quot;Point { x: 0.0, y: 0.0 }&quot;</span>
    <span class="n">println</span>(<span class="n">show</span>(<span class="n">p</span>))       % <span class="s">&quot;Point { x: 3.0, y: 4.0 }&quot;</span>

    <span class="k">if</span> <span class="n">origin</span> == <span class="n">p</span> <span class="nb">then</span>
        <span class="n">println</span>(<span class="s">&quot;Points are equal&quot;</span>)
    <span class="k">else</span>
        <span class="k">let</span> <span class="n">dist</span> = <span class="n">distance</span>(<span class="n">origin</span>, <span class="n">p</span>)
        <span class="n">println</span>(<span class="s">&quot;Distance: &quot;</span> ++ <span class="n">show</span>(<span class="n">dist</span>))
    <span class="nb">end</span>
</code></pre></div>

<h3 id="parameterized-types">Parameterized Types</h3>
<div class="codehilite"><pre><span></span><code><span class="k">module</span> <span class="n">collections</span>

<span class="n">record</span> <span class="n">Box</span>(<span class="n">T</span>) <span class="nb">do</span>
    <span class="n">value:</span> <span class="n">T</span>
<span class="nb">end</span>
<span class="n">derive</span> <span class="n">Show</span>, <span class="n">Eq</span>

<span class="n">def</span> <span class="n">map_box</span>(<span class="n">f:</span> <span class="n">T</span> -&gt; <span class="n">U</span>, <span class="n">box:</span> <span class="n">Box</span>(<span class="n">T</span>)): <span class="n">Box</span>(<span class="n">U</span>) =
    <span class="n">Box</span> { <span class="n">value:</span> <span class="nb">f</span>(<span class="n">box</span>.<span class="nb">value</span>) }

<span class="n">def</span> <span class="n">main</span>(): <span class="n">Unit</span> <span class="n">where</span> <span class="n">Show</span>(<span class="nb">Int</span>), <span class="n">Show</span>(<span class="n">String</span>) =
    <span class="k">let</span> <span class="n">int_box</span> = <span class="n">Box</span> { <span class="n">value:</span> <span class="mi">42</span> }
    <span class="k">let</span> <span class="n">str_box</span> = <span class="n">map_box</span>(<span class="n">int_to_string</span>, <span class="n">int_box</span>)

    <span class="n">println</span>(<span class="n">show</span>(<span class="n">int_box</span>))  % <span class="s">&quot;Box { value: 42 }&quot;</span>
    <span class="n">println</span>(<span class="n">show</span>(<span class="n">str_box</span>))  % <span class="s">&quot;Box { value: \&quot;42\&quot; }&quot;</span>
</code></pre></div>

<h3 id="hierarchical-data">Hierarchical Data</h3>
<div class="codehilite"><pre><span></span><code><span class="nx">module</span><span class="w"> </span><span class="nx">organization</span>

<span class="nx">record</span><span class="w"> </span><span class="nx">Address</span><span class="w"> </span><span class="nx">do</span>
<span class="w">    </span><span class="nx">street</span><span class="p">:</span><span class="w"> </span><span class="nx">String</span>
<span class="w">    </span><span class="nx">city</span><span class="p">:</span><span class="w"> </span><span class="nx">String</span>
<span class="w">    </span><span class="nx">country</span><span class="p">:</span><span class="w"> </span><span class="nx">String</span>
<span class="nx">end</span>
<span class="nx">derive</span><span class="w"> </span><span class="nx">Show</span><span class="p">,</span><span class="w"> </span><span class="nx">Eq</span>

<span class="nx">record</span><span class="w"> </span><span class="nx">Person</span><span class="w"> </span><span class="nx">do</span>
<span class="w">    </span><span class="nx">name</span><span class="p">:</span><span class="w"> </span><span class="nx">String</span>
<span class="w">    </span><span class="nx">age</span><span class="p">:</span><span class="w"> </span><span class="nx">Int</span>
<span class="w">    </span><span class="nx">address</span><span class="p">:</span><span class="w"> </span><span class="nx">Address</span>
<span class="nx">end</span>
<span class="nx">derive</span><span class="w"> </span><span class="nx">Show</span><span class="p">,</span><span class="w"> </span><span class="nx">Eq</span><span class="p">,</span><span class="w"> </span><span class="nx">Ord</span>

<span class="nx">record</span><span class="w"> </span><span class="nx">Department</span><span class="w"> </span><span class="nx">do</span>
<span class="w">    </span><span class="nx">name</span><span class="p">:</span><span class="w"> </span><span class="nx">String</span>
<span class="w">    </span><span class="nx">manager</span><span class="p">:</span><span class="w"> </span><span class="nx">Person</span>
<span class="w">    </span><span class="nx">employees</span><span class="p">:</span><span class="w"> </span><span class="nx">List</span><span class="p">(</span><span class="nx">Person</span><span class="p">)</span>
<span class="nx">end</span>
<span class="nx">derive</span><span class="w"> </span><span class="nx">Show</span><span class="p">,</span><span class="w"> </span><span class="nx">Eq</span>

<span class="nx">def</span><span class="w"> </span><span class="nx">main</span><span class="p">():</span><span class="w"> </span><span class="nx">Unit</span><span class="w"> </span><span class="p">=</span>
<span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="kd">addr</span><span class="w"> </span><span class="p">=</span><span class="w"> </span><span class="nx">Address</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="nx">street</span><span class="p">:</span><span class="w"> </span><span class="s">&quot;123 Main St&quot;</span><span class="p">,</span>
<span class="w">        </span><span class="nx">city</span><span class="p">:</span><span class="w"> </span><span class="s">&quot;Springfield&quot;</span><span class="p">,</span>
<span class="w">        </span><span class="nx">country</span><span class="p">:</span><span class="w"> </span><span class="s">&quot;USA&quot;</span>
<span class="w">    </span><span class="p">}</span>

<span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="nx">manager</span><span class="w"> </span><span class="p">=</span><span class="w"> </span><span class="nx">Person</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="nx">name</span><span class="p">:</span><span class="w"> </span><span class="s">&quot;Alice&quot;</span><span class="p">,</span>
<span class="w">        </span><span class="nx">age</span><span class="p">:</span><span class="w"> </span><span class="mi">35</span><span class="p">,</span>
<span class="w">        </span><span class="nx">address</span><span class="p">:</span><span class="w"> </span><span class="kd">addr</span>
<span class="w">    </span><span class="p">}</span>

<span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="nx">dept</span><span class="w"> </span><span class="p">=</span><span class="w"> </span><span class="nx">Department</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="nx">name</span><span class="p">:</span><span class="w"> </span><span class="s">&quot;Engineering&quot;</span><span class="p">,</span>
<span class="w">        </span><span class="nx">manager</span><span class="p">:</span><span class="w"> </span><span class="nx">manager</span><span class="p">,</span>
<span class="w">        </span><span class="nx">employees</span><span class="p">:</span><span class="w"> </span><span class="p">[]</span>
<span class="w">    </span><span class="p">}</span>

<span class="w">    </span><span class="nx">println</span><span class="p">(</span><span class="nx">show</span><span class="p">(</span><span class="nx">dept</span><span class="p">))</span>
</code></pre></div>

<h2 id="best-practices">Best Practices</h2>
<h3 id="1-derive-by-default">1. Derive by Default</h3>
<p>Start with derivation for standard typeclasses:</p>
<div class="codehilite"><pre><span></span><code><span class="nv">record</span><span class="w"> </span><span class="nv">MyType</span><span class="w"> </span><span class="k">do</span>
<span class="w">    </span><span class="nv">field1</span>:<span class="w"> </span><span class="nv">T1</span>
<span class="w">    </span><span class="nv">field2</span>:<span class="w"> </span><span class="nv">T2</span>
<span class="k">end</span>
<span class="nv">derive</span><span class="w"> </span><span class="k">Show</span>,<span class="w"> </span><span class="nv">Eq</span>
</code></pre></div>

<h3 id="2-custom-when-needed">2. Custom When Needed</h3>
<p>Override with manual instances only when necessary:</p>
<div class="codehilite"><pre><span></span><code><span class="c">% Derive most instances</span>
<span class="n">derive</span><span class="w"> </span><span class="s">Show,</span><span class="w"> </span><span class="s">Ord</span>

<span class="c">% But custom Eq for special logic</span>
<span class="n">instance</span><span class="w"> </span><span class="s">Eq(MyType)</span><span class="w"> </span><span class="s">do</span>
<span class="w">    </span><span class="n">def</span><span class="w"> </span><span class="o">==</span><span class="p">(</span><span class="n">a</span><span class="p">:</span><span class="w"> </span><span class="n">MyType</span><span class="p">,</span><span class="w"> </span><span class="n">b</span><span class="p">:</span><span class="w"> </span><span class="n">MyType</span><span class="p">):</span><span class="w"> </span><span class="n">Bool</span><span class="w"> </span><span class="p">=</span><span class="w"> </span><span class="k">...</span>
<span class="k">end</span>
</code></pre></div>

<h3 id="3-document-custom-instances">3. Document Custom Instances</h3>
<p>When manually implementing, explain why:</p>
<div class="codehilite"><pre><span></span><code><span class="c">% Custom equality compares only the ID field</span>
<span class="c">% because other fields are metadata that should be ignored</span>
<span class="n">instance</span><span class="w"> </span><span class="s">Eq(User)</span><span class="w"> </span><span class="s">do</span>
<span class="w">    </span><span class="n">def</span><span class="w"> </span><span class="o">==</span><span class="p">(</span><span class="n">u1</span><span class="p">:</span><span class="w"> </span><span class="n">User</span><span class="p">,</span><span class="w"> </span><span class="n">u2</span><span class="p">:</span><span class="w"> </span><span class="n">User</span><span class="p">):</span><span class="w"> </span><span class="n">Bool</span><span class="w"> </span><span class="p">=</span>
<span class="w">        </span><span class="n">u1</span><span class="p">.</span><span class="n">id</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="n">u2</span><span class="p">.</span><span class="n">id</span>
<span class="k">end</span>
</code></pre></div>

<h3 id="4-order-fields-intentionally">4. Order Fields Intentionally</h3>
<p>For derived <code>Ord</code>, field order matters:</p>
<div class="codehilite"><pre><span></span><code><span class="c">% First name, then age for ordering</span>
<span class="nb">record</span><span class="w"> </span><span class="n">Person</span><span class="w"> </span><span class="n">do</span>
<span class="w">    </span><span class="n">name</span><span class="p">:</span><span class="w"> </span><span class="n">String</span><span class="w">    </span><span class="c">% Primary sort key</span>
<span class="w">    </span><span class="n">age</span><span class="p">:</span><span class="w"> </span><span class="n">Int</span><span class="w">        </span><span class="c">% Secondary sort key</span>
<span class="w">    </span><span class="n">email</span><span class="p">:</span><span class="w"> </span><span class="n">String</span><span class="w">   </span><span class="c">% Tertiary sort key</span>
<span class="k">end</span>
<span class="n">derive</span><span class="w"> </span><span class="s">Ord</span>
</code></pre></div>

<h3 id="5-consider-performance">5. Consider Performance</h3>
<p>Derived instances are straightforward but not always optimal:</p>
<div class="codehilite"><pre><span></span><code><span class="c">% Many fields - derived Eq checks all</span>
<span class="nb">record</span><span class="w"> </span><span class="n">LargeRecord</span><span class="w"> </span><span class="n">do</span>
<span class="w">    </span><span class="n">id</span><span class="p">:</span><span class="w"> </span><span class="n">Int</span>
<span class="w">    </span><span class="n">field1</span><span class="p">:</span><span class="w"> </span><span class="n">String</span>
<span class="w">    </span><span class="n">field2</span><span class="p">:</span><span class="w"> </span><span class="n">String</span>
<span class="w">    </span><span class="c">% ... 50 more fields</span>
<span class="k">end</span>

<span class="c">% Better: manual Eq that checks ID first</span>
<span class="n">instance</span><span class="w"> </span><span class="s">Eq(LargeRecord)</span><span class="w"> </span><span class="s">do</span>
<span class="w">    </span><span class="n">def</span><span class="w"> </span><span class="o">==</span><span class="p">(</span><span class="n">r1</span><span class="p">:</span><span class="w"> </span><span class="n">LargeRecord</span><span class="p">,</span><span class="w"> </span><span class="n">r2</span><span class="p">:</span><span class="w"> </span><span class="n">LargeRecord</span><span class="p">):</span><span class="w"> </span><span class="n">Bool</span><span class="w"> </span><span class="p">=</span>
<span class="w">        </span><span class="n">r1</span><span class="p">.</span><span class="n">id</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="n">r2</span><span class="p">.</span><span class="n">id</span><span class="w">  </span><span class="c">% Fast path</span>
<span class="k">end</span>
</code></pre></div>

<h2 id="implementation-details">Implementation Details</h2>
<h3 id="code-generation">Code Generation</h3>
<p>Derived instances generate AST nodes equivalent to hand-written code:</p>
<div class="codehilite"><pre><span></span><code><span class="nb">record</span><span class="w"> </span><span class="n">Point</span><span class="w"> </span><span class="n">do</span><span class="w"> </span><span class="n">x</span><span class="p">:</span><span class="w"> </span><span class="n">Int</span><span class="p">,</span><span class="w"> </span><span class="n">y</span><span class="p">:</span><span class="w"> </span><span class="n">Int</span><span class="w"> </span><span class="k">end</span>
<span class="n">derive</span><span class="w"> </span><span class="s">Show</span>

<span class="c">% Equivalent to:</span>
<span class="n">instance</span><span class="w"> </span><span class="s">Show(Point)</span><span class="w"> </span><span class="s">do</span>
<span class="w">    </span><span class="n">def</span><span class="w"> </span><span class="n">show</span><span class="p">(</span><span class="n">p</span><span class="p">:</span><span class="w"> </span><span class="n">Point</span><span class="p">):</span><span class="w"> </span><span class="n">String</span><span class="w"> </span><span class="p">=</span>
<span class="w">        </span><span class="s">&quot;Point { x: &quot;</span><span class="w"> </span><span class="o">++</span><span class="w"> </span><span class="n">show</span><span class="p">(</span><span class="n">p</span><span class="p">.</span><span class="n">x</span><span class="p">)</span><span class="w"> </span><span class="o">++</span><span class="w"> </span><span class="s">&quot;, y: &quot;</span><span class="w"> </span><span class="o">++</span><span class="w"> </span><span class="n">show</span><span class="p">(</span><span class="n">p</span><span class="p">.</span><span class="n">y</span><span class="p">)</span><span class="w"> </span><span class="o">++</span><span class="w"> </span><span class="s">&quot; }&quot;</span>
<span class="k">end</span>
</code></pre></div>

<h3 id="compilation-phases">Compilation Phases</h3>
<ol>
<li><strong>Parse</strong>: Recognize <code>derive</code> clause in AST</li>
<li><strong>Validate</strong>: Check typeclass is derivable for type</li>
<li><strong>Generate</strong>: Create instance definition AST</li>
<li><strong>Typecheck</strong>: Verify generated instance is well-typed</li>
<li><strong>Codegen</strong>: Compile instance to BEAM bytecode</li>
</ol>
<h3 id="performance-characteristics">Performance Characteristics</h3>
<ul>
<li><strong>Compile-time</strong>: Zero runtime overhead</li>
<li><strong>Generated code</strong>: Equivalent to hand-written instances</li>
<li><strong>Binary size</strong>: No difference from manual implementations</li>
</ul>
<h2 id="faq">FAQ</h2>
<p><strong>Q: Can I derive instances for existing types?</strong><br />
A: No, derive clauses must appear in the same module as the type definition.</p>
<p><strong>Q: Can I derive partial instances?</strong><br />
A: No, you either derive the complete instance or write it manually.</p>
<p><strong>Q: What if I derive and manually define the same instance?</strong><br />
A: Compiler error - instance coherence violation.</p>
<p><strong>Q: Can I derive instances conditionally?</strong><br />
A: Not directly, but you can use different type definitions in different modules.</p>
<p><strong>Q: How do I debug derived instances?</strong><br />
A: Use compiler flags to emit generated code for inspection.</p>
<h2 id="see-also">See Also</h2>
<ul>
<li><a href="./TYPECLASS_GUIDE.md">Typeclass Guide</a> - Complete typeclass system documentation</li>
<li><a href="./TYPE_SYSTEM.md">Type System</a> - Cure's type system overview</li>
<li><a href="./STDLIB.md">Standard Library</a> - Built-in typeclass instances</li>
</ul>
    </div>

    <!-- Footer -->
    <footer class="site-footer">
        <div class="footer-content">
            <div class="footer-section">
                <h4>Documentation</h4>
                <ul>
                    <li><a href="../docs.html">Getting Started</a></li>
                    <li><a href="language-spec.html">Language Specification</a></li>
                    <li><a href="type-system.html">Type System</a></li>
                    <li><a href="fsm-usage.html">FSM Guide</a></li>
                </ul>
            </div>

            <div class="footer-section">
                <h4>Reference</h4>
                <ul>
                    <li><a href="../api/index.html">API Reference</a></li>
                    <li><a href="std-summary.html">Standard Library</a></li>
                    <li><a href="feature-reference.html">Feature Reference</a></li>
                    <li><a href="cli-usage.html">CLI Usage</a></li>
                </ul>
            </div>

            <div class="footer-section">
                <h4>Resources</h4>
                <ul>
                    <li><a href="editor-setup.html">Editor Setup</a></li>
                    <li><a href="project-overview.html">Project Overview</a></li>
                    <li><a href="cure-ultimate-description.html">Ultimate Guide</a></li>
                </ul>
            </div>
        </div>

        <div class="footer-bottom">
            <p>&copy; 2025 Cure Programming Language. Verification-first programming for the BEAM.</p>
        </div>
    </footer>
</body>
</html>
