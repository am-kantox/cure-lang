<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>The `$` Operator Issue and Fix - Cure Documentation</title>
    <meta name="description" content=" Summary">
    <link rel="icon" type="image/png" href="../media/logo-128x128.png">
    <link rel="stylesheet" href="../css/style.css">
    <link rel="stylesheet" href="../css/cure-theme.css">
</head>
<body>
    <!-- Header -->
    <header class="site-header">
        <div class="nav-container">
            <div class="logo-section">
                <img src="../media/logo-128x128.png" alt="Cure Logo" class="logo">
                <div>
                    <h1 class="site-title">Cure</h1>
                    <p class="site-tagline">Verification-First Programming</p>
                </div>
            </div>
            <nav class="main-nav">
                <ul>
                    <li><a href="../index.html">Home</a></li>
                    <li><a href="../docs.html">Documentation</a></li>
                    <li><a href="../api/index.html">API Reference</a></li>
                </ul>
            </nav>
        </div>
    </header>

    <!-- Main Content -->
    <div class="doc-page">
        <div class="doc-nav">
            <a href="../docs.html">← Back to Documentation</a>
        </div>
        
        <h1 id="the-operator-issue-and-fix">The <code>$</code> Operator Issue and Fix</h1>
<h2 id="summary">Summary</h2>
<p>Cure's typeclass specifications use operators containing <code>$</code> (dollar sign), which were causing lexer errors. This document explains the issue, why we need these operators, and how we fixed it.</p>
<h2 id="the-problem">The Problem</h2>
<h3 id="error-message">Error Message</h3>
<div class="codehilite"><pre><span></span><code><span class="n">Error</span><span class="o">:</span><span class="w"> </span><span class="n">Lexical</span><span class="w"> </span><span class="n">Analysis</span><span class="w"> </span><span class="n">failed</span><span class="o">:</span><span class="w"> </span><span class="o">{{</span><span class="n">unexpected_character</span><span class="o">,</span><span class="mi">36</span><span class="o">},</span><span class="mi">82</span><span class="o">,</span><span class="mi">9</span><span class="o">}</span>
</code></pre></div>

<ul>
<li>Character 36 is ASCII for <code>$</code></li>
<li>Occurred when parsing typeclass specification files</li>
</ul>
<h3 id="root-cause">Root Cause</h3>
<p>The lexer (<code>src/lexer/cure_lexer.erl</code>) only recognized characters in the <code>operators()</code> map. When it encountered <code>$</code>, it threw <code>{lexer_error, {unexpected_character, 36}, Line, Column}</code>.</p>
<p>This happened at two locations:<br />
- <strong>Line 448</strong>: <code>scan_single_char/4</code> - handles single-character operators<br />
- <strong>Line 630</strong>: <code>scan_one_token/3</code> - used during string interpolation</p>
<h2 id="why-we-need-operators">Why We Need <code>$</code> Operators</h2>
<p>These operators come from <strong>Haskell's Functor and Applicative typeclasses</strong> and are standard in functional programming languages.</p>
<h3 id="the-operators">The Operators</h3>
<h4 id="functor-operators">Functor Operators</h4>
<ol>
<li><strong><code>&lt;$</code> (replace-left)</strong> - Replace all values in a container with a constant<br />
<code>cure
   def (&lt;$)(value: A, fb: F(B)): F(A) =
     map(fn(_) -&gt; value end, fb)</code></li>
</ol>
<p>Example usage:<br />
<code>cure
   5 &lt;$ Some(10)     # Result: Some(5)
   "x" &lt;$ [1,2,3]    # Result: ["x", "x", "x"]</code></p>
<ol start="2">
<li><strong><code>$&gt;</code> (replace-right)</strong> - Same as <code>&lt;$</code> but with flipped arguments<br />
<code>cure
   def ($&gt;)(fa: F(A), value: B): F(B) =
     map(fn(_) -&gt; value end, fa)</code></li>
</ol>
<p>Example usage:<br />
<code>cure
   Some(10) $&gt; 5     # Result: Some(5)
   [1,2,3] $&gt; "x"    # Result: ["x", "x", "x"]</code></p>
<h4 id="applicative-operators">Applicative Operators</h4>
<ol start="3">
<li>
<p><strong><code>&lt;*&gt;</code> (apply)</strong> - Apply a function in a context to a value in a context<br />
<code>cure
   def (&lt;*&gt;)(ff: F(A -&gt; B), fa: F(A)): F(B)</code></p>
</li>
<li>
<p><strong><code>*&gt;</code> (sequence-right)</strong> - Sequence two actions, keeping only the second result<br />
<code>cure
   def (*&gt;)(fa: F(A), fb: F(B)): F(B)</code></p>
</li>
<li>
<p><strong><code>&lt;*</code> (sequence-left)</strong> - Sequence two actions, keeping only the first result<br />
<code>cure
   def (&lt;*)(fa: F(A), fb: F(B)): F(A)</code></p>
</li>
</ol>
<h4 id="monad-operators">Monad Operators</h4>
<ol start="6">
<li>
<p><strong><code>&gt;&gt;=</code> (bind)</strong> - Monadic bind operator<br />
<code>cure
   def (&gt;&gt;=)(ma: M(A), f: A -&gt; M(B)): M(B) = bind(ma, f)</code></p>
</li>
<li>
<p><strong><code>&gt;&gt;</code> (then)</strong> - Sequence two monadic actions, discarding the first result<br />
<code>cure
   def (&gt;&gt;)(ma: M(A), mb: M(B)): M(B) =
     ma &gt;&gt;= fn(_) -&gt; mb end</code></p>
</li>
</ol>
<h3 id="why-use-specifically">Why Use <code>$</code> Specifically?</h3>
<ol>
<li>
<p><strong>Historical Convention</strong>: Established by Haskell decades ago<br />
   - <code>&lt;$&gt;</code> is the infix operator for <code>fmap</code> (our <code>map</code>)<br />
   - <code>&lt;$</code> and <code>$&gt;</code> are natural variants</p>
</li>
<li>
<p><strong>Visual Distinction</strong>: The <code>$</code> clearly indicates:<br />
   - Function application<br />
   - Value replacement<br />
   - "Lifting" operations into contexts</p>
</li>
<li>
<p><strong>Ecosystem Compatibility</strong>: Anyone familiar with Functor/Applicative expects these names<br />
   - Haskell programmers<br />
   - Scala programmers (similar operators)<br />
   - PureScript programmers<br />
   - Elm programmers (adapted versions)</p>
</li>
<li>
<p><strong>Semantic Clarity</strong>: The operators form a visual pattern:<br />
   - <code>&lt;</code> points to what's kept<br />
   - <code>$</code> indicates the operation<br />
   - <code>&gt;</code> shows direction</p>
</li>
</ol>
<h2 id="the-fix">The Fix</h2>
<h3 id="what-we-changed">What We Changed</h3>
<p>Added the new operators to the <code>operators()</code> map in <code>src/lexer/cure_lexer.erl</code>:</p>
<div class="codehilite"><pre><span></span><code><span class="nf">operators</span><span class="p">()</span><span class="w"> </span><span class="o">-&gt;</span>
<span class="w">    </span><span class="p">#{</span>
<span class="w">        </span><span class="c">% ... existing operators ...</span>
<span class="w">        </span><span class="o">&lt;&lt;</span><span class="s">&quot;|&gt;&quot;</span><span class="o">&gt;&gt;</span><span class="w"> </span><span class="o">=&gt;</span><span class="w"> </span><span class="n">&#39;|&gt;&#39;</span><span class="p">,</span>
<span class="w">        </span><span class="o">&lt;&lt;</span><span class="s">&quot;#{&quot;</span><span class="o">&gt;&gt;=&gt;&gt;</span><span class="w">  </span><span class="n">&#39;interpolation_start&#39;</span><span class="p">,</span>
<span class="w">        </span><span class="c">% Functor/Applicative operators</span>
<span class="w">        </span><span class="o">&lt;&lt;</span><span class="s">&quot;&lt;$&quot;</span><span class="o">&gt;&gt;</span><span class="w"> </span><span class="o">=&gt;</span><span class="w"> </span><span class="n">&#39;&lt;$&#39;</span><span class="p">,</span>
<span class="w">        </span><span class="o">&lt;&lt;</span><span class="s">&quot;$&gt;&quot;</span><span class="o">&gt;&gt;</span><span class="w"> </span><span class="o">=&gt;</span><span class="w"> </span><span class="n">&#39;$&gt;&#39;</span><span class="p">,</span>
<span class="w">        </span><span class="o">&lt;&lt;</span><span class="s">&quot;&lt;*&gt;&quot;</span><span class="o">&gt;&gt;</span><span class="w"> </span><span class="o">=&gt;</span><span class="w"> </span><span class="n">&#39;&lt;*&gt;&#39;</span><span class="p">,</span>
<span class="w">        </span><span class="o">&lt;&lt;</span><span class="s">&quot;*&gt;&quot;</span><span class="o">&gt;&gt;</span><span class="w"> </span><span class="o">=&gt;</span><span class="w"> </span><span class="n">&#39;*&gt;&#39;</span><span class="p">,</span>
<span class="w">        </span><span class="o">&lt;&lt;</span><span class="s">&quot;&lt;*&quot;</span><span class="o">&gt;&gt;</span><span class="w"> </span><span class="o">=&gt;</span><span class="w"> </span><span class="n">&#39;&lt;*&#39;</span><span class="p">,</span>
<span class="w">        </span><span class="c">% Monad operators</span>
<span class="w">        </span><span class="o">&lt;&lt;</span><span class="s">&quot;&gt;&gt;=&quot;</span><span class="o">&gt;&gt;</span><span class="w"> </span><span class="o">=&gt;</span><span class="w"> </span><span class="n">&#39;&gt;&gt;=&#39;</span><span class="p">,</span>
<span class="w">        </span><span class="o">&lt;&lt;</span><span class="s">&quot;&gt;&gt;&quot;</span><span class="o">&gt;&gt;</span><span class="w"> </span><span class="o">=&gt;</span><span class="w"> </span><span class="n">&#39;&gt;&gt;&#39;</span>
<span class="w">    </span><span class="p">}.</span>
</code></pre></div>

<h3 id="how-it-works">How It Works</h3>
<p>The lexer now follows this process:</p>
<ol>
<li><strong>Three-character check</strong>: Tries <code>&lt;*&gt;</code> and <code>&gt;&gt;=</code> first (lines 412-421)</li>
<li><strong>Two-character check</strong>: Tries <code>&lt;$</code>, <code>$&gt;</code>, <code>*&gt;</code>, <code>&lt;*</code>, <code>&gt;&gt;</code> (lines 429-441)</li>
<li><strong>Single-character check</strong>: Only if no multi-char match (lines 444-454)</li>
</ol>
<p>The order matters because:<br />
- <code>&lt;*&gt;</code> must be checked before <code>&lt;*</code> and <code>*&gt;</code><br />
- <code>&gt;&gt;=</code> must be checked before <code>&gt;&gt;</code><br />
- Longer operators take precedence</p>
<h3 id="testing">Testing</h3>
<p>Verified the fix works:</p>
<div class="codehilite"><pre><span></span><code>$<span class="w"> </span>erl<span class="w"> </span>-pa<span class="w"> </span>_build/ebin<span class="w"> </span>-noshell<span class="w"> </span>-eval<span class="w"> </span><span class="se">\</span>
<span class="w">  </span><span class="s2">&quot;case cure_lexer:tokenize_file(\&quot;lib/typeclass_spec/typeclass.cure\&quot;) of \</span>
<span class="s2">     {ok, Tokens} -&gt; io:format(\&quot;Success! Tokenized ~p tokens~n\&quot;, [length(Tokens)]); \</span>
<span class="s2">     {error, E} -&gt; io:format(\&quot;Error: ~p~n\&quot;, [E]) \</span>
<span class="s2">   end, halt(0).&quot;</span>

Success!<span class="w"> </span>Tokenized<span class="w"> </span><span class="m">1026</span><span class="w"> </span>tokens
</code></pre></div>

<h2 id="alternative-approaches-not-chosen">Alternative Approaches (Not Chosen)</h2>
<h3 id="option-2-use-different-operator-names">Option 2: Use Different Operator Names</h3>
<p>We could have avoided <code>$</code> by using different names:</p>
<div class="codehilite"><pre><span></span><code>def replace_left(value: A, fb: F(B)): F(A)
def replace_right(fa: F(A), value: B): F(B)
</code></pre></div>

<p><strong>Rejected because</strong>:<br />
- Loses the elegant infix notation<br />
- Breaks compatibility with functional programming conventions<br />
- Makes code more verbose<br />
- Reduces readability for experienced functional programmers</p>
<h3 id="option-3-use-unicode-operators">Option 3: Use Unicode Operators</h3>
<p>We could have used Unicode symbols:</p>
<div class="codehilite"><pre><span></span><code>def (⊳)(value: A, fb: F(B)): F(A)  # U+22B3 CONTAINS AS NORMAL SUBGROUP
def (⊲)(fa: F(A), value: B): F(B)  # U+22B2 NORMAL SUBGROUP OF
</code></pre></div>

<p><strong>Rejected because</strong>:<br />
- Harder to type on standard keyboards<br />
- Not widely recognized in the functional programming community<br />
- Adds unnecessary complexity<br />
- Poor tool support</p>
<h2 id="impact-on-existing-code">Impact on Existing Code</h2>
<h3 id="no-breaking-changes">No Breaking Changes</h3>
<p>Adding these operators is <strong>backward compatible</strong>:<br />
- Existing code continues to work<br />
- <code>$</code> was previously an error, so no code used it<br />
- Parser needs updates to handle operator definitions</p>
<h3 id="whats-still-needed">What's Still Needed</h3>
<ol>
<li>
<p><strong>Parser Updates</strong>: Add grammar rules for operator function definitions<br />
<code>cure
   def (&lt;$)(value: A, fb: F(B)): F(A) = ...</code></p>
</li>
<li>
<p><strong>Operator Precedence</strong>: Define precedence and associativity<br />
   - <code>&lt;$</code> and <code>$&gt;</code>: Same as <code>map</code> (high precedence)<br />
   - <code>&lt;*&gt;</code>: Lower than <code>&lt;$</code> (function application)<br />
   - <code>*&gt;</code> and <code>&lt;*</code>: Same as <code>&lt;*&gt;</code><br />
   - <code>&gt;&gt;=</code> and <code>&gt;&gt;</code>: Lowest (sequencing)</p>
</li>
<li>
<p><strong>Type System</strong>: Already supports these through typeclass definitions</p>
</li>
</ol>
<h2 id="references">References</h2>
<ul>
<li><strong>Haskell Functor</strong>: https://hackage.haskell.org/package/base/docs/Data-Functor.html</li>
<li><strong>Haskell Applicative</strong>: https://hackage.haskell.org/package/base/docs/Control-Applicative.html</li>
<li><strong>Haskell Monad</strong>: https://hackage.haskell.org/package/base/docs/Control-Monad.html</li>
<li><strong>Learn You a Haskell</strong>: http://learnyouahaskell.com/functors-applicative-functors-and-monoids</li>
</ul>
<h2 id="summary-of-changes">Summary of Changes</h2>
<h3 id="files-modified">Files Modified</h3>
<ul>
<li><code>src/lexer/cure_lexer.erl</code> - Added 7 new operators to <code>operators()</code> map</li>
</ul>
<h3 id="operators-added">Operators Added</h3>
<ul>
<li><code>&lt;$</code> - Functor replace-left</li>
<li><code>$&gt;</code> - Functor replace-right  </li>
<li><code>&lt;*&gt;</code> - Applicative apply</li>
<li><code>*&gt;</code> - Applicative sequence-right</li>
<li><code>&lt;*</code> - Applicative sequence-left</li>
<li><code>&gt;&gt;=</code> - Monad bind</li>
<li><code>&gt;&gt;</code> - Monad then</li>
</ul>
<h3 id="testing-status">Testing Status</h3>
<ul>
<li>✅ Lexer successfully tokenizes typeclass specifications</li>
<li>⏳ Parser grammar rules needed for operator definitions</li>
<li>⏳ Operator precedence rules needed</li>
<li>✅ Type system already supports typeclasses</li>
</ul>
<h2 id="next-steps">Next Steps</h2>
<ol>
<li><strong>Update Parser</strong>: Add grammar rules for operator function definitions</li>
<li><strong>Define Precedence</strong>: Establish operator precedence table</li>
<li><strong>Move Typeclass Files</strong>: Once parser is ready, move from <code>lib/typeclass_spec/</code> to <code>lib/std/</code></li>
<li><strong>Documentation</strong>: Add operator documentation to language guide</li>
<li><strong>Examples</strong>: Create example programs using these operators</li>
</ol>
    </div>

    <!-- Footer -->
    <footer class="site-footer">
        <div class="footer-content">
            <div class="footer-section">
                <h4>Documentation</h4>
                <ul>
                    <li><a href="../docs.html">Getting Started</a></li>
                    <li><a href="language-spec.html">Language Specification</a></li>
                    <li><a href="type-system.html">Type System</a></li>
                    <li><a href="fsm-usage.html">FSM Guide</a></li>
                </ul>
            </div>

            <div class="footer-section">
                <h4>Reference</h4>
                <ul>
                    <li><a href="../api/index.html">API Reference</a></li>
                    <li><a href="std-summary.html">Standard Library</a></li>
                    <li><a href="feature-reference.html">Feature Reference</a></li>
                    <li><a href="cli-usage.html">CLI Usage</a></li>
                </ul>
            </div>

            <div class="footer-section">
                <h4>Resources</h4>
                <ul>
                    <li><a href="editor-setup.html">Editor Setup</a></li>
                    <li><a href="project-overview.html">Project Overview</a></li>
                    <li><a href="cure-ultimate-description.html">Ultimate Guide</a></li>
                </ul>
            </div>
        </div>

        <div class="footer-bottom">
            <p>&copy; 2025 Cure Programming Language. Verification-first programming for the BEAM.</p>
        </div>
    </footer>
    <!-- Syntax Highlighting -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.11.1/highlight.min.js"></script>
    <script src="../js/cure-language.js"></script>
    <script>
        // Initialize highlight.js and highlight all code blocks
        hljs.highlightAll();
    </script>
</body>
</html>
