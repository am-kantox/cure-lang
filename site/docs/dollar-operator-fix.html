<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>The `$` Operator Issue and Fix - Cure Documentation</title>
    <meta name="description" content=" Summary">
    <link rel="icon" type="image/png" href="../media/logo-128x128.png">
    <link rel="stylesheet" href="../css/style.css">
</head>
<body>
    <!-- Header -->
    <header class="site-header">
        <div class="nav-container">
            <div class="logo-section">
                <img src="../media/logo-128x128.png" alt="Cure Logo" class="logo">
                <div>
                    <h1 class="site-title">Cure</h1>
                    <p class="site-tagline">Verification-First Programming</p>
                </div>
            </div>
            <nav class="main-nav">
                <ul>
                    <li><a href="../index.html">Home</a></li>
                    <li><a href="../docs.html">Documentation</a></li>
                    <li><a href="../api/index.html">API Reference</a></li>
                </ul>
            </nav>
        </div>
    </header>

    <!-- Main Content -->
    <div class="doc-page">
        <div class="doc-nav">
            <a href="../docs.html">← Back to Documentation</a>
        </div>
        
        <h1>The <code>$</code> Operator Issue and Fix</h1>

<h2>Summary</h2>

<p>Cure's typeclass specifications use operators containing <code>$</code> (dollar sign), which were causing lexer errors. This document explains the issue, why we need these operators, and how we fixed it.</p>

<h2>The Problem</h2>

<h3>Error Message</h3>
<pre><code>Error: Lexical Analysis failed: {{unexpected_character,36},82,9}
</code></pre>
<ul>
<li>Character 36 is ASCII for <code>$</code></li>
<li>Occurred when parsing typeclass specification files</li>
</ul>

<h3>Root Cause</h3>
<p>The lexer (<code>src/lexer/cure<em>lexer.erl</code>) only recognized characters in the <code>operators()</code> map. When it encountered <code>$</code>, it threw <code>{lexer</em>error, {unexpected_character, 36}, Line, Column}</code>.</p>

<p>This happened at two locations:</p>
<ul>
<li><strong>Line 448</strong>: <code>scan<em>single</em>char/4</code> - handles single-character operators</li>
<li><strong>Line 630</strong>: <code>scan<em>one</em>token/3</code> - used during string interpolation</li>
</ul>

<h2>Why We Need <code>$</code> Operators</h2>

<p>These operators come from <strong>Haskell's Functor and Applicative typeclasses</strong> and are standard in functional programming languages.</p>

<h3>The Operators</h3>

<h4>Functor Operators</h4>

<ol>
<li><strong><code><$</code> (replace-left)</strong> - Replace all values in a container with a constant</li>
</ol>
   <pre><code>   def (<$)(value: A, fb: F(B)): F(A) =
<p>     map(fn(_) -> value end, fb)</p>
   </code></pre>
   
<p>   Example usage:</p>
   <pre><code>   5 <$ Some(10)     # Result: Some(5)
<p>   "x" <$ [1,2,3]    # Result: ["x", "x", "x"]</p>
   </code></pre>

<ol>
<li><strong><code>$></code> (replace-right)</strong> - Same as <code><$</code> but with flipped arguments</li>
</ol>
   <pre><code>   def ($>)(fa: F(A), value: B): F(B) =
<p>     map(fn(_) -> value end, fa)</p>
   </code></pre>
   
<p>   Example usage:</p>
   <pre><code>   Some(10) $> 5     # Result: Some(5)
<p>   [1,2,3] $> "x"    # Result: ["x", "x", "x"]</p>
   </code></pre>

<h4>Applicative Operators</h4>

<ol>
<li><strong><code><*></code> (apply)</strong> - Apply a function in a context to a value in a context</li>
</ol>
   <pre><code>   def (<*>)(ff: F(A -> B), fa: F(A)): F(B)
   </code></pre>

<ol>
<li><strong><code>*></code> (sequence-right)</strong> - Sequence two actions, keeping only the second result</li>
</ol>
   <pre><code>   def (*>)(fa: F(A), fb: F(B)): F(B)
   </code></pre>

<ol>
<li><strong><code><*</code> (sequence-left)</strong> - Sequence two actions, keeping only the first result</li>
</ol>
   <pre><code>   def (<*)(fa: F(A), fb: F(B)): F(A)
   </code></pre>

<h4>Monad Operators</h4>

<ol>
<li><strong><code>>>=</code> (bind)</strong> - Monadic bind operator</li>
</ol>
   <pre><code>   def (>>=)(ma: M(A), f: A -> M(B)): M(B) = bind(ma, f)
   </code></pre>

<ol>
<li><strong><code>>></code> (then)</strong> - Sequence two monadic actions, discarding the first result</li>
</ol>
   <pre><code>   def (>>)(ma: M(A), mb: M(B)): M(B) =
<p>     ma >>= fn(_) -> mb end</p>
   </code></pre>

<h3>Why Use <code>$</code> Specifically?</h3>

<ol>
<li><strong>Historical Convention</strong>: Established by Haskell decades ago</li>
</ol>
<ul>
<li><code><$></code> is the infix operator for <code>fmap</code> (our <code>map</code>)</li>
<li><code><$</code> and <code>$></code> are natural variants</li>
</ul>

<ol>
<li><strong>Visual Distinction</strong>: The <code>$</code> clearly indicates:</li>
</ol>
<ul>
<li>Function application</li>
<li>Value replacement</li>
<li>"Lifting" operations into contexts</li>
</ul>

<ol>
<li><strong>Ecosystem Compatibility</strong>: Anyone familiar with Functor/Applicative expects these names</li>
</ol>
<ul>
<li>Haskell programmers</li>
<li>Scala programmers (similar operators)</li>
<li>PureScript programmers</li>
<li>Elm programmers (adapted versions)</li>
</ul>

<ol>
<li><strong>Semantic Clarity</strong>: The operators form a visual pattern:</li>
</ol>
<ul>
<li><code><</code> points to what's kept</li>
<li><code>$</code> indicates the operation</li>
<li><code>></code> shows direction</li>
</ul>

<h2>The Fix</h2>

<h3>What We Changed</h3>

<p>Added the new operators to the <code>operators()</code> map in <code>src/lexer/cure_lexer.erl</code>:</p>

<pre><code>operators() ->
<p>    #{</p>
<p>        % ... existing operators ...</p>
        <<"|>">> => '|>',
        <<"#{">>=>>  'interpolation_start',
<p>        % Functor/Applicative operators</p>
        <<"<$">> => '<$',
        <<"$>">> => '$>',
        <<"<<em>>">> => '<</em>>',
        <<"<em>>">> => '</em>>',
        <<"<<em>">> => '<</em>',
<p>        % Monad operators</p>
        <<">>=">> => '>>=',
        <<">>">> => '>>'
<p>    }.</p>
</code></pre>

<h3>How It Works</h3>

<p>The lexer now follows this process:</p>

<ol>
<li><strong>Three-character check</strong>: Tries <code><*></code> and <code>>>=</code> first (lines 412-421)</li>
<li><strong>Two-character check</strong>: Tries <code><$</code>, <code>$></code>, <code><em>></code>, <code><</em></code>, <code>>></code> (lines 429-441)</li>
<li><strong>Single-character check</strong>: Only if no multi-char match (lines 444-454)</li>
</ol>

<p>The order matters because:</p>
<ul>
<li><code><<em>></code> must be checked before <code><</em></code> and <code>*></code></li>
<li><code>>>=</code> must be checked before <code>>></code></li>
<li>Longer operators take precedence</li>
</ul>

<h3>Testing</h3>

<p>Verified the fix works:</p>
<pre><code>$ erl -pa _build/ebin -noshell -eval \
<p>  "case cure<em>lexer:tokenize</em>file(\"lib/typeclass_spec/typeclass.cure\") of \</p>
<p>     {ok, Tokens} -> io:format(\"Success! Tokenized ~p tokens~n\", [length(Tokens)]); \</p>
<p>     {error, E} -> io:format(\"Error: ~p~n\", [E]) \</p>
<p>   end, halt(0)."</p>
   
<p>Success! Tokenized 1026 tokens</p>
</code></pre>

<h2>Alternative Approaches (Not Chosen)</h2>

<h3>Option 2: Use Different Operator Names</h3>

<p>We could have avoided <code>$</code> by using different names:</p>

<pre><code>def replace_left(value: A, fb: F(B)): F(A)
<p>def replace_right(fa: F(A), value: B): F(B)</p>
</code></pre>

<strong>Rejected because</strong>:
<ul>
<li>Loses the elegant infix notation</li>
<li>Breaks compatibility with functional programming conventions</li>
<li>Makes code more verbose</li>
<li>Reduces readability for experienced functional programmers</li>
</ul>

<h3>Option 3: Use Unicode Operators</h3>

<p>We could have used Unicode symbols:</p>

<pre><code>def (⊳)(value: A, fb: F(B)): F(A)  # U+22B3 CONTAINS AS NORMAL SUBGROUP
<p>def (⊲)(fa: F(A), value: B): F(B)  # U+22B2 NORMAL SUBGROUP OF</p>
</code></pre>

<strong>Rejected because</strong>:
<ul>
<li>Harder to type on standard keyboards</li>
<li>Not widely recognized in the functional programming community</li>
<li>Adds unnecessary complexity</li>
<li>Poor tool support</li>
</ul>

<h2>Impact on Existing Code</h2>

<h3>No Breaking Changes</h3>

<p>Adding these operators is <strong>backward compatible</strong>:</p>
<ul>
<li>Existing code continues to work</li>
<li><code>$</code> was previously an error, so no code used it</li>
<li>Parser needs updates to handle operator definitions</li>
</ul>

<h3>What's Still Needed</h3>

<ol>
<li><strong>Parser Updates</strong>: Add grammar rules for operator function definitions</li>
</ol>
   <pre><code>   def (<$)(value: A, fb: F(B)): F(A) = ...
   </code></pre>

<ol>
<li><strong>Operator Precedence</strong>: Define precedence and associativity</li>
</ol>
<ul>
<li><code><$</code> and <code>$></code>: Same as <code>map</code> (high precedence)</li>
<li><code><*></code>: Lower than <code><$</code> (function application)</li>
<li><code><em>></code> and <code><</em></code>: Same as <code><*></code></li>
<li><code>>>=</code> and <code>>></code>: Lowest (sequencing)</li>
</ul>

<ol>
<li><strong>Type System</strong>: Already supports these through typeclass definitions</li>
</ol>

<h2>References</h2>

<ul>
<li><strong>Haskell Functor</strong>: https://hackage.haskell.org/package/base/docs/Data-Functor.html</li>
<li><strong>Haskell Applicative</strong>: https://hackage.haskell.org/package/base/docs/Control-Applicative.html</li>
<li><strong>Haskell Monad</strong>: https://hackage.haskell.org/package/base/docs/Control-Monad.html</li>
<li><strong>Learn You a Haskell</strong>: http://learnyouahaskell.com/functors-applicative-functors-and-monoids</li>
</ul>

<h2>Summary of Changes</h2>

<h3>Files Modified</h3>
<ul>
<li><code>src/lexer/cure_lexer.erl</code> - Added 7 new operators to <code>operators()</code> map</li>
</ul>

<h3>Operators Added</h3>
<ul>
<li><code><$</code> - Functor replace-left</li>
<li><code>$></code> - Functor replace-right  </li>
<li><code><*></code> - Applicative apply</li>
<li><code>*></code> - Applicative sequence-right</li>
<li><code><*</code> - Applicative sequence-left</li>
<li><code>>>=</code> - Monad bind</li>
<li><code>>></code> - Monad then</li>
</ul>

<h3>Testing Status</h3>
<ul>
<li>✅ Lexer successfully tokenizes typeclass specifications</li>
<li>⏳ Parser grammar rules needed for operator definitions</li>
<li>⏳ Operator precedence rules needed</li>
<li>✅ Type system already supports typeclasses</li>
</ul>

<h2>Next Steps</h2>

<ol>
<li><strong>Update Parser</strong>: Add grammar rules for operator function definitions</li>
<li><strong>Define Precedence</strong>: Establish operator precedence table</li>
<li><strong>Move Typeclass Files</strong>: Once parser is ready, move from <code>lib/typeclass_spec/</code> to <code>lib/std/</code></li>
<li><strong>Documentation</strong>: Add operator documentation to language guide</li>
<li><strong>Examples</strong>: Create example programs using these operators</li>
</ol>

    </div>

    <!-- Pill Decoration -->
    <img src="../media/pill-512x512.png" alt="" class="pill-decoration">

    <!-- Footer -->
    <footer class="site-footer">
        <div class="footer-content">
            <div class="footer-section">
                <h4>Documentation</h4>
                <ul>
                    <li><a href="../docs.html">Getting Started</a></li>
                    <li><a href="language-spec.html">Language Specification</a></li>
                    <li><a href="type-system.html">Type System</a></li>
                    <li><a href="fsm-usage.html">FSM Guide</a></li>
                </ul>
            </div>

            <div class="footer-section">
                <h4>Reference</h4>
                <ul>
                    <li><a href="../api/index.html">API Reference</a></li>
                    <li><a href="std-summary.html">Standard Library</a></li>
                    <li><a href="feature-reference.html">Feature Reference</a></li>
                    <li><a href="cli-usage.html">CLI Usage</a></li>
                </ul>
            </div>

            <div class="footer-section">
                <h4>Resources</h4>
                <ul>
                    <li><a href="editor-setup.html">Editor Setup</a></li>
                    <li><a href="project-overview.html">Project Overview</a></li>
                    <li><a href="cure-ultimate-description.html">Ultimate Guide</a></li>
                </ul>
            </div>
        </div>

        <div class="footer-bottom">
            <p>&copy; 2025 Cure Programming Language. Verification-first programming for the BEAM.</p>
        </div>
    </footer>
</body>
</html>
