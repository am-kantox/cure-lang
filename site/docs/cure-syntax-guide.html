<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Cure Language Syntax Guide - Cure Documentation</title>
    <meta name="description" content="Based on: Actual Cure implementation (Standard Library v1.0)  
Purpose: Reference for creating correct Cure examples  
Last Updated: Novem">
    <link rel="icon" type="image/png" href="../media/logo-128x128.png">
    <link rel="stylesheet" href="../css/style.css">
    <link rel="stylesheet" href="../css/cure-theme.css">
</head>
<body>
    <!-- Header -->
    <header class="site-header">
        <div class="nav-container">
            <div class="logo-section">
                <img src="../media/logo-128x128.png" alt="Cure Logo" class="logo">
                <div>
                    <h1 class="site-title">Cure</h1>
                    <p class="site-tagline">Verification-First Programming</p>
                </div>
            </div>
            <nav class="main-nav">
                <ul>
                    <li><a href="../index.html">Home</a></li>
                    <li><a href="../docs.html">Documentation</a></li>
                    <li><a href="../api/index.html">API Reference</a></li>
                </ul>
            </nav>
        </div>
    </header>

    <!-- Main Content -->
    <div class="doc-page">
        <div class="doc-nav">
            <a href="../docs.html">← Back to Documentation</a>
        </div>
        
        <h1 id="cure-language-syntax-guide">Cure Language Syntax Guide</h1>
<p><strong>Based on</strong>: Actual Cure implementation (Standard Library v1.0)<br />
<strong>Purpose</strong>: Reference for creating correct Cure examples<br />
<strong>Last Updated</strong>: November 22, 2025</p>
<hr />
<h2 id="1-module-structure">1. Module Structure</h2>
<p>Every Cure file should define a module:</p>
<div class="codehilite"><pre><span></span><code><span class="n">module</span><span class="w"> </span><span class="n">ModuleName</span><span class="w"> </span><span class="n">do</span>
<span class="w">  </span><span class="k">export</span><span class="w"> </span><span class="p">[</span><span class="n">function_name</span><span class="o">/</span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="n">TypeName</span><span class="p">]</span>

<span class="w">  </span><span class="c1"># Module contents</span>
<span class="n">end</span>
</code></pre></div>

<h3 id="exports">Exports</h3>
<p>Export declarations specify what's public:</p>
<div class="codehilite"><pre><span></span><code><span class="k">export</span><span class="w"> </span><span class="p">[</span>
<span class="w">  </span><span class="n">function_name</span><span class="o">/</span><span class="mi">1</span><span class="p">,</span><span class="w">    </span><span class="c1"># Function with arity</span>
<span class="w">  </span><span class="n">TypeName</span><span class="p">,</span><span class="w">           </span><span class="c1"># Type constructor</span>
<span class="w">  </span><span class="n">constructor_name</span><span class="w">    </span><span class="c1"># Data constructor</span>
<span class="p">]</span>
</code></pre></div>

<h3 id="imports">Imports</h3>
<p>Import from other modules (including standard library):</p>
<div class="codehilite"><pre><span></span><code><span class="kn">import</span><span class="w"> </span><span class="nn">Std.Core</span><span class="w"> </span><span class="p">[</span><span class="n">Result</span><span class="p">,</span><span class="w"> </span><span class="n">Option</span><span class="p">,</span><span class="w"> </span><span class="n">ok</span><span class="o">/</span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="n">error</span><span class="o">/</span><span class="mi">1</span><span class="p">]</span>
<span class="kn">import</span><span class="w"> </span><span class="nn">Std.List</span><span class="w"> </span><span class="p">[</span><span class="nb">map</span><span class="o">/</span><span class="mi">2</span><span class="p">,</span><span class="w"> </span><span class="nb">filter</span><span class="o">/</span><span class="mi">2</span><span class="p">,</span><span class="w"> </span><span class="n">fold</span><span class="o">/</span><span class="mi">3</span><span class="p">]</span>
<span class="kn">import</span><span class="w"> </span><span class="nn">Std.Io</span><span class="w"> </span><span class="p">[</span><span class="nb">print</span><span class="o">/</span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="n">println</span><span class="o">/</span><span class="mi">1</span><span class="p">]</span>
</code></pre></div>

<hr />
<h2 id="2-comments">2. Comments</h2>
<p>Single-line comments only:</p>
<div class="codehilite"><pre><span></span><code># This is a comment
</code></pre></div>

<hr />
<h2 id="3-type-definitions">3. Type Definitions</h2>
<h3 id="type-aliases-with-sum-types">Type Aliases with Sum Types</h3>
<div class="codehilite"><pre><span></span><code><span class="k">type</span><span class="w"> </span><span class="nx">Result</span><span class="p">(</span><span class="nx">T</span><span class="p">,</span><span class="w"> </span><span class="nx">E</span><span class="p">)</span><span class="w"> </span><span class="p">=</span><span class="w"> </span><span class="nx">Ok</span><span class="p">(</span><span class="nx">T</span><span class="p">)</span><span class="w"> </span><span class="o">|</span><span class="w"> </span><span class="nx">Error</span><span class="p">(</span><span class="nx">E</span><span class="p">)</span>
<span class="k">type</span><span class="w"> </span><span class="nx">Option</span><span class="p">(</span><span class="nx">T</span><span class="p">)</span><span class="w"> </span><span class="p">=</span><span class="w"> </span><span class="nx">Some</span><span class="p">(</span><span class="nx">T</span><span class="p">)</span><span class="w"> </span><span class="o">|</span><span class="w"> </span><span class="nx">None</span>
<span class="k">type</span><span class="w"> </span><span class="nx">Ordering</span><span class="w"> </span><span class="p">=</span><span class="w"> </span><span class="nx">Lt</span><span class="w"> </span><span class="o">|</span><span class="w"> </span><span class="nx">Eq</span><span class="w"> </span><span class="o">|</span><span class="w"> </span><span class="nx">Gt</span>
</code></pre></div>

<h3 id="record-types">Record Types</h3>
<p>Records define structured data with named fields:</p>
<div class="codehilite"><pre><span></span><code><span class="nv">record</span><span class="w"> </span><span class="nv">RecordName</span><span class="w"> </span><span class="k">do</span>
<span class="w">  </span><span class="nv">field1</span>:<span class="w"> </span><span class="nv">Type1</span>
<span class="w">  </span><span class="nv">field2</span>:<span class="w"> </span><span class="nv">Type2</span>
<span class="w">  </span><span class="nv">field3</span>:<span class="w"> </span><span class="nv">Type3</span>
<span class="k">end</span>
</code></pre></div>

<h4 id="record-with-type-parameters">Record with Type Parameters</h4>
<div class="codehilite"><pre><span></span><code><span class="nv">record</span><span class="w"> </span><span class="nv">Point</span><span class="ss">(</span><span class="nv">T</span><span class="ss">)</span><span class="w"> </span><span class="k">do</span>
<span class="w">  </span><span class="nv">x</span>:<span class="w"> </span><span class="nv">T</span>
<span class="w">  </span><span class="nv">y</span>:<span class="w"> </span><span class="nv">T</span>
<span class="k">end</span>
</code></pre></div>

<h4 id="record-construction">Record Construction</h4>
<div class="codehilite"><pre><span></span><code><span class="c1"># Create a record instance</span>
<span class="n">let</span><span class="w"> </span><span class="n">point</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">Point</span><span class="p">{</span><span class="n">x</span><span class="p">:</span><span class="w"> </span><span class="mf">3.0</span><span class="p">,</span><span class="w"> </span><span class="n">y</span><span class="p">:</span><span class="w"> </span><span class="mf">4.0</span><span class="p">}</span>
<span class="n">let</span><span class="w"> </span><span class="n">payload</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">TrafficPayload</span><span class="p">{</span><span class="n">cycles_completed</span><span class="p">:</span><span class="w"> </span><span class="mi">0</span><span class="p">,</span><span class="w"> </span><span class="n">timer_events</span><span class="p">:</span><span class="w"> </span><span class="mi">0</span><span class="p">,</span><span class="w"> </span><span class="n">emergency_stops</span><span class="p">:</span><span class="w"> </span><span class="mi">0</span><span class="p">}</span>
</code></pre></div>

<h4 id="record-pattern-matching">Record Pattern Matching</h4>
<div class="codehilite"><pre><span></span><code><span class="cp"># Match and extract fields</span>
<span class="n">match</span><span class="w"> </span><span class="n">point</span><span class="w"> </span><span class="n">do</span>
<span class="w">  </span><span class="n">Point</span><span class="p">{</span><span class="n">x</span><span class="o">:</span><span class="w"> </span><span class="n">x</span><span class="p">,</span><span class="w"> </span><span class="n">y</span><span class="o">:</span><span class="w"> </span><span class="n">y</span><span class="p">}</span><span class="w"> </span><span class="kr">when</span><span class="w"> </span><span class="n">x</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="mf">0.0</span><span class="w"> </span><span class="kr">and</span><span class="w"> </span><span class="n">y</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="mf">0.0</span><span class="w"> </span><span class="o">-&gt;</span>
<span class="w">    </span><span class="s">&quot;Origin&quot;</span>
<span class="w">  </span><span class="n">Point</span><span class="p">{</span><span class="n">x</span><span class="o">:</span><span class="w"> </span><span class="n">x</span><span class="p">,</span><span class="w"> </span><span class="n">y</span><span class="o">:</span><span class="w"> </span><span class="n">y</span><span class="p">}</span><span class="w"> </span><span class="kr">when</span><span class="w"> </span><span class="n">x</span><span class="w"> </span><span class="o">&gt;</span><span class="w"> </span><span class="mf">0.0</span><span class="w"> </span><span class="kr">and</span><span class="w"> </span><span class="n">y</span><span class="w"> </span><span class="o">&gt;</span><span class="w"> </span><span class="mf">0.0</span><span class="w"> </span><span class="o">-&gt;</span>
<span class="w">    </span><span class="s">&quot;First quadrant&quot;</span>
<span class="w">  </span><span class="n">Point</span><span class="p">{</span><span class="n">x</span><span class="o">:</span><span class="w"> </span><span class="n">_</span><span class="p">,</span><span class="w"> </span><span class="n">y</span><span class="o">:</span><span class="w"> </span><span class="n">y</span><span class="p">}</span><span class="w"> </span><span class="kr">when</span><span class="w"> </span><span class="n">y</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="mf">0.0</span><span class="w"> </span><span class="o">-&gt;</span>
<span class="w">    </span><span class="s">&quot;On X-axis&quot;</span>
<span class="kd">end</span>

<span class="cp"># Partial field matching (other fields ignored)</span>
<span class="n">match</span><span class="w"> </span><span class="n">person</span><span class="w"> </span><span class="n">do</span>
<span class="w">  </span><span class="n">Person</span><span class="p">{</span><span class="n">age</span><span class="o">:</span><span class="w"> </span><span class="n">age</span><span class="p">,</span><span class="w"> </span><span class="n">score</span><span class="o">:</span><span class="w"> </span><span class="n">score</span><span class="p">}</span><span class="w"> </span><span class="kr">when</span><span class="w"> </span><span class="n">age</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="mi">18</span><span class="w"> </span><span class="kr">and</span><span class="w"> </span><span class="n">score</span><span class="w"> </span><span class="o">&gt;=</span><span class="w"> </span><span class="mi">90</span><span class="w"> </span><span class="o">-&gt;</span>
<span class="w">    </span><span class="s">&quot;Outstanding young achiever&quot;</span>
<span class="kd">end</span>
</code></pre></div>

<hr />
<h2 id="4-function-definitions">4. Function Definitions</h2>
<h3 id="basic-function-syntax">Basic Function Syntax</h3>
<div class="codehilite"><pre><span></span><code class="language-cure">def function_name(param1: Type1, param2: Type2): ReturnType =
  expression
</code></pre></div>

<h3 id="function-with-match-expression">Function with Match Expression</h3>
<div class="codehilite"><pre><span></span><code><span class="n">def</span><span class="w"> </span><span class="nf">length</span><span class="p">(</span><span class="n">list</span><span class="o">:</span><span class="w"> </span><span class="n">List</span><span class="p">(</span><span class="n">T</span><span class="p">))</span><span class="o">:</span><span class="w"> </span><span class="n">Nat</span><span class="w"> </span><span class="o">=</span>
<span class="w">  </span><span class="n">match</span><span class="w"> </span><span class="n">list</span><span class="w"> </span><span class="n">do</span>
<span class="w">    </span><span class="p">[]</span><span class="w"> </span><span class="o">-&gt;</span><span class="w"> </span><span class="n">Zero</span>
<span class="w">    </span><span class="p">[</span><span class="n">_</span><span class="w"> </span><span class="o">|</span><span class="w"> </span><span class="n">t</span><span class="p">]</span><span class="w"> </span><span class="o">-&gt;</span><span class="w"> </span><span class="n">Succ</span><span class="p">(</span><span class="nf">length</span><span class="p">(</span><span class="n">t</span><span class="p">))</span>
<span class="w">  </span><span class="kd">end</span>
</code></pre></div>

<h3 id="functions-with-let-bindings">Functions with Let Bindings</h3>
<div class="codehilite"><pre><span></span><code><span class="n">def</span><span class="w"> </span><span class="n">filter</span><span class="p">(</span><span class="n">list</span><span class="o">:</span><span class="w"> </span><span class="n">List</span><span class="p">(</span><span class="n">T</span><span class="p">),</span><span class="w"> </span><span class="n">predicate</span><span class="o">:</span><span class="w"> </span><span class="n">T</span><span class="w"> </span><span class="o">-&gt;</span><span class="w"> </span><span class="n">Bool</span><span class="p">)</span><span class="o">:</span><span class="w"> </span><span class="n">List</span><span class="p">(</span><span class="n">T</span><span class="p">)</span><span class="w"> </span><span class="o">=</span>
<span class="w">  </span><span class="n">match</span><span class="w"> </span><span class="n">list</span><span class="w"> </span><span class="n">do</span>
<span class="w">    </span><span class="p">[]</span><span class="w"> </span><span class="o">-&gt;</span><span class="w"> </span><span class="p">[]</span>
<span class="w">    </span><span class="p">[</span><span class="n">h</span><span class="w"> </span><span class="o">|</span><span class="w"> </span><span class="n">t</span><span class="p">]</span><span class="w"> </span><span class="o">-&gt;</span><span class="w"> </span>
<span class="w">      </span><span class="n">let</span><span class="w"> </span><span class="n">filtered_tail</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">filter</span><span class="p">(</span><span class="n">t</span><span class="p">,</span><span class="w"> </span><span class="n">predicate</span><span class="p">)</span>
<span class="w">      </span><span class="n">match</span><span class="w"> </span><span class="n">predicate</span><span class="p">(</span><span class="n">h</span><span class="p">)</span><span class="w"> </span><span class="n">do</span>
<span class="w">        </span><span class="kr">true</span><span class="w"> </span><span class="o">-&gt;</span><span class="w"> </span><span class="p">[</span><span class="n">h</span><span class="w"> </span><span class="o">|</span><span class="w"> </span><span class="n">filtered_tail</span><span class="p">]</span>
<span class="w">        </span><span class="kr">false</span><span class="w"> </span><span class="o">-&gt;</span><span class="w"> </span><span class="n">filtered_tail</span>
<span class="w">      </span><span class="kd">end</span>
<span class="w">  </span><span class="kd">end</span>
</code></pre></div>

<h3 id="lambda-functions">Lambda Functions</h3>
<p>Lambdas (anonymous functions) allow inline function definitions without naming them.</p>
<p><strong>Syntax</strong>: <code>fn(params) -&gt; expression end</code></p>
<h4 id="basic-lambda-expressions">Basic Lambda Expressions</h4>
<div class="codehilite"><pre><span></span><code><span class="c1"># Simple lambda (one parameter)</span>
<span class="n">let</span><span class="w"> </span><span class="n">double</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">fn</span><span class="p">(</span><span class="n">x</span><span class="p">)</span><span class="w"> </span><span class="o">-&gt;</span><span class="w"> </span><span class="n">x</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="mi">2</span><span class="w"> </span><span class="n">end</span>

<span class="c1"># Lambda with multiple parameters</span>
<span class="n">let</span><span class="w"> </span><span class="n">add</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">fn</span><span class="p">(</span><span class="n">x</span><span class="p">,</span><span class="w"> </span><span class="n">y</span><span class="p">)</span><span class="w"> </span><span class="o">-&gt;</span><span class="w"> </span><span class="n">x</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">y</span><span class="w"> </span><span class="n">end</span>

<span class="c1"># Zero-parameter lambda (thunk)</span>
<span class="n">let</span><span class="w"> </span><span class="n">get_constant</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">fn</span><span class="p">()</span><span class="w"> </span><span class="o">-&gt;</span><span class="w"> </span><span class="mi">42</span><span class="w"> </span><span class="n">end</span>
</code></pre></div>

<h4 id="type-inference">Type Inference</h4>
<p>Lambda parameter types are <strong>inferred from context</strong> - you don't need to annotate them:</p>
<div class="codehilite"><pre><span></span><code><span class="err">#</span><span class="w"> </span><span class="nx">Type</span><span class="w"> </span><span class="nx">inferred</span><span class="w"> </span><span class="nx">from</span><span class="w"> </span><span class="nx">list</span><span class="w"> </span><span class="nx">element</span><span class="w"> </span><span class="k">type</span>
<span class="kd">let</span><span class="w"> </span><span class="nx">doubled</span><span class="w"> </span><span class="p">=</span><span class="w"> </span><span class="nx">map</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="mi">2</span><span class="p">,</span><span class="w"> </span><span class="mi">3</span><span class="p">],</span><span class="w"> </span><span class="kd">fn</span><span class="p">(</span><span class="nx">x</span><span class="p">)</span><span class="w"> </span><span class="o">-&gt;</span><span class="w"> </span><span class="nx">x</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="mi">2</span><span class="w"> </span><span class="nx">end</span><span class="p">)</span>
<span class="err">#</span><span class="w"> </span><span class="nx">x</span><span class="w"> </span><span class="k">is</span><span class="w"> </span><span class="nx">inferred</span><span class="w"> </span><span class="nx">to</span><span class="w"> </span><span class="nx">be</span><span class="w"> </span><span class="nx">Int</span>

<span class="err">#</span><span class="w"> </span><span class="nx">Type</span><span class="w"> </span><span class="nx">inferred</span><span class="w"> </span><span class="nx">from</span><span class="w"> </span><span class="nx">function</span><span class="w"> </span><span class="nx">signature</span>
<span class="nx">def</span><span class="w"> </span><span class="nx">apply_twice</span><span class="p">(</span><span class="nx">f</span><span class="p">:</span><span class="w"> </span><span class="nx">Int</span><span class="w"> </span><span class="o">-&gt;</span><span class="w"> </span><span class="nx">Int</span><span class="p">,</span><span class="w"> </span><span class="nx">x</span><span class="p">:</span><span class="w"> </span><span class="nx">Int</span><span class="p">):</span><span class="w"> </span><span class="nx">Int</span><span class="w"> </span><span class="p">=</span>
<span class="w">  </span><span class="nx">f</span><span class="p">(</span><span class="nx">f</span><span class="p">(</span><span class="nx">x</span><span class="p">))</span>

<span class="kd">let</span><span class="w"> </span><span class="nx">result</span><span class="w"> </span><span class="p">=</span><span class="w"> </span><span class="nx">apply_twice</span><span class="p">(</span><span class="kd">fn</span><span class="p">(</span><span class="nx">n</span><span class="p">)</span><span class="w"> </span><span class="o">-&gt;</span><span class="w"> </span><span class="nx">n</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="mi">1</span><span class="w"> </span><span class="nx">end</span><span class="p">,</span><span class="w"> </span><span class="mi">5</span><span class="p">)</span>
<span class="err">#</span><span class="w"> </span><span class="nx">n</span><span class="w"> </span><span class="k">is</span><span class="w"> </span><span class="nx">inferred</span><span class="w"> </span><span class="nx">to</span><span class="w"> </span><span class="nx">be</span><span class="w"> </span><span class="nx">Int</span><span class="w"> </span><span class="nx">from</span><span class="w"> </span><span class="nx">apply_twice</span><span class="w"> </span><span class="nx">signature</span>
</code></pre></div>

<h4 id="nested-lambdas-currying">Nested Lambdas (Currying)</h4>
<p>Lambdas can return other lambdas for currying:</p>
<div class="codehilite"><pre><span></span><code><span class="cp"># Manual currying</span>
<span class="n">let</span><span class="w"> </span><span class="n">add</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">fn</span><span class="p">(</span><span class="n">x</span><span class="p">)</span><span class="w"> </span><span class="o">-&gt;</span><span class="w"> </span><span class="n">fn</span><span class="p">(</span><span class="n">y</span><span class="p">)</span><span class="w"> </span><span class="o">-&gt;</span><span class="w"> </span><span class="n">x</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">y</span><span class="w"> </span><span class="kd">end end</span>

<span class="cp"># Partial application (conceptually)</span>
<span class="cp"># let add_five = add(5)  # Returns fn(y) -&gt; 5 + y end</span>
<span class="cp"># let result = add_five(3)  # Returns 8</span>

<span class="cp"># Real example with fold</span>
<span class="n">let</span><span class="w"> </span><span class="nf">sum</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">fold</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="mi">2</span><span class="p">,</span><span class="w"> </span><span class="mi">3</span><span class="p">,</span><span class="w"> </span><span class="mi">4</span><span class="p">],</span><span class="w"> </span><span class="mi">0</span><span class="p">,</span><span class="w"> </span><span class="n">fn</span><span class="p">(</span><span class="n">x</span><span class="p">)</span><span class="w"> </span><span class="o">-&gt;</span><span class="w"> </span><span class="n">fn</span><span class="p">(</span><span class="n">acc</span><span class="p">)</span><span class="w"> </span><span class="o">-&gt;</span><span class="w"> </span><span class="n">x</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">acc</span><span class="w"> </span><span class="kd">end end)</span>
</code></pre></div>

<h4 id="closures-variable-capture">Closures (Variable Capture)</h4>
<p>Lambdas can capture variables from their surrounding scope:</p>
<div class="codehilite"><pre><span></span><code><span class="cp"># Capture from outer scope</span>
<span class="n">let</span><span class="w"> </span><span class="n">base</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">10</span>
<span class="n">let</span><span class="w"> </span><span class="n">add_base</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">fn</span><span class="p">(</span><span class="n">x</span><span class="p">)</span><span class="w"> </span><span class="o">-&gt;</span><span class="w"> </span><span class="n">x</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">base</span><span class="w"> </span><span class="kd">end</span>
<span class="cp"># add_base captures &#39;base&#39; (closure)</span>

<span class="n">let</span><span class="w"> </span><span class="n">result</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">add_base</span><span class="p">(</span><span class="mi">5</span><span class="p">)</span><span class="w">  </span><span class="err">#</span><span class="w"> </span><span class="n">Returns</span><span class="w"> </span><span class="mi">15</span>

<span class="cp"># Multiple captures</span>
<span class="n">def</span><span class="w"> </span><span class="n">make_adder</span><span class="p">(</span><span class="n">x</span><span class="o">:</span><span class="w"> </span><span class="n">Int</span><span class="p">)</span><span class="o">:</span><span class="w"> </span><span class="n">Int</span><span class="w"> </span><span class="o">-&gt;</span><span class="w"> </span><span class="n">Int</span><span class="w"> </span><span class="o">=</span>
<span class="w">  </span><span class="n">fn</span><span class="p">(</span><span class="n">y</span><span class="p">)</span><span class="w"> </span><span class="o">-&gt;</span><span class="w"> </span><span class="n">x</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">y</span><span class="w"> </span><span class="kd">end</span>
<span class="cp"># Returns a lambda that captures x</span>

<span class="n">let</span><span class="w"> </span><span class="n">add_five</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">make_adder</span><span class="p">(</span><span class="mi">5</span><span class="p">)</span>
<span class="n">let</span><span class="w"> </span><span class="n">result</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">add_five</span><span class="p">(</span><span class="mi">3</span><span class="p">)</span><span class="w">  </span><span class="err">#</span><span class="w"> </span><span class="n">Returns</span><span class="w"> </span><span class="mi">8</span>
</code></pre></div>

<h4 id="lambdas-in-higher-order-functions">Lambdas in Higher-Order Functions</h4>
<p>Most common use is passing lambdas to higher-order functions:</p>
<div class="codehilite"><pre><span></span><code><span class="kn">import</span><span class="w"> </span><span class="nn">Std.List</span><span class="w"> </span><span class="p">[</span><span class="nb">map</span><span class="o">/</span><span class="mi">2</span><span class="p">,</span><span class="w"> </span><span class="nb">filter</span><span class="o">/</span><span class="mi">2</span><span class="p">,</span><span class="w"> </span><span class="n">fold</span><span class="o">/</span><span class="mi">3</span><span class="p">]</span>

<span class="c1"># Map: transform each element</span>
<span class="n">let</span><span class="w"> </span><span class="n">doubled</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nb">map</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="mi">2</span><span class="p">,</span><span class="w"> </span><span class="mi">3</span><span class="p">,</span><span class="w"> </span><span class="mi">4</span><span class="p">,</span><span class="w"> </span><span class="mi">5</span><span class="p">],</span><span class="w"> </span><span class="n">fn</span><span class="p">(</span><span class="n">x</span><span class="p">)</span><span class="w"> </span><span class="o">-&gt;</span><span class="w"> </span><span class="n">x</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="mi">2</span><span class="w"> </span><span class="n">end</span><span class="p">)</span>
<span class="c1"># Result: [2, 4, 6, 8, 10]</span>

<span class="c1"># Filter: select elements</span>
<span class="n">let</span><span class="w"> </span><span class="n">evens</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nb">filter</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="mi">2</span><span class="p">,</span><span class="w"> </span><span class="mi">3</span><span class="p">,</span><span class="w"> </span><span class="mi">4</span><span class="p">,</span><span class="w"> </span><span class="mi">5</span><span class="p">],</span><span class="w"> </span><span class="n">fn</span><span class="p">(</span><span class="n">x</span><span class="p">)</span><span class="w"> </span><span class="o">-&gt;</span><span class="w"> </span><span class="n">x</span><span class="w"> </span><span class="o">%</span><span class="w"> </span><span class="mi">2</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="mi">0</span><span class="w"> </span><span class="n">end</span><span class="p">)</span>
<span class="c1"># Result: [2, 4]</span>

<span class="c1"># Fold: aggregate with accumulator</span>
<span class="n">let</span><span class="w"> </span><span class="nb">sum</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">fold</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="mi">2</span><span class="p">,</span><span class="w"> </span><span class="mi">3</span><span class="p">,</span><span class="w"> </span><span class="mi">4</span><span class="p">,</span><span class="w"> </span><span class="mi">5</span><span class="p">],</span><span class="w"> </span><span class="mi">0</span><span class="p">,</span><span class="w"> </span>
<span class="w">               </span><span class="n">fn</span><span class="p">(</span><span class="n">x</span><span class="p">)</span><span class="w"> </span><span class="o">-&gt;</span><span class="w"> </span><span class="n">fn</span><span class="p">(</span><span class="n">acc</span><span class="p">)</span><span class="w"> </span><span class="o">-&gt;</span><span class="w"> </span><span class="n">x</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">acc</span><span class="w"> </span><span class="n">end</span><span class="w"> </span><span class="n">end</span><span class="p">)</span>
<span class="c1"># Result: 15</span>

<span class="c1"># Chain operations</span>
<span class="n">let</span><span class="w"> </span><span class="n">result</span><span class="w"> </span><span class="o">=</span><span class="w"> </span>
<span class="w">  </span><span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="mi">2</span><span class="p">,</span><span class="w"> </span><span class="mi">3</span><span class="p">,</span><span class="w"> </span><span class="mi">4</span><span class="p">,</span><span class="w"> </span><span class="mi">5</span><span class="p">]</span>
<span class="w">  </span><span class="o">|&gt;</span><span class="w"> </span><span class="nb">map</span><span class="p">(</span><span class="n">fn</span><span class="p">(</span><span class="n">x</span><span class="p">)</span><span class="w"> </span><span class="o">-&gt;</span><span class="w"> </span><span class="n">x</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="mi">2</span><span class="w"> </span><span class="n">end</span><span class="p">)</span>
<span class="w">  </span><span class="o">|&gt;</span><span class="w"> </span><span class="nb">filter</span><span class="p">(</span><span class="n">fn</span><span class="p">(</span><span class="n">x</span><span class="p">)</span><span class="w"> </span><span class="o">-&gt;</span><span class="w"> </span><span class="n">x</span><span class="w"> </span><span class="o">&gt;</span><span class="w"> </span><span class="mi">5</span><span class="w"> </span><span class="n">end</span><span class="p">)</span>
<span class="w">  </span><span class="o">|&gt;</span><span class="w"> </span><span class="n">fold</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="w"> </span><span class="n">fn</span><span class="p">(</span><span class="n">x</span><span class="p">)</span><span class="w"> </span><span class="o">-&gt;</span><span class="w"> </span><span class="n">fn</span><span class="p">(</span><span class="n">acc</span><span class="p">)</span><span class="w"> </span><span class="o">-&gt;</span><span class="w"> </span><span class="n">x</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">acc</span><span class="w"> </span><span class="n">end</span><span class="w"> </span><span class="n">end</span><span class="p">)</span>
</code></pre></div>

<h4 id="complex-lambda-bodies">Complex Lambda Bodies</h4>
<p>Lambda bodies can contain any expression, including pattern matching:</p>
<div class="codehilite"><pre><span></span><code><span class="gh">#</span> Lambda with match expression
let classify = fn(x) -&gt;
  match x do
    n when n &gt; 0 -&gt; &quot;positive&quot;
    0 -&gt; &quot;zero&quot;
    _ -&gt; &quot;negative&quot;
  end
end

<span class="gh">#</span> Lambda with let bindings
let compute = fn(x) -&gt;
  let doubled = x <span class="gs">* 2</span>
<span class="gs">  let squared = doubled *</span> doubled
  squared + 1
end
</code></pre></div>

<h4 id="limitations">Limitations</h4>
<p><strong>Recursive Lambdas</strong>: Lambdas cannot directly call themselves (they're anonymous).<br />
Use named functions for recursion:</p>
<div class="codehilite"><pre><span></span><code><span class="gh">#</span> ❌ Won&#39;t work - lambda can&#39;t reference itself
let factorial = fn(n) -&gt;
  match n do
    0 -&gt; 1
    _ -&gt; n * factorial(n - 1)  # Error: factorial undefined
  end
end

<span class="gh">#</span> ✅ Use named function instead
def factorial(n: Nat): Nat =
  match n do
    Zero -&gt; Succ(Zero)
    Succ(pred) -&gt; mult(n, factorial(pred))
  end
</code></pre></div>

<p><strong>Direct Invocation</strong>: Directly calling a lambda literal may require binding first:</p>
<div class="codehilite"><pre><span></span><code><span class="c1"># May not work:</span>
<span class="c1"># (fn(x) -&gt; x + 1 end)(5)</span>

<span class="c1"># Instead, bind to variable:</span>
<span class="n">let</span><span class="w"> </span><span class="n">increment</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">fn</span><span class="p">(</span><span class="n">x</span><span class="p">)</span><span class="w"> </span><span class="o">-&gt;</span><span class="w"> </span><span class="n">x</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="mi">1</span><span class="w"> </span><span class="n">end</span>
<span class="n">let</span><span class="w"> </span><span class="n">result</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">increment</span><span class="p">(</span><span class="mi">5</span><span class="p">)</span><span class="w">  </span><span class="c1"># Works</span>
</code></pre></div>

<h3 id="function-guards">Function Guards ✅</h3>
<p>Function-level guards use <code>when</code> clauses to specify preconditions:</p>
<div class="codehilite"><pre><span></span><code><span class="gh">#</span> Basic guard
def is_positive(x: Int): Bool when x &gt; 0 = true
def is_positive(_x: Int): Bool = false

<span class="gh">#</span> Multi-clause with guards
def abs(x: Int): Int when x &gt;= 0 = x
def abs(x: Int): Int = 0 - x

<span class="gh">#</span> Sign function with complete coverage
def sign(x: Int): Int when x &gt; 0 = 1
def sign(x: Int): Int when x == 0 = 0
def sign(x: Int): Int = -1

<span class="gh">#</span> Guards with AND
def in_range(x: Int, min: Int, max: Int): Bool 
  when x &gt;= min and x &lt;= max = true
def in_range(_x: Int, _min: Int, _max: Int): Bool = false

<span class="gh">#</span> Guards with OR
def is_extreme(x: Int): Bool 
  when x &gt; 100 or x &lt; -100 = true
def is_extreme(_x: Int): Bool = false

<span class="gh">#</span> Real-world example: tax brackets
def tax_rate(income: Int): Float when income &lt;= 10000 = 0.0
def tax_rate(income: Int): Float 
  when income &gt; 10000 and income &lt;= 40000 = 0.1
def tax_rate(income: Int): Float 
  when income &gt; 40000 and income &lt;= 100000 = 0.2
def tax_rate(_income: Int): Float = 0.3
</code></pre></div>

<p><strong>Guard Features</strong>:<br />
- Comparison operators: <code>&gt;</code>, <code>&lt;</code>, <code>&gt;=</code>, <code>&lt;=</code>, <code>==</code>, <code>!=</code><br />
- Logical operators: <code>and</code>, <code>or</code><br />
- Type refinement: Guards narrow types in function bodies<br />
- SMT verification: Completeness and consistency checking<br />
- Coverage analysis: Detects unreachable clauses</p>
<p><strong>See</strong>: <code>examples/06_comprehensive_guards_demo.cure</code> for complete examples</p>
<hr />
<h2 id="5-pattern-matching">5. Pattern Matching</h2>
<h3 id="match-expression-structure">Match Expression Structure</h3>
<div class="codehilite"><pre><span></span><code><span class="n">match</span><span class="w"> </span><span class="n">value</span><span class="w"> </span><span class="n">do</span>
<span class="w">  </span><span class="kt">pattern1</span><span class="w"> </span><span class="o">-&gt;</span><span class="w"> </span><span class="n">result1</span>
<span class="w">  </span><span class="kt">pattern2</span><span class="w"> </span><span class="o">-&gt;</span><span class="w"> </span><span class="n">result2</span>
<span class="w">  </span><span class="n">_</span><span class="w"> </span><span class="o">-&gt;</span><span class="w"> </span><span class="n">default_result</span>
<span class="kd">end</span>
</code></pre></div>

<h3 id="pattern-guards">Pattern Guards</h3>
<p>Guards allow additional conditions on patterns using <code>when</code>:</p>
<div class="codehilite"><pre><span></span><code><span class="n">match</span><span class="w"> </span><span class="n">value</span><span class="w"> </span><span class="n">do</span>
<span class="w">  </span><span class="n">x</span><span class="w"> </span><span class="kr">when</span><span class="w"> </span><span class="n">x</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="mi">0</span><span class="w"> </span><span class="o">-&gt;</span><span class="w"> </span><span class="s">&quot;Negative&quot;</span>
<span class="w">  </span><span class="n">x</span><span class="w"> </span><span class="kr">when</span><span class="w"> </span><span class="n">x</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="mi">0</span><span class="w"> </span><span class="o">-&gt;</span><span class="w"> </span><span class="s">&quot;Zero&quot;</span>
<span class="w">  </span><span class="n">x</span><span class="w"> </span><span class="kr">when</span><span class="w"> </span><span class="n">x</span><span class="w"> </span><span class="o">&gt;</span><span class="w"> </span><span class="mi">0</span><span class="w"> </span><span class="o">-&gt;</span><span class="w"> </span><span class="s">&quot;Positive&quot;</span>
<span class="kd">end</span>

<span class="cp"># Multiple conditions with logical operators</span>
<span class="n">match</span><span class="w"> </span><span class="n">n</span><span class="w"> </span><span class="n">do</span>
<span class="w">  </span><span class="n">x</span><span class="w"> </span><span class="kr">when</span><span class="w"> </span><span class="n">x</span><span class="w"> </span><span class="o">&gt;=</span><span class="w"> </span><span class="mi">10</span><span class="w"> </span><span class="kr">and</span><span class="w"> </span><span class="n">x</span><span class="w"> </span><span class="o">&lt;=</span><span class="w"> </span><span class="mi">20</span><span class="w"> </span><span class="o">-&gt;</span><span class="w"> </span><span class="s">&quot;In range&quot;</span>
<span class="w">  </span><span class="n">x</span><span class="w"> </span><span class="kr">when</span><span class="w"> </span><span class="n">x</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="mi">10</span><span class="w"> </span><span class="kr">or</span><span class="w"> </span><span class="n">x</span><span class="w"> </span><span class="o">&gt;</span><span class="w"> </span><span class="mi">20</span><span class="w"> </span><span class="o">-&gt;</span><span class="w"> </span><span class="s">&quot;Out of range&quot;</span>
<span class="kd">end</span>

<span class="cp"># Guards with record patterns</span>
<span class="n">match</span><span class="w"> </span><span class="n">point</span><span class="w"> </span><span class="n">do</span>
<span class="w">  </span><span class="n">Point</span><span class="p">{</span><span class="n">x</span><span class="o">:</span><span class="w"> </span><span class="n">x</span><span class="p">,</span><span class="w"> </span><span class="n">y</span><span class="o">:</span><span class="w"> </span><span class="n">y</span><span class="p">}</span><span class="w"> </span><span class="kr">when</span><span class="w"> </span><span class="n">x</span><span class="w"> </span><span class="o">&gt;</span><span class="w"> </span><span class="mf">0.0</span><span class="w"> </span><span class="kr">and</span><span class="w"> </span><span class="n">y</span><span class="w"> </span><span class="o">&gt;</span><span class="w"> </span><span class="mf">0.0</span><span class="w"> </span><span class="o">-&gt;</span>
<span class="w">    </span><span class="s">&quot;First quadrant&quot;</span>
<span class="w">  </span><span class="n">Point</span><span class="p">{</span><span class="n">x</span><span class="o">:</span><span class="w"> </span><span class="n">x</span><span class="p">,</span><span class="w"> </span><span class="n">y</span><span class="o">:</span><span class="w"> </span><span class="n">_</span><span class="p">}</span><span class="w"> </span><span class="kr">when</span><span class="w"> </span><span class="n">x</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="mf">0.0</span><span class="w"> </span><span class="o">-&gt;</span>
<span class="w">    </span><span class="s">&quot;On Y-axis&quot;</span>
<span class="kd">end</span>
</code></pre></div>

<h3 id="list-patterns">List Patterns</h3>
<div class="codehilite"><pre><span></span><code><span class="n">match</span><span class="w"> </span><span class="n">list</span><span class="w"> </span><span class="n">do</span>
<span class="w">  </span><span class="p">[]</span><span class="w"> </span><span class="o">-&gt;</span><span class="w"> </span><span class="err">#</span><span class="w"> </span><span class="n">empty</span><span class="w"> </span><span class="n">list</span>
<span class="w">  </span><span class="p">[</span><span class="n">h</span><span class="w"> </span><span class="o">|</span><span class="w"> </span><span class="n">t</span><span class="p">]</span><span class="w"> </span><span class="o">-&gt;</span><span class="w"> </span><span class="err">#</span><span class="w"> </span><span class="n">head</span><span class="w"> </span><span class="kr">and</span><span class="w"> </span><span class="n">tail</span>
<span class="w">  </span><span class="p">[</span><span class="n">a</span><span class="p">,</span><span class="w"> </span><span class="n">b</span><span class="p">,</span><span class="w"> </span><span class="n">c</span><span class="p">]</span><span class="w"> </span><span class="o">-&gt;</span><span class="w"> </span><span class="err">#</span><span class="w"> </span><span class="n">exact</span><span class="w"> </span><span class="nf">length</span><span class="w"> </span><span class="p">(</span><span class="nf">if</span><span class="w"> </span><span class="n">supported</span><span class="p">)</span>
<span class="kd">end</span>
</code></pre></div>

<h3 id="constructor-patterns">Constructor Patterns</h3>
<div class="codehilite"><pre><span></span><code><span class="n">match</span><span class="w"> </span><span class="n">result</span><span class="w"> </span><span class="n">do</span>
<span class="w">  </span><span class="n">Ok</span><span class="p">(</span><span class="n">value</span><span class="p">)</span><span class="w"> </span><span class="o">-&gt;</span><span class="w"> </span><span class="err">#</span><span class="w"> </span><span class="kr">success</span><span class="w"> </span><span class="kr">case</span>
<span class="w">  </span><span class="nf">Error</span><span class="p">(</span><span class="n">err</span><span class="p">)</span><span class="w"> </span><span class="o">-&gt;</span><span class="w"> </span><span class="err">#</span><span class="w"> </span><span class="nf">error</span><span class="w"> </span><span class="kr">case</span>
<span class="kd">end</span>

<span class="n">match</span><span class="w"> </span><span class="n">option</span><span class="w"> </span><span class="n">do</span>
<span class="w">  </span><span class="n">Some</span><span class="p">(</span><span class="n">value</span><span class="p">)</span><span class="w"> </span><span class="o">-&gt;</span><span class="w"> </span><span class="err">#</span><span class="w"> </span><span class="n">present</span>
<span class="w">  </span><span class="n">None</span><span class="w"> </span><span class="o">-&gt;</span><span class="w"> </span><span class="err">#</span><span class="w"> </span><span class="n">absent</span>
<span class="kd">end</span>
</code></pre></div>

<h3 id="nested-match">Nested Match</h3>
<div class="codehilite"><pre><span></span><code><span class="n">match</span><span class="w"> </span><span class="n">list</span><span class="w"> </span><span class="n">do</span>
<span class="w">  </span><span class="p">[]</span><span class="w"> </span><span class="o">-&gt;</span><span class="w"> </span><span class="p">[]</span>
<span class="w">  </span><span class="p">[</span><span class="n">h</span><span class="w"> </span><span class="o">|</span><span class="w"> </span><span class="n">t</span><span class="p">]</span><span class="w"> </span><span class="o">-&gt;</span>
<span class="w">    </span><span class="n">match</span><span class="w"> </span><span class="n">predicate</span><span class="p">(</span><span class="n">h</span><span class="p">)</span><span class="w"> </span><span class="n">do</span>
<span class="w">      </span><span class="kr">true</span><span class="w"> </span><span class="o">-&gt;</span><span class="w"> </span><span class="p">[</span><span class="n">h</span><span class="w"> </span><span class="o">|</span><span class="w"> </span><span class="n">filtered_tail</span><span class="p">]</span>
<span class="w">      </span><span class="kr">false</span><span class="w"> </span><span class="o">-&gt;</span><span class="w"> </span><span class="n">filtered_tail</span>
<span class="w">    </span><span class="kd">end</span>
<span class="kd">end</span>
</code></pre></div>

<hr />
<h2 id="6-type-annotations">6. Type Annotations</h2>
<h3 id="function-types">Function Types</h3>
<p>Arrow notation for function types:</p>
<div class="codehilite"><pre><span></span><code><span class="cp"># Function taking T, returning U</span>
<span class="n">T</span><span class="w"> </span><span class="o">-&gt;</span><span class="w"> </span><span class="n">U</span>

<span class="cp"># Function taking two params</span>
<span class="n">T</span><span class="w"> </span><span class="o">-&gt;</span><span class="w"> </span><span class="n">U</span><span class="w"> </span><span class="o">-&gt;</span><span class="w"> </span><span class="n">V</span>

<span class="cp"># Can be curried</span>
<span class="n">def</span><span class="w"> </span><span class="n">func</span><span class="p">(</span><span class="n">x</span><span class="o">:</span><span class="w"> </span><span class="n">T</span><span class="p">)</span><span class="o">:</span><span class="w"> </span><span class="n">U</span><span class="w"> </span><span class="o">-&gt;</span><span class="w"> </span><span class="n">V</span><span class="w"> </span><span class="o">=</span>
<span class="w">  </span><span class="n">fn</span><span class="p">(</span><span class="n">y</span><span class="p">)</span><span class="w"> </span><span class="o">-&gt;</span><span class="w"> </span><span class="n">result</span><span class="w"> </span><span class="kd">end</span>
</code></pre></div>

<h3 id="polymorphic-types">Polymorphic Types</h3>
<p>Generic type parameters:</p>
<div class="codehilite"><pre><span></span><code><span class="n">def</span><span class="w"> </span><span class="n">identity</span><span class="p">(</span><span class="n">x</span><span class="o">:</span><span class="w"> </span><span class="n">T</span><span class="p">)</span><span class="o">:</span><span class="w"> </span><span class="n">T</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">x</span>
<span class="n">def</span><span class="w"> </span><span class="nf">map</span><span class="p">(</span><span class="n">list</span><span class="o">:</span><span class="w"> </span><span class="n">List</span><span class="p">(</span><span class="n">T</span><span class="p">),</span><span class="w"> </span><span class="n">f</span><span class="o">:</span><span class="w"> </span><span class="n">T</span><span class="w"> </span><span class="o">-&gt;</span><span class="w"> </span><span class="n">U</span><span class="p">)</span><span class="o">:</span><span class="w"> </span><span class="n">List</span><span class="p">(</span><span class="n">U</span><span class="p">)</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">...</span>
</code></pre></div>

<hr />
<h2 id="7-literals-and-basic-types">7. Literals and Basic Types</h2>
<h3 id="primitives">Primitives</h3>
<div class="codehilite"><pre><span></span><code><span class="mf">42</span><span class="w">              </span><span class="err">#</span><span class="w"> </span><span class="nb">Int</span>
<span class="mf">3.14</span><span class="w">            </span><span class="err">#</span><span class="w"> </span><span class="n">Float</span>
<span class="s">&quot;hello&quot;</span><span class="w">         </span><span class="err">#</span><span class="w"> </span><span class="n">String</span>
<span class="n">true</span><span class="w">            </span><span class="err">#</span><span class="w"> </span><span class="n">Bool</span>
<span class="n">false</span><span class="w">           </span><span class="err">#</span><span class="w"> </span><span class="n">Bool</span>
<span class="p">:</span><span class="n">atom_name</span><span class="w">      </span><span class="err">#</span><span class="w"> </span><span class="n">Atom</span>
</code></pre></div>

<h3 id="lists">Lists</h3>
<div class="codehilite"><pre><span></span><code><span class="p">[]</span><span class="w">              </span><span class="c1"># Empty list</span>
<span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="mi">2</span><span class="p">,</span><span class="w"> </span><span class="mi">3</span><span class="p">]</span><span class="w">       </span><span class="c1"># List of integers</span>
<span class="p">[</span><span class="n">h</span><span class="w"> </span><span class="o">|</span><span class="w"> </span><span class="n">t</span><span class="p">]</span><span class="w">         </span><span class="c1"># Cons pattern/constructor</span>
</code></pre></div>

<h3 id="tuples">Tuples</h3>
<p>Tuples group multiple values of potentially different types together.</p>
<p><strong>Syntax</strong>: <code>{elem1, elem2, ...}</code></p>
<h4 id="creating-tuples">Creating Tuples</h4>
<div class="codehilite"><pre><span></span><code><span class="err">#</span><span class="w"> </span><span class="nx">Empty</span><span class="w"> </span><span class="nx">tuple</span>
<span class="kd">let</span><span class="w"> </span><span class="nx">empty</span><span class="w"> </span><span class="p">=</span><span class="w"> </span><span class="p">{}</span>

<span class="err">#</span><span class="w"> </span><span class="nx">Two</span><span class="o">-</span><span class="nx">element</span><span class="w"> </span><span class="nx">tuple</span><span class="w"> </span><span class="p">(</span><span class="nx">pair</span><span class="p">)</span>
<span class="kd">let</span><span class="w"> </span><span class="nx">pair</span><span class="w"> </span><span class="p">=</span><span class="w"> </span><span class="p">{</span><span class="mi">10</span><span class="p">,</span><span class="w"> </span><span class="mi">20</span><span class="p">}</span>
<span class="kd">let</span><span class="w"> </span><span class="nx">point</span><span class="w"> </span><span class="p">=</span><span class="w"> </span><span class="p">{</span><span class="m m-Double">3.0</span><span class="p">,</span><span class="w"> </span><span class="m m-Double">4.0</span><span class="p">}</span>

<span class="err">#</span><span class="w"> </span><span class="nx">Three</span><span class="o">-</span><span class="nx">element</span><span class="w"> </span><span class="nx">tuple</span>
<span class="kd">let</span><span class="w"> </span><span class="nx">triple</span><span class="w"> </span><span class="p">=</span><span class="w"> </span><span class="p">{</span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="s">&quot;hello&quot;</span><span class="p">,</span><span class="w"> </span><span class="kc">true</span><span class="p">}</span>

<span class="err">#</span><span class="w"> </span><span class="nx">Nested</span><span class="w"> </span><span class="nx">tuples</span>
<span class="kd">let</span><span class="w"> </span><span class="nx">nested</span><span class="w"> </span><span class="p">=</span><span class="w"> </span><span class="p">{{</span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="mi">2</span><span class="p">},</span><span class="w"> </span><span class="p">{</span><span class="mi">3</span><span class="p">,</span><span class="w"> </span><span class="mi">4</span><span class="p">}}</span>

<span class="err">#</span><span class="w"> </span><span class="nx">Mixed</span><span class="w"> </span><span class="nx">with</span><span class="w"> </span><span class="nx">other</span><span class="w"> </span><span class="nx">types</span>
<span class="kd">let</span><span class="w"> </span><span class="nx">mixed</span><span class="w"> </span><span class="p">=</span><span class="w"> </span><span class="p">{[</span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="mi">2</span><span class="p">,</span><span class="w"> </span><span class="mi">3</span><span class="p">],</span><span class="w"> </span><span class="s">&quot;numbers&quot;</span><span class="p">,</span><span class="w"> </span><span class="nx">Ok</span><span class="p">(</span><span class="mi">42</span><span class="p">)}</span>
</code></pre></div>

<h4 id="tuple-pattern-matching">Tuple Pattern Matching</h4>
<p>Tuples can be destructured in match expressions:</p>
<div class="codehilite"><pre><span></span><code><span class="cp"># Match on tuple</span>
<span class="n">let</span><span class="w"> </span><span class="n">point</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">{</span><span class="mi">5</span><span class="p">,</span><span class="w"> </span><span class="mi">10</span><span class="p">}</span>
<span class="n">match</span><span class="w"> </span><span class="n">point</span><span class="w"> </span><span class="n">do</span>
<span class="w">  </span><span class="p">{</span><span class="mi">0</span><span class="p">,</span><span class="w"> </span><span class="mi">0</span><span class="p">}</span><span class="w"> </span><span class="o">-&gt;</span><span class="w"> </span><span class="s">&quot;Origin&quot;</span>
<span class="w">  </span><span class="p">{</span><span class="n">x</span><span class="p">,</span><span class="w"> </span><span class="mi">0</span><span class="p">}</span><span class="w"> </span><span class="o">-&gt;</span><span class="w"> </span><span class="s">&quot;On X-axis&quot;</span>
<span class="w">  </span><span class="p">{</span><span class="mi">0</span><span class="p">,</span><span class="w"> </span><span class="n">y</span><span class="p">}</span><span class="w"> </span><span class="o">-&gt;</span><span class="w"> </span><span class="s">&quot;On Y-axis&quot;</span>
<span class="w">  </span><span class="p">{</span><span class="n">x</span><span class="p">,</span><span class="w"> </span><span class="n">y</span><span class="p">}</span><span class="w"> </span><span class="o">-&gt;</span><span class="w"> </span><span class="s">&quot;General point&quot;</span>
<span class="kd">end</span>

<span class="cp"># Match with literals</span>
<span class="n">match</span><span class="w"> </span><span class="n">tuple</span><span class="w"> </span><span class="n">do</span>
<span class="w">  </span><span class="p">{</span><span class="mi">0</span><span class="p">,</span><span class="w"> </span><span class="mi">0</span><span class="p">}</span><span class="w"> </span><span class="o">-&gt;</span><span class="w"> </span><span class="s">&quot;Both zero&quot;</span>
<span class="w">  </span><span class="p">{</span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="mi">2</span><span class="p">}</span><span class="w"> </span><span class="o">-&gt;</span><span class="w"> </span><span class="s">&quot;Exact match&quot;</span>
<span class="w">  </span><span class="p">{</span><span class="n">x</span><span class="p">,</span><span class="w"> </span><span class="n">y</span><span class="p">}</span><span class="w"> </span><span class="o">-&gt;</span><span class="w"> </span><span class="s">&quot;Any other pair&quot;</span>
<span class="kd">end</span>

<span class="cp"># Match with wildcards</span>
<span class="n">match</span><span class="w"> </span><span class="p">{</span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="mi">2</span><span class="p">,</span><span class="w"> </span><span class="mi">3</span><span class="p">,</span><span class="w"> </span><span class="mi">4</span><span class="p">,</span><span class="w"> </span><span class="mi">5</span><span class="p">}</span><span class="w"> </span><span class="n">do</span>
<span class="w">  </span><span class="p">{</span><span class="kr">first</span><span class="p">,</span><span class="w"> </span><span class="n">_</span><span class="p">,</span><span class="w"> </span><span class="n">_</span><span class="p">,</span><span class="w"> </span><span class="n">_</span><span class="p">,</span><span class="w"> </span><span class="kr">last</span><span class="p">}</span><span class="w"> </span><span class="o">-&gt;</span><span class="w"> </span><span class="err">#</span><span class="w"> </span><span class="kr">Only</span><span class="w"> </span><span class="n">care</span><span class="w"> </span><span class="n">about</span><span class="w"> </span><span class="kr">first</span><span class="w"> </span><span class="kr">and</span><span class="w"> </span><span class="kr">last</span>
<span class="kd">end</span>
</code></pre></div>

<h4 id="nested-tuple-patterns">Nested Tuple Patterns</h4>
<div class="codehilite"><pre><span></span><code><span class="x"># Match nested tuples</span>
<span class="x">let nested = </span><span class="cp">{{</span><span class="m">1</span><span class="o">,</span> <span class="m">2</span><span class="o">},</span> <span class="o">{</span><span class="m">3</span><span class="o">,</span> <span class="m">4</span><span class="cp">}}</span>
<span class="x">match nested do</span>
<span class="x">  </span><span class="cp">{{</span><span class="nv">a</span><span class="o">,</span> <span class="nv">b</span><span class="o">},</span> <span class="o">{</span><span class="nv">c</span><span class="o">,</span> <span class="nv">d</span><span class="cp">}}</span><span class="x"> -&gt; a + b + c + d</span>
<span class="x">end</span>

<span class="x"># Deeply nested</span>
<span class="x">let deep = {1, {2, {3, 4}}}</span>
<span class="x">match deep do</span>
<span class="x">  {x, {y, {z, w}}} -&gt; &quot;All extracted&quot;</span>
<span class="x">end</span>
</code></pre></div>

<h4 id="tuples-with-guards">Tuples with Guards</h4>
<div class="codehilite"><pre><span></span><code><span class="cp"># Classify points by quadrant</span>
<span class="n">match</span><span class="w"> </span><span class="p">{</span><span class="n">x</span><span class="p">,</span><span class="w"> </span><span class="n">y</span><span class="p">}</span><span class="w"> </span><span class="n">do</span>
<span class="w">  </span><span class="p">{</span><span class="n">x</span><span class="p">,</span><span class="w"> </span><span class="n">y</span><span class="p">}</span><span class="w"> </span><span class="kr">when</span><span class="w"> </span><span class="n">x</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="mi">0</span><span class="w"> </span><span class="kr">and</span><span class="w"> </span><span class="n">y</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="mi">0</span><span class="w"> </span><span class="o">-&gt;</span><span class="w"> </span><span class="s">&quot;origin&quot;</span>
<span class="w">  </span><span class="p">{</span><span class="n">x</span><span class="p">,</span><span class="w"> </span><span class="n">y</span><span class="p">}</span><span class="w"> </span><span class="kr">when</span><span class="w"> </span><span class="n">x</span><span class="w"> </span><span class="o">&gt;</span><span class="w"> </span><span class="mi">0</span><span class="w"> </span><span class="kr">and</span><span class="w"> </span><span class="n">y</span><span class="w"> </span><span class="o">&gt;</span><span class="w"> </span><span class="mi">0</span><span class="w"> </span><span class="o">-&gt;</span><span class="w"> </span><span class="s">&quot;quadrant-1&quot;</span>
<span class="w">  </span><span class="p">{</span><span class="n">x</span><span class="p">,</span><span class="w"> </span><span class="n">y</span><span class="p">}</span><span class="w"> </span><span class="kr">when</span><span class="w"> </span><span class="n">x</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="mi">0</span><span class="w"> </span><span class="kr">and</span><span class="w"> </span><span class="n">y</span><span class="w"> </span><span class="o">&gt;</span><span class="w"> </span><span class="mi">0</span><span class="w"> </span><span class="o">-&gt;</span><span class="w"> </span><span class="s">&quot;quadrant-2&quot;</span>
<span class="w">  </span><span class="p">{</span><span class="n">x</span><span class="p">,</span><span class="w"> </span><span class="n">y</span><span class="p">}</span><span class="w"> </span><span class="kr">when</span><span class="w"> </span><span class="n">x</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="mi">0</span><span class="w"> </span><span class="kr">and</span><span class="w"> </span><span class="n">y</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="mi">0</span><span class="w"> </span><span class="o">-&gt;</span><span class="w"> </span><span class="s">&quot;quadrant-3&quot;</span>
<span class="w">  </span><span class="p">{</span><span class="n">x</span><span class="p">,</span><span class="w"> </span><span class="n">y</span><span class="p">}</span><span class="w"> </span><span class="kr">when</span><span class="w"> </span><span class="n">x</span><span class="w"> </span><span class="o">&gt;</span><span class="w"> </span><span class="mi">0</span><span class="w"> </span><span class="kr">and</span><span class="w"> </span><span class="n">y</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="mi">0</span><span class="w"> </span><span class="o">-&gt;</span><span class="w"> </span><span class="s">&quot;quadrant-4&quot;</span>
<span class="w">  </span><span class="p">{</span><span class="n">x</span><span class="p">,</span><span class="w"> </span><span class="mi">0</span><span class="p">}</span><span class="w"> </span><span class="o">-&gt;</span><span class="w"> </span><span class="s">&quot;x-axis&quot;</span>
<span class="w">  </span><span class="p">{</span><span class="mi">0</span><span class="p">,</span><span class="w"> </span><span class="n">y</span><span class="p">}</span><span class="w"> </span><span class="o">-&gt;</span><span class="w"> </span><span class="s">&quot;y-axis&quot;</span>
<span class="kd">end</span>
</code></pre></div>

<h4 id="tuples-in-function-parameters">Tuples in Function Parameters</h4>
<div class="codehilite"><pre><span></span><code><span class="x"># Function taking a tuple</span>
<span class="x">def distance(point: {Int, Int}): Int =</span>
<span class="x">  match point do</span>
<span class="x">    {x, y} -&gt; x * x + y * y</span>
<span class="x">  end</span>

<span class="x"># Multiple tuple parameters</span>
<span class="x">def distance_between(p1: {Int, Int}, p2: {Int, Int}): Int =</span>
<span class="x">  match {p1, p2} do</span>
<span class="x">    </span><span class="cp">{{</span><span class="nv">x1</span><span class="o">,</span> <span class="nv">y1</span><span class="o">},</span> <span class="o">{</span><span class="nv">x2</span><span class="o">,</span> <span class="nv">y2</span><span class="cp">}}</span><span class="x"> -&gt;</span>
<span class="x">      let dx = x2 - x1</span>
<span class="x">      let dy = y2 - y1</span>
<span class="x">      dx * dx + dy * dy</span>
<span class="x">  end</span>
</code></pre></div>

<h4 id="returning-multiple-values">Returning Multiple Values</h4>
<p>Tuples are useful for returning multiple values:</p>
<div class="codehilite"><pre><span></span><code><span class="cp"># Return quotient and remainder</span>
<span class="n">def</span><span class="w"> </span><span class="n">divide_with_remainder</span><span class="p">(</span><span class="n">a</span><span class="o">:</span><span class="w"> </span><span class="n">Int</span><span class="p">,</span><span class="w"> </span><span class="n">b</span><span class="o">:</span><span class="w"> </span><span class="n">Int</span><span class="p">)</span><span class="o">:</span><span class="w"> </span><span class="p">{</span><span class="n">Int</span><span class="p">,</span><span class="w"> </span><span class="n">Int</span><span class="p">}</span><span class="w"> </span><span class="o">=</span>
<span class="w">  </span><span class="p">{</span><span class="n">a</span><span class="w"> </span><span class="o">/</span><span class="w"> </span><span class="n">b</span><span class="p">,</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="o">%</span><span class="w"> </span><span class="n">b</span><span class="p">}</span>

<span class="cp"># Return min and max</span>
<span class="n">def</span><span class="w"> </span><span class="n">min_max</span><span class="p">(</span><span class="n">a</span><span class="o">:</span><span class="w"> </span><span class="n">Int</span><span class="p">,</span><span class="w"> </span><span class="n">b</span><span class="o">:</span><span class="w"> </span><span class="n">Int</span><span class="p">)</span><span class="o">:</span><span class="w"> </span><span class="p">{</span><span class="n">Int</span><span class="p">,</span><span class="w"> </span><span class="n">Int</span><span class="p">}</span><span class="w"> </span><span class="o">=</span>
<span class="w">  </span><span class="n">match</span><span class="w"> </span><span class="p">{</span><span class="n">a</span><span class="p">,</span><span class="w"> </span><span class="n">b</span><span class="p">}</span><span class="w"> </span><span class="n">do</span>
<span class="w">    </span><span class="p">{</span><span class="n">x</span><span class="p">,</span><span class="w"> </span><span class="n">y</span><span class="p">}</span><span class="w"> </span><span class="kr">when</span><span class="w"> </span><span class="n">x</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="n">y</span><span class="w"> </span><span class="o">-&gt;</span><span class="w"> </span><span class="p">{</span><span class="n">x</span><span class="p">,</span><span class="w"> </span><span class="n">y</span><span class="p">}</span>
<span class="w">    </span><span class="p">{</span><span class="n">x</span><span class="p">,</span><span class="w"> </span><span class="n">y</span><span class="p">}</span><span class="w"> </span><span class="o">-&gt;</span><span class="w"> </span><span class="p">{</span><span class="n">y</span><span class="p">,</span><span class="w"> </span><span class="n">x</span><span class="p">}</span>
<span class="w">  </span><span class="kd">end</span>
</code></pre></div>

<h4 id="tuple-destructuring-in-let">Tuple Destructuring in Let</h4>
<div class="codehilite"><pre><span></span><code><span class="gh">#</span> Direct destructuring
let point = {100, 200}
let {x, y} = point
<span class="gh">#</span> Now x = 100, y = 200

<span class="gh">#</span> Works with function results
let {quot, rem} = divide_with_remainder(17, 5)
</code></pre></div>

<h4 id="tuples-with-constructors">Tuples with Constructors</h4>
<div class="codehilite"><pre><span></span><code><span class="c1"># Tuple inside Result/Option</span>
<span class="n">let</span><span class="w"> </span><span class="n">result</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">Ok</span><span class="p">({</span><span class="mi">42</span><span class="p">,</span><span class="w"> </span><span class="s2">&quot;success&quot;</span><span class="p">})</span>
<span class="k">match</span><span class="w"> </span><span class="n">result</span><span class="w"> </span><span class="n">do</span>
<span class="w">  </span><span class="n">Ok</span><span class="p">({</span><span class="n">value</span><span class="p">,</span><span class="w"> </span><span class="n">message</span><span class="p">})</span><span class="w"> </span><span class="o">-&gt;</span><span class="w"> </span><span class="s2">&quot;Got value and message&quot;</span>
<span class="w">  </span><span class="n">Error</span><span class="p">(</span><span class="n">e</span><span class="p">)</span><span class="w"> </span><span class="o">-&gt;</span><span class="w"> </span><span class="s2">&quot;Error&quot;</span>
<span class="n">end</span>

<span class="c1"># Multiple values in constructor</span>
<span class="n">let</span><span class="w"> </span><span class="n">data</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">Some</span><span class="p">({</span><span class="s2">&quot;Alice&quot;</span><span class="p">,</span><span class="w"> </span><span class="mi">30</span><span class="p">,</span><span class="w"> </span><span class="bp">true</span><span class="p">})</span>
<span class="k">match</span><span class="w"> </span><span class="n">data</span><span class="w"> </span><span class="n">do</span>
<span class="w">  </span><span class="n">Some</span><span class="p">({</span><span class="n">name</span><span class="p">,</span><span class="w"> </span><span class="n">age</span><span class="p">,</span><span class="w"> </span><span class="n">active</span><span class="p">})</span><span class="w"> </span><span class="o">-&gt;</span><span class="w"> </span><span class="s2">&quot;Person data&quot;</span>
<span class="w">  </span><span class="n">None</span><span class="w"> </span><span class="o">-&gt;</span><span class="w"> </span><span class="s2">&quot;No data&quot;</span>
<span class="n">end</span>
</code></pre></div>

<h4 id="mixed-patterns">Mixed Patterns</h4>
<div class="codehilite"><pre><span></span><code><span class="cp"># Tuple with list</span>
<span class="n">match</span><span class="w"> </span><span class="p">{[</span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="mi">2</span><span class="p">,</span><span class="w"> </span><span class="mi">3</span><span class="p">],</span><span class="w"> </span><span class="s">&quot;label&quot;</span><span class="p">}</span><span class="w"> </span><span class="n">do</span>
<span class="w">  </span><span class="p">{[],</span><span class="w"> </span><span class="n">_</span><span class="p">}</span><span class="w"> </span><span class="o">-&gt;</span><span class="w"> </span><span class="s">&quot;Empty list&quot;</span>
<span class="w">  </span><span class="p">{[</span><span class="n">h</span><span class="w"> </span><span class="o">|</span><span class="w"> </span><span class="n">t</span><span class="p">],</span><span class="w"> </span><span class="n">label</span><span class="p">}</span><span class="w"> </span><span class="o">-&gt;</span><span class="w"> </span><span class="s">&quot;Non-empty list&quot;</span>
<span class="kd">end</span>

<span class="cp"># Tuple with record</span>
<span class="n">match</span><span class="w"> </span><span class="p">{</span><span class="n">Point</span><span class="p">{</span><span class="n">x</span><span class="o">:</span><span class="w"> </span><span class="mi">0</span><span class="p">,</span><span class="w"> </span><span class="n">y</span><span class="o">:</span><span class="w"> </span><span class="mi">0</span><span class="p">},</span><span class="w"> </span><span class="s">&quot;origin&quot;</span><span class="p">}</span><span class="w"> </span><span class="n">do</span>
<span class="w">  </span><span class="p">{</span><span class="n">Point</span><span class="p">{</span><span class="n">x</span><span class="o">:</span><span class="w"> </span><span class="mi">0</span><span class="p">,</span><span class="w"> </span><span class="n">y</span><span class="o">:</span><span class="w"> </span><span class="mi">0</span><span class="p">},</span><span class="w"> </span><span class="n">label</span><span class="p">}</span><span class="w"> </span><span class="o">-&gt;</span><span class="w"> </span><span class="n">label</span>
<span class="w">  </span><span class="n">_</span><span class="w"> </span><span class="o">-&gt;</span><span class="w"> </span><span class="s">&quot;Other&quot;</span>
<span class="kd">end</span>
</code></pre></div>

<hr />
<h2 id="8-operators">8. Operators</h2>
<h3 id="arithmetic">Arithmetic</h3>
<div class="codehilite"><pre><span></span><code>x + y           # Addition
x - y           # Subtraction
x * y           # Multiplication
x / y           # Division (may be integer division)
</code></pre></div>

<h3 id="comparison">Comparison</h3>
<div class="codehilite"><pre><span></span><code>x == y          # Equality
x != y          # Inequality
x &lt; y           # Less than
x &gt; y           # Greater than
x &lt;= y          # Less than or equal
x &gt;= y          # Greater than or equal
</code></pre></div>

<h3 id="list-construction">List Construction</h3>
<div class="codehilite"><pre><span></span><code>[element | list]    # Cons (prepend)
</code></pre></div>

<h3 id="string-concatenation">String Concatenation</h3>
<div class="codehilite"><pre><span></span><code><span class="nv">str1</span><span class="w"> </span><span class="o">&lt;&gt;</span><span class="w"> </span><span class="nv">str2</span><span class="w">    </span>#<span class="w"> </span><span class="nv">Diamond</span><span class="w"> </span><span class="nv">operator</span><span class="w"> </span><span class="k">for</span><span class="w"> </span><span class="nv">string</span><span class="w"> </span><span class="nv">concatenation</span>
</code></pre></div>

<hr />
<h2 id="9-let-bindings">9. Let Bindings</h2>
<p>Simple let syntax:</p>
<div class="codehilite"><pre><span></span><code><span class="n">let</span><span class="w"> </span><span class="n">variable</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">expression</span><span class="w"> </span><span class="n">body_expression</span>
<span class="n">let</span><span class="w"> </span><span class="n">result</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">function_call</span><span class="p">()</span><span class="w"> </span><span class="n">result</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="mi">10</span>
</code></pre></div>

<p>The body expression follows the binding immediately without requiring an explicit <code>in</code> keyword.</p>
<p>Example:</p>
<div class="codehilite"><pre><span></span><code>let x = 5 x + 10
</code></pre></div>

<hr />
<h2 id="10-special-constructs">10. Special Constructs</h2>
<h3 id="curify-erlang-ffi">Curify (Erlang FFI)</h3>
<p>Declare Erlang FFI functions:</p>
<div class="codehilite"><pre><span></span><code class="language-cure">curify function_name(param: Type): ReturnType = {module, function, arity}
</code></pre></div>

<p>Example:</p>
<div class="codehilite"><pre><span></span><code>curify print_raw(format: String, args: List(String)): Unit = {io, format, 2}
</code></pre></div>

<h3 id="nat-type-and-peano-numbers">Nat Type and Peano Numbers</h3>
<p>Natural numbers use Peano encoding:</p>
<div class="codehilite"><pre><span></span><code>Zero            # Zero
Succ(n)         # Successor of n
</code></pre></div>

<p>Example:</p>
<div class="codehilite"><pre><span></span><code><span class="n">def</span><span class="w"> </span><span class="nf">length</span><span class="p">(</span><span class="n">list</span><span class="o">:</span><span class="w"> </span><span class="n">List</span><span class="p">(</span><span class="n">T</span><span class="p">))</span><span class="o">:</span><span class="w"> </span><span class="n">Nat</span><span class="w"> </span><span class="o">=</span>
<span class="w">  </span><span class="n">match</span><span class="w"> </span><span class="n">list</span><span class="w"> </span><span class="n">do</span>
<span class="w">    </span><span class="p">[]</span><span class="w"> </span><span class="o">-&gt;</span><span class="w"> </span><span class="n">Zero</span>
<span class="w">    </span><span class="p">[</span><span class="n">_</span><span class="w"> </span><span class="o">|</span><span class="w"> </span><span class="n">t</span><span class="p">]</span><span class="w"> </span><span class="o">-&gt;</span><span class="w"> </span><span class="n">Succ</span><span class="p">(</span><span class="nf">length</span><span class="p">(</span><span class="n">t</span><span class="p">))</span>
<span class="w">  </span><span class="kd">end</span>
</code></pre></div>

<hr />
<h2 id="11-fsm-syntax">11. FSM Syntax</h2>
<p>FSMs are defined with an initial payload record and transition arrows:</p>
<div class="codehilite"><pre><span></span><code><span class="c1"># Define a payload record for FSM state tracking</span>
<span class="n">record</span><span class="w"> </span><span class="n">PayloadName</span><span class="w"> </span><span class="n">do</span>
<span class="w">  </span><span class="n">field1</span><span class="p">:</span><span class="w"> </span><span class="n">Type1</span>
<span class="w">  </span><span class="n">field2</span><span class="p">:</span><span class="w"> </span><span class="n">Type2</span>
<span class="n">end</span>

<span class="c1"># FSM definition with initial payload values</span>
<span class="n">fsm</span><span class="w"> </span><span class="n">PayloadName</span><span class="p">{</span><span class="n">field1</span><span class="p">:</span><span class="w"> </span><span class="n">value1</span><span class="p">,</span><span class="w"> </span><span class="n">field2</span><span class="p">:</span><span class="w"> </span><span class="n">value2</span><span class="p">}</span><span class="w"> </span><span class="n">do</span>
<span class="w">  </span><span class="n">State1</span><span class="w"> </span><span class="o">--&gt;</span><span class="w"> </span><span class="o">|</span><span class="n">event1</span><span class="o">|</span><span class="w"> </span><span class="n">State2</span>
<span class="w">  </span><span class="n">State1</span><span class="w"> </span><span class="o">--&gt;</span><span class="w"> </span><span class="o">|</span><span class="n">event2</span><span class="o">|</span><span class="w"> </span><span class="n">State1</span>
<span class="w">  </span><span class="n">State2</span><span class="w"> </span><span class="o">--&gt;</span><span class="w"> </span><span class="o">|</span><span class="n">event3</span><span class="o">|</span><span class="w"> </span><span class="n">State1</span>
<span class="n">end</span>
</code></pre></div>

<h3 id="fsm-example-turnstile">FSM Example: Turnstile</h3>
<div class="codehilite"><pre><span></span><code><span class="n">record</span><span class="w"> </span><span class="n">TurnstilePayload</span><span class="w"> </span><span class="n">do</span>
<span class="w">  </span><span class="n">coins_inserted</span><span class="p">:</span><span class="w"> </span><span class="n">Int</span>
<span class="w">  </span><span class="n">people_passed</span><span class="p">:</span><span class="w"> </span><span class="n">Int</span>
<span class="w">  </span><span class="n">denied_attempts</span><span class="p">:</span><span class="w"> </span><span class="n">Int</span>
<span class="n">end</span>

<span class="n">fsm</span><span class="w"> </span><span class="n">TurnstilePayload</span><span class="p">{</span><span class="n">coins_inserted</span><span class="p">:</span><span class="w"> </span><span class="mi">0</span><span class="p">,</span><span class="w"> </span><span class="n">people_passed</span><span class="p">:</span><span class="w"> </span><span class="mi">0</span><span class="p">,</span><span class="w"> </span><span class="n">denied_attempts</span><span class="p">:</span><span class="w"> </span><span class="mi">0</span><span class="p">}</span><span class="w"> </span><span class="n">do</span>
<span class="w">  </span><span class="n">Locked</span><span class="w"> </span><span class="o">--&gt;</span><span class="w"> </span><span class="o">|</span><span class="n">coin</span><span class="o">|</span><span class="w"> </span><span class="n">Unlocked</span>
<span class="w">  </span><span class="n">Locked</span><span class="w"> </span><span class="o">--&gt;</span><span class="w"> </span><span class="o">|</span><span class="n">push</span><span class="o">|</span><span class="w"> </span><span class="n">Locked</span>
<span class="w">  </span><span class="n">Unlocked</span><span class="w"> </span><span class="o">--&gt;</span><span class="w"> </span><span class="o">|</span><span class="n">coin</span><span class="o">|</span><span class="w"> </span><span class="n">Unlocked</span>
<span class="w">  </span><span class="n">Unlocked</span><span class="w"> </span><span class="o">--&gt;</span><span class="w"> </span><span class="o">|</span><span class="n">push</span><span class="o">|</span><span class="w"> </span><span class="n">Locked</span>
<span class="n">end</span>
</code></pre></div>

<h3 id="fsm-runtime-operations">FSM Runtime Operations</h3>
<div class="codehilite"><pre><span></span><code><span class="kn">import</span><span class="w"> </span><span class="nn">Std.Fsm</span><span class="w"> </span><span class="p">[</span><span class="n">fsm_spawn</span><span class="o">/</span><span class="mi">2</span><span class="p">,</span><span class="w"> </span><span class="n">fsm_cast</span><span class="o">/</span><span class="mi">2</span><span class="p">,</span><span class="w"> </span><span class="n">fsm_advertise</span><span class="o">/</span><span class="mi">2</span><span class="p">,</span><span class="w"> </span><span class="n">fsm_state</span><span class="o">/</span><span class="mi">1</span><span class="p">]</span>
<span class="kn">import</span><span class="w"> </span><span class="nn">Std.Pair</span><span class="w"> </span><span class="p">[</span><span class="n">pair</span><span class="o">/</span><span class="mi">2</span><span class="p">]</span>

<span class="c1"># Spawn an FSM instance</span>
<span class="n">let</span><span class="w"> </span><span class="n">fsm_pid</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">fsm_spawn</span><span class="p">(:</span><span class="n">PayloadName</span><span class="p">,</span><span class="w"> </span><span class="n">initial_data</span><span class="p">)</span>

<span class="c1"># Give it a name</span>
<span class="n">let</span><span class="w"> </span><span class="n">adv_result</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">fsm_advertise</span><span class="p">(</span><span class="n">fsm_pid</span><span class="p">,</span><span class="w"> </span><span class="p">:</span><span class="n">fsm_name</span><span class="p">)</span>

<span class="c1"># Send an event (with empty data list)</span>
<span class="n">let</span><span class="w"> </span><span class="n">empty_list</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">[]</span>
<span class="n">let</span><span class="w"> </span><span class="n">event</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">pair</span><span class="p">(:</span><span class="n">event_name</span><span class="p">,</span><span class="w"> </span><span class="n">empty_list</span><span class="p">)</span>
<span class="n">let</span><span class="w"> </span><span class="n">cast_result</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">fsm_cast</span><span class="p">(:</span><span class="n">fsm_name</span><span class="p">,</span><span class="w"> </span><span class="n">event</span><span class="p">)</span>

<span class="c1"># Get current state</span>
<span class="n">let</span><span class="w"> </span><span class="n">current_state</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">fsm_state</span><span class="p">(:</span><span class="n">fsm_name</span><span class="p">)</span>
</code></pre></div>

<p><strong>Key Points</strong>:<br />
- First state in transitions is the initial state<br />
- Events are atoms (<code>:event_name</code>)<br />
- Transitions use <code>--&gt;</code> and <code>|event|</code> syntax<br />
- Must define a payload record even if empty</p>
<hr />
<h2 id="12-common-patterns-from-std-library">12. Common Patterns from Std Library</h2>
<h3 id="resultoption-handling">Result/Option Handling</h3>
<div class="codehilite"><pre><span></span><code><span class="n">match</span><span class="w"> </span><span class="n">result</span><span class="w"> </span><span class="n">do</span>
<span class="w">  </span><span class="n">Ok</span><span class="p">(</span><span class="n">value</span><span class="p">)</span><span class="w"> </span><span class="o">-&gt;</span><span class="w"> </span><span class="err">#</span><span class="w"> </span><span class="n">handle</span><span class="w"> </span><span class="kr">success</span>
<span class="w">  </span><span class="nf">Error</span><span class="p">(</span><span class="n">err</span><span class="p">)</span><span class="w"> </span><span class="o">-&gt;</span><span class="w"> </span><span class="err">#</span><span class="w"> </span><span class="n">handle</span><span class="w"> </span><span class="nf">error</span>
<span class="kd">end</span>

<span class="n">match</span><span class="w"> </span><span class="n">option</span><span class="w"> </span><span class="n">do</span>
<span class="w">  </span><span class="n">Some</span><span class="p">(</span><span class="n">value</span><span class="p">)</span><span class="w"> </span><span class="o">-&gt;</span><span class="w"> </span><span class="err">#</span><span class="w"> </span><span class="n">handle</span><span class="w"> </span><span class="n">present</span><span class="w"> </span><span class="n">value</span>
<span class="w">  </span><span class="n">None</span><span class="w"> </span><span class="o">-&gt;</span><span class="w"> </span><span class="err">#</span><span class="w"> </span><span class="n">handle</span><span class="w"> </span><span class="n">absence</span>
<span class="kd">end</span>
</code></pre></div>

<h3 id="recursive-list-processing">Recursive List Processing</h3>
<div class="codehilite"><pre><span></span><code><span class="n">def</span><span class="w"> </span><span class="nf">map</span><span class="p">(</span><span class="n">list</span><span class="o">:</span><span class="w"> </span><span class="n">List</span><span class="p">(</span><span class="n">T</span><span class="p">),</span><span class="w"> </span><span class="n">f</span><span class="o">:</span><span class="w"> </span><span class="n">T</span><span class="w"> </span><span class="o">-&gt;</span><span class="w"> </span><span class="n">U</span><span class="p">)</span><span class="o">:</span><span class="w"> </span><span class="n">List</span><span class="p">(</span><span class="n">U</span><span class="p">)</span><span class="w"> </span><span class="o">=</span>
<span class="w">  </span><span class="n">match</span><span class="w"> </span><span class="n">list</span><span class="w"> </span><span class="n">do</span>
<span class="w">    </span><span class="p">[]</span><span class="w"> </span><span class="o">-&gt;</span><span class="w"> </span><span class="p">[]</span>
<span class="w">    </span><span class="p">[</span><span class="n">h</span><span class="w"> </span><span class="o">|</span><span class="w"> </span><span class="n">t</span><span class="p">]</span><span class="w"> </span><span class="o">-&gt;</span><span class="w"> </span><span class="p">[</span><span class="n">f</span><span class="p">(</span><span class="n">h</span><span class="p">)</span><span class="w"> </span><span class="o">|</span><span class="w"> </span><span class="nf">map</span><span class="p">(</span><span class="n">t</span><span class="p">,</span><span class="w"> </span><span class="n">f</span><span class="p">)]</span>
<span class="w">  </span><span class="kd">end</span>
</code></pre></div>

<h3 id="tail-recursion-with-accumulator">Tail Recursion with Accumulator</h3>
<div class="codehilite"><pre><span></span><code><span class="n">def</span><span class="w"> </span><span class="n">reverse</span><span class="p">(</span><span class="n">list</span><span class="o">:</span><span class="w"> </span><span class="n">List</span><span class="p">(</span><span class="n">T</span><span class="p">),</span><span class="w"> </span><span class="n">acc</span><span class="o">:</span><span class="w"> </span><span class="n">List</span><span class="p">(</span><span class="n">T</span><span class="p">))</span><span class="o">:</span><span class="w"> </span><span class="n">List</span><span class="p">(</span><span class="n">T</span><span class="p">)</span><span class="w"> </span><span class="o">=</span>
<span class="w">  </span><span class="n">match</span><span class="w"> </span><span class="n">list</span><span class="w"> </span><span class="n">do</span>
<span class="w">    </span><span class="p">[]</span><span class="w"> </span><span class="o">-&gt;</span><span class="w"> </span><span class="n">acc</span>
<span class="w">    </span><span class="p">[</span><span class="n">h</span><span class="w"> </span><span class="o">|</span><span class="w"> </span><span class="n">t</span><span class="p">]</span><span class="w"> </span><span class="o">-&gt;</span><span class="w"> </span><span class="n">reverse</span><span class="p">(</span><span class="n">t</span><span class="p">,</span><span class="w"> </span><span class="p">[</span><span class="n">h</span><span class="w"> </span><span class="o">|</span><span class="w"> </span><span class="n">acc</span><span class="p">])</span>
<span class="w">  </span><span class="kd">end</span>
</code></pre></div>

<h3 id="curried-functions">Curried Functions</h3>
<div class="codehilite"><pre><span></span><code><span class="cp"># Function returns another function</span>
<span class="n">def</span><span class="w"> </span><span class="n">flip</span><span class="p">(</span><span class="n">f</span><span class="o">:</span><span class="w"> </span><span class="n">A</span><span class="w"> </span><span class="o">-&gt;</span><span class="w"> </span><span class="n">B</span><span class="w"> </span><span class="o">-&gt;</span><span class="w"> </span><span class="n">C</span><span class="p">)</span><span class="o">:</span><span class="w"> </span><span class="n">B</span><span class="w"> </span><span class="o">-&gt;</span><span class="w"> </span><span class="n">A</span><span class="w"> </span><span class="o">-&gt;</span><span class="w"> </span><span class="n">C</span><span class="w"> </span><span class="o">=</span>
<span class="w">  </span><span class="n">fn</span><span class="p">(</span><span class="n">b</span><span class="p">,</span><span class="w"> </span><span class="n">a</span><span class="p">)</span><span class="w"> </span><span class="o">-&gt;</span><span class="w"> </span>
<span class="w">    </span><span class="n">let</span><span class="w"> </span><span class="n">g</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">f</span><span class="p">(</span><span class="n">a</span><span class="p">)</span><span class="w"> </span><span class="n">g</span><span class="p">(</span><span class="n">b</span><span class="p">)</span>
<span class="w">  </span><span class="kd">end</span>
</code></pre></div>

<hr />
<h2 id="13-key-syntactic-rules">13. Key Syntactic Rules</h2>
<ol>
<li><strong>Module Required</strong>: Every file needs a <code class="language-cure">module ModuleName do ... end</code></li>
<li><strong>Type Annotations</strong>: All function parameters and return types must be annotated</li>
<li><strong>Pattern Matching</strong>: Use <code>match ... do ... end</code> blocks</li>
<li><strong>Lambdas</strong>: Use <code>fn(params) -&gt; body end</code> syntax</li>
<li><strong>Let Binding</strong>: Simple <code>let name = value</code> without semicolons</li>
<li><strong>Function Application</strong>: Standard <code>func(arg1, arg2)</code> syntax</li>
<li><strong>Comments</strong>: Only <code>#</code> single-line comments</li>
<li><strong>Indentation</strong>: Not significant (use <code>do ... end</code> blocks)</li>
</ol>
<hr />
<h2 id="14-things-to-avoid-not-in-std-library">14. Things to AVOID (Not in Std Library)</h2>
<p>Based on actual standard library, these features may not be implemented:</p>
<ol>
<li><strong>Process definitions</strong>: <code>process name(...) do ... end</code> - verify syntax</li>
<li><strong>Dependent types</strong>: <code>Vector(T, n: Nat)</code> - may not fully work yet</li>
<li><strong>String interpolation</strong>: <code>"text #{expr}"</code> - use <code>&lt;&gt;</code> for concatenation instead</li>
<li><strong>If-then-else</strong>: May exist but std lib uses match expressions</li>
</ol>
<hr />
<h2 id="15-recommended-workflow">15. Recommended Workflow</h2>
<p>When creating examples:</p>
<ol>
<li>Start with module definition</li>
<li>Import needed functions from Std library</li>
<li>Define types (sum types with constructors)</li>
<li>Define functions with explicit type signatures</li>
<li>Use pattern matching for control flow</li>
<li>Use lambdas for higher-order functions</li>
<li>Keep it simple - mirror std library style</li>
</ol>
<hr />
<h2 id="example-complete-module-template">Example: Complete Module Template</h2>
<div class="codehilite"><pre><span></span><code><span class="n">module</span><span class="w"> </span><span class="n">ExampleModule</span><span class="w"> </span><span class="n">do</span>
<span class="w">  </span><span class="n">export</span><span class="w"> </span><span class="p">[</span>
<span class="w">    </span><span class="n">main</span><span class="o">/</span><span class="mi">0</span><span class="p">,</span>
<span class="w">    </span><span class="n">helper_function</span><span class="o">/</span><span class="mi">1</span>
<span class="w">  </span><span class="p">]</span>

<span class="w">  </span><span class="c1"># Import standard library functions</span>
<span class="w">  </span><span class="kn">import</span><span class="w"> </span><span class="nn">Std.Core</span><span class="w"> </span><span class="p">[</span><span class="n">Result</span><span class="p">,</span><span class="w"> </span><span class="n">ok</span><span class="o">/</span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="n">error</span><span class="o">/</span><span class="mi">1</span><span class="p">]</span>
<span class="w">  </span><span class="kn">import</span><span class="w"> </span><span class="nn">Std.List</span><span class="w"> </span><span class="p">[</span><span class="nb">map</span><span class="o">/</span><span class="mi">2</span><span class="p">,</span><span class="w"> </span><span class="nb">filter</span><span class="o">/</span><span class="mi">2</span><span class="p">]</span>
<span class="w">  </span><span class="kn">import</span><span class="w"> </span><span class="nn">Std.Io</span><span class="w"> </span><span class="p">[</span><span class="nb">print</span><span class="o">/</span><span class="mi">1</span><span class="p">]</span>

<span class="w">  </span><span class="c1"># Type definition</span>
<span class="w">  </span><span class="nb">type</span><span class="w"> </span><span class="n">MyType</span><span class="p">(</span><span class="n">T</span><span class="p">)</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">Constructor1</span><span class="p">(</span><span class="n">T</span><span class="p">)</span><span class="w"> </span><span class="o">|</span><span class="w"> </span><span class="n">Constructor2</span><span class="p">(</span><span class="nb">String</span><span class="p">)</span>

<span class="w">  </span><span class="c1"># Main function</span>
<span class="w">  </span><span class="k">def</span><span class="w"> </span><span class="nf">main</span><span class="p">():</span><span class="w"> </span><span class="n">Unit</span><span class="w"> </span><span class="o">=</span>
<span class="w">    </span><span class="n">let</span><span class="w"> </span><span class="n">result</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">helper_function</span><span class="p">(</span><span class="mi">42</span><span class="p">)</span>
<span class="w">    </span><span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Done&quot;</span><span class="p">)</span>

<span class="w">  </span><span class="c1"># Helper with pattern matching</span>
<span class="w">  </span><span class="k">def</span><span class="w"> </span><span class="nf">helper_function</span><span class="p">(</span><span class="n">value</span><span class="p">:</span><span class="w"> </span><span class="nb">Int</span><span class="p">):</span><span class="w"> </span><span class="n">Result</span><span class="p">(</span><span class="nb">String</span><span class="p">,</span><span class="w"> </span><span class="nb">String</span><span class="p">)</span><span class="w"> </span><span class="o">=</span>
<span class="w">    </span><span class="n">match</span><span class="w"> </span><span class="n">value</span><span class="w"> </span><span class="o">&gt;</span><span class="w"> </span><span class="mi">0</span><span class="w"> </span><span class="n">do</span>
<span class="w">      </span><span class="n">true</span><span class="w"> </span><span class="o">-&gt;</span><span class="w"> </span><span class="n">ok</span><span class="p">(</span><span class="s2">&quot;positive&quot;</span><span class="p">)</span>
<span class="w">      </span><span class="n">false</span><span class="w"> </span><span class="o">-&gt;</span><span class="w"> </span><span class="n">error</span><span class="p">(</span><span class="s2">&quot;non-positive&quot;</span><span class="p">)</span>
<span class="w">    </span><span class="n">end</span>
<span class="n">end</span>
</code></pre></div>

<hr />
<p><strong>This guide is based on actual working code in the Cure standard library. When in doubt, refer to <code>lib/std/</code> directory for real examples.</strong></p>
    </div>

    <!-- Footer -->
    <footer class="site-footer">
        <div class="footer-content">
            <div class="footer-section">
                <h4>Documentation</h4>
                <ul>
                    <li><a href="../docs.html">Getting Started</a></li>
                    <li><a href="language-spec.html">Language Specification</a></li>
                    <li><a href="type-system.html">Type System</a></li>
                    <li><a href="fsm-usage.html">FSM Guide</a></li>
                </ul>
            </div>

            <div class="footer-section">
                <h4>Reference</h4>
                <ul>
                    <li><a href="../api/index.html">API Reference</a></li>
                    <li><a href="std-summary.html">Standard Library</a></li>
                    <li><a href="feature-reference.html">Feature Reference</a></li>
                    <li><a href="cli-usage.html">CLI Usage</a></li>
                </ul>
            </div>

            <div class="footer-section">
                <h4>All Documentation</h4>
                <ul>
                    <li><a href="cli-integration-status.html">CLI Integration - SMT Solver Options and</a></li>
                    <li><a href="codegen-analysis-2025-11-25.html">Code Generation Issues - Analysis (2025-</a></li>
                    <li><a href="codegen-investigation-summary.html">Code Generation Issues - Investigation S</a></li>
                    <li><a href="contributing.html">Contributing</a></li>
                    <li><a href="api-reference.html">Cure API Reference</a></li>
                    <li><a href="fsm-api-design.html">Cure FSM API Design</a></li>
                    <li><a href="fsm-usage.html">Cure FSM Usage Guide</a></li>
                    <li><a href="lsp-mcp-update-2025-11-26.html">Cure LSP and MCP Update - November 26, 2</a></li>
                    <li><a href="lsp-smt-user-guide.html">Cure LSP with SMT Verification - User Gu</a></li>
                    <li><a href="feature-reference.html">Cure Language Features Reference</a></li>
                    <li><a href="language-spec.html">Cure Language Specification</a></li>
                    <li><a href="cure-syntax-guide.html">Cure Language Syntax Guide</a></li>
                    <li><a href="cure-ultimate-description.html">Cure Language: Ultimate Implementation D</a></li>
                    <li><a href="mcp-integration.html">Cure MCP Integration</a></li>
                    <li><a href="cli-usage.html">Cure Programming Language - Command Line</a></li>
                </ul>
            </div>
        </div>

        <div class="footer-bottom">
            <p>&copy; 2025 Cure Programming Language. Verification-first programming for the BEAM.</p>
        </div>
    </footer>

    <!-- Syntax Highlighting -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.11.1/highlight.min.js"></script>
    <script src="../js/cure-language.js"></script>
    <script>
        // Initialize highlight.js and highlight all code blocks
        hljs.highlightAll();
    </script>
</body>
</html>
