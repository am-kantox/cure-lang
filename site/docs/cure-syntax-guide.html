<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Cure Language Syntax Guide - Cure Documentation</title>
    <meta name="description" content="Based on: Actual Cure implementation (Standard Library v1.0)  
Purpose: Reference for creating correct Cure examples  
Last Updated: Octob">
    <link rel="icon" type="image/png" href="../media/logo-128x128.png">
    <link rel="stylesheet" href="../css/style.css">
</head>
<body>
    <!-- Header -->
    <header class="site-header">
        <div class="nav-container">
            <div class="logo-section">
                <img src="../media/logo-128x128.png" alt="Cure Logo" class="logo">
                <div>
                    <h1 class="site-title">Cure</h1>
                    <p class="site-tagline">Verification-First Programming</p>
                </div>
            </div>
            <nav class="main-nav">
                <ul>
                    <li><a href="../index.html">Home</a></li>
                    <li><a href="../docs.html">Documentation</a></li>
                    <li><a href="../api/index.html">API Reference</a></li>
                </ul>
            </nav>
        </div>
    </header>

    <!-- Main Content -->
    <div class="doc-page">
        <div class="doc-nav">
            <a href="../docs.html">‚Üê Back to Documentation</a>
        </div>
        
        <h1>Cure Language Syntax Guide</h1>

<strong>Based on</strong>: Actual Cure implementation (Standard Library v1.0)  
<strong>Purpose</strong>: Reference for creating correct Cure examples  
<strong>Last Updated</strong>: October 30, 2025

<p>---</p>

<h2>1. Module Structure</h2>

<p>Every Cure file should define a module:</p>

<pre><code>module ModuleName do
  export [function_name/1, TypeName]
  
  # Module contents
end
</code></pre>

<h3>Exports</h3>

<p>Export declarations specify what's public:</p>

<pre><code>export [
  function_name/1,    # Function with arity
  TypeName,           # Type constructor
  constructor_name    # Data constructor
]
</code></pre>

<h3>Imports</h3>

<p>Import from other modules (including standard library):</p>

<pre><code>import Std.Core [Result, Option, ok/1, error/1]
import Std.List [map/2, filter/2, fold/3]
import Std.Io [print/1, println/1]
</code></pre>

<p>---</p>

<h2>2. Comments</h2>

<p>Single-line comments only:</p>

<pre><code># This is a comment
</code></pre>

<p>---</p>

<h2>3. Type Definitions</h2>

<h3>Type Aliases with Sum Types</h3>

<pre><code>type Result(T, E) = Ok(T) | Error(E)
type Option(T) = Some(T) | None
type Ordering = Lt | Eq | Gt
</code></pre>

<h3>Record Types</h3>

<p>Records define structured data with named fields:</p>

<pre><code>record RecordName do
  field1: Type1
  field2: Type2
  field3: Type3
end
</code></pre>

<h4>Record with Type Parameters</h4>

<pre><code>record Point(T) do
  x: T
  y: T
end
</code></pre>

<h4>Record Construction</h4>

<pre><code># Create a record instance
let point = Point{x: 3.0, y: 4.0}
let payload = TrafficPayload{cycles_completed: 0, timer_events: 0, emergency_stops: 0}
</code></pre>

<h4>Record Pattern Matching</h4>

<pre><code># Match and extract fields
match point do
  Point{x: x, y: y} when x == 0.0 and y == 0.0 ->
    "Origin"
  Point{x: x, y: y} when x > 0.0 and y > 0.0 ->
    "First quadrant"
  Point{x: _, y: y} when y == 0.0 ->
    "On X-axis"
end

# Partial field matching (other fields ignored)
match person do
  Person{age: age, score: score} when age < 18 and score >= 90 ->
    "Outstanding young achiever"
end
</code></pre>

<p>---</p>

<h2>4. Function Definitions</h2>

<h3>Basic Function Syntax</h3>

<pre><code>def function_name(param1: Type1, param2: Type2): ReturnType =
  expression
</code></pre>

<h3>Function with Match Expression</h3>

<pre><code>def length(list: List(T)): Nat =
  match list do
    [] -> Zero
    [_ | t] -> Succ(length(t))
  end
</code></pre>

<h3>Functions with Let Bindings</h3>

<pre><code>def filter(list: List(T), predicate: T -> Bool): List(T) =
  match list do
    [] -> []
    [h | t] -> 
      let filtered_tail = filter(t, predicate)
      match predicate(h) do
        true -> [h | filtered_tail]
        false -> filtered_tail
      end
  end
</code></pre>

<h3>Lambda Functions</h3>

<p>Lambda syntax: <code>fn(params) -> expression end</code></p>

<pre><code># Simple lambda
let double = fn(x) -> x * 2 end

# Lambda with multiple params
let add = fn(x, y) -> x + y end

# Curried function application
let partial_func = func(h)
partial_func(fold(t, init, func))
</code></pre>

<p>---</p>

<h2>5. Pattern Matching</h2>

<h3>Match Expression Structure</h3>

<pre><code>match value do
  pattern1 -> result1
  pattern2 -> result2
  _ -> default_result
end
</code></pre>

<h3>Pattern Guards</h3>

<p>Guards allow additional conditions on patterns using <code>when</code>:</p>

<pre><code>match value do
  x when x < 0 -> "Negative"
  x when x == 0 -> "Zero"
  x when x > 0 -> "Positive"
end

# Multiple conditions with logical operators
match n do
  x when x >= 10 and x <= 20 -> "In range"
  x when x < 10 or x > 20 -> "Out of range"
end

# Guards with record patterns
match point do
  Point{x: x, y: y} when x > 0.0 and y > 0.0 ->
    "First quadrant"
  Point{x: x, y: _} when x == 0.0 ->
    "On Y-axis"
end
</code></pre>

<h3>List Patterns</h3>

<pre><code>match list do
  [] -> # empty list
  [h | t] -> # head and tail
  [a, b, c] -> # exact length (if supported)
end
</code></pre>

<h3>Constructor Patterns</h3>

<pre><code>match result do
  Ok(value) -> # success case
  Error(err) -> # error case
end

match option do
  Some(value) -> # present
  None -> # absent
end
</code></pre>

<h3>Nested Match</h3>

<pre><code>match list do
  [] -> []
  [h | t] ->
    match predicate(h) do
      true -> [h | filtered_tail]
      false -> filtered_tail
    end
end
</code></pre>

<p>---</p>

<h2>6. Type Annotations</h2>

<h3>Function Types</h3>

<p>Arrow notation for function types:</p>

<pre><code># Function taking T, returning U
T -> U

# Function taking two params
T -> U -> V

# Can be curried
def func(x: T): U -> V =
  fn(y) -> result end
</code></pre>

<h3>Polymorphic Types</h3>

<p>Generic type parameters:</p>

<pre><code>def identity(x: T): T = x
def map(list: List(T), f: T -> U): List(U) = ...
</code></pre>

<p>---</p>

<h2>7. Literals and Basic Types</h2>

<h3>Primitives</h3>

<pre><code>42              # Int
3.14            # Float
"hello"         # String
true            # Bool
false           # Bool
:atom_name      # Atom
</code></pre>

<h3>Lists</h3>

<pre><code>[]              # Empty list
[1, 2, 3]       # List of integers
[h | t]         # Cons pattern/constructor
</code></pre>

<h3>Tuples (Limited Support)</h3>

<p>Check actual implementation before using tuples extensively.</p>

<p>---</p>

<h2>8. Operators</h2>

<h3>Arithmetic</h3>

<pre><code>x + y           # Addition
x - y           # Subtraction
x * y           # Multiplication
x / y           # Division (may be integer division)
</code></pre>

<h3>Comparison</h3>

<pre><code>x == y          # Equality
x != y          # Inequality
x < y           # Less than
x > y           # Greater than
x <= y          # Less than or equal
x >= y          # Greater than or equal
</code></pre>

<h3>List Construction</h3>

<pre><code>[element | list]    # Cons (prepend)
</code></pre>

<h3>String Concatenation</h3>

<pre><code>str1 <> str2    # Diamond operator for string concatenation
</code></pre>

<p>---</p>

<h2>9. Let Bindings</h2>

<p>Simple let syntax:</p>

<pre><code>let variable = expression
let result = function_call()
</code></pre>

<strong>Note</strong>: Use <code>in</code> for scoped let expressions (check if implemented):

<pre><code>let x = 5 in x + 10
</code></pre>

<p>---</p>

<h2>10. Special Constructs</h2>

<h3>Curify (Erlang FFI)</h3>

<p>Declare Erlang FFI functions:</p>

<pre><code>curify function_name(param: Type): ReturnType = {module, function, arity}
</code></pre>

<p>Example:</p>

<pre><code>curify print_raw(format: String, args: List(String)): Unit = {io, format, 2}
</code></pre>

<h3>Nat Type and Peano Numbers</h3>

<p>Natural numbers use Peano encoding:</p>

<pre><code>Zero            # Zero
Succ(n)         # Successor of n
</code></pre>

<p>Example:</p>

<pre><code>def length(list: List(T)): Nat =
  match list do
    [] -> Zero
    [_ | t] -> Succ(length(t))
  end
</code></pre>

<p>---</p>

<h2>11. FSM Syntax</h2>

<p>FSMs are defined with an initial payload record and transition arrows:</p>

<pre><code># Define a payload record for FSM state tracking
record PayloadName do
  field1: Type1
  field2: Type2
end

# FSM definition with initial payload values
fsm PayloadName{field1: value1, field2: value2} do
  State1 --> |event1| State2
  State1 --> |event2| State1
  State2 --> |event3| State1
end
</code></pre>

<h3>FSM Example: Turnstile</h3>

<pre><code>record TurnstilePayload do
  coins_inserted: Int
  people_passed: Int
  denied_attempts: Int
end

fsm TurnstilePayload{coins_inserted: 0, people_passed: 0, denied_attempts: 0} do
  Locked --> |coin| Unlocked
  Locked --> |push| Locked
  Unlocked --> |coin| Unlocked
  Unlocked --> |push| Locked
end
</code></pre>

<h3>FSM Runtime Operations</h3>

<pre><code>import Std.Fsm [fsm_spawn/2, fsm_cast/2, fsm_advertise/2, fsm_state/1]
import Std.Pair [pair/2]

# Spawn an FSM instance
let fsm_pid = fsm_spawn(:PayloadName, initial_data)

# Give it a name
let adv_result = fsm_advertise(fsm_pid, :fsm_name)

# Send an event (with empty data list)
let empty_list = []
let event = pair(:event_name, empty_list)
let cast_result = fsm_cast(:fsm_name, event)

# Get current state
let current_state = fsm_state(:fsm_name)
</code></pre>

<strong>Key Points</strong>:
<ul>
<li>First state in transitions is the initial state</li>
<li>Events are atoms (<code>:event_name</code>)</li>
<li>Transitions use <code>--></code> and <code>|event|</code> syntax</li>
<li>Must define a payload record even if empty</li>
</ul>

<p>---</p>

<h2>12. Common Patterns from Std Library</h2>

<h3>Result/Option Handling</h3>

<pre><code>match result do
  Ok(value) -> # handle success
  Error(err) -> # handle error
end

match option do
  Some(value) -> # handle present value
  None -> # handle absence
end
</code></pre>

<h3>Recursive List Processing</h3>

<pre><code>def map(list: List(T), f: T -> U): List(U) =
  match list do
    [] -> []
    [h | t] -> [f(h) | map(t, f)]
  end
</code></pre>

<h3>Tail Recursion with Accumulator</h3>

<pre><code>def reverse(list: List(T), acc: List(T)): List(T) =
  match list do
    [] -> acc
    [h | t] -> reverse(t, [h | acc])
  end
</code></pre>

<h3>Curried Functions</h3>

<pre><code># Function returns another function
def flip(f: A -> B -> C): B -> A -> C =
  fn(b, a) -> 
    let g = f(a) in
    g(b)
  end
</code></pre>

<p>---</p>

<h2>13. Key Syntactic Rules</h2>

<ol>
<li><strong>Module Required</strong>: Every file needs a <code>module ModuleName do ... end</code></li>
<li><strong>Type Annotations</strong>: All function parameters and return types must be annotated</li>
<li><strong>Pattern Matching</strong>: Use <code>match ... do ... end</code> blocks</li>
<li><strong>Lambdas</strong>: Use <code>fn(params) -> body end</code> syntax</li>
<li><strong>Let Binding</strong>: Simple <code>let name = value</code> without semicolons</li>
<li><strong>Function Application</strong>: Standard <code>func(arg1, arg2)</code> syntax</li>
<li><strong>Comments</strong>: Only <code>#</code> single-line comments</li>
<li><strong>Indentation</strong>: Not significant (use <code>do ... end</code> blocks)</li>
</ol>

<p>---</p>

<h2>14. Things to AVOID (Not in Std Library)</h2>

<p>Based on actual standard library, these features may not be implemented:</p>

<ol>
<li><strong>Process definitions</strong>: <code>process name(...) do ... end</code> - verify syntax</li>
<li><strong>Dependent types</strong>: <code>Vector(T, n: Nat)</code> - may not fully work yet</li>
<li><strong>String interpolation</strong>: <code>"text #{expr}"</code> - use <code><></code> for concatenation instead</li>
<li><strong>If-then-else</strong>: May exist but std lib uses match expressions</li>
</ol>

<p>---</p>

<h2>15. Recommended Workflow</h2>

<p>When creating examples:</p>

<ol>
<li>Start with module definition</li>
<li>Import needed functions from Std library</li>
<li>Define types (sum types with constructors)</li>
<li>Define functions with explicit type signatures</li>
<li>Use pattern matching for control flow</li>
<li>Use lambdas for higher-order functions</li>
<li>Keep it simple - mirror std library style</li>
</ol>

<p>---</p>

<h2>Example: Complete Module Template</h2>

<pre><code>module ExampleModule do
  export [
    main/0,
    helper_function/1
  ]
  
  # Import standard library functions
  import Std.Core [Result, ok/1, error/1]
  import Std.List [map/2, filter/2]
  import Std.Io [print/1]
  
  # Type definition
  type MyType(T) = Constructor1(T) | Constructor2(String)
  
  # Main function
  def main(): Unit =
    let result = helper_function(42)
    print("Done")
  
  # Helper with pattern matching
  def helper_function(value: Int): Result(String, String) =
    match value > 0 do
      true -> ok("positive")
      false -> error("non-positive")
    end
end
</code></pre>

<p>---</p>

<strong>This guide is based on actual working code in the Cure standard library. When in doubt, refer to <code>lib/std/</code> directory for real examples.</strong>

    </div>

    <!-- Pill Decoration -->
    <img src="../media/pill-512x512.png" alt="" class="pill-decoration">

    <!-- Footer -->
    <footer class="site-footer">
        <div class="footer-content">
            <div class="footer-section">
                <h4>Documentation</h4>
                <ul>
                    <li><a href="../docs.html">Getting Started</a></li>
                    <li><a href="language-spec.html">Language Specification</a></li>
                    <li><a href="type-system.html">Type System</a></li>
                    <li><a href="fsm-usage.html">FSM Guide</a></li>
                </ul>
            </div>

            <div class="footer-section">
                <h4>Reference</h4>
                <ul>
                    <li><a href="../api/index.html">API Reference</a></li>
                    <li><a href="std-summary.html">Standard Library</a></li>
                    <li><a href="feature-reference.html">Feature Reference</a></li>
                    <li><a href="cli-usage.html">CLI Usage</a></li>
                </ul>
            </div>

            <div class="footer-section">
                <h4>Resources</h4>
                <ul>
                    <li><a href="editor-setup.html">Editor Setup</a></li>
                    <li><a href="project-overview.html">Project Overview</a></li>
                    <li><a href="cure-ultimate-description.html">Ultimate Guide</a></li>
                </ul>
            </div>
        </div>

        <div class="footer-bottom">
            <p>&copy; 2025 Cure Programming Language. Verification-first programming for the BEAM.</p>
        </div>
    </footer>
</body>
</html>
