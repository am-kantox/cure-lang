<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>LSP Type Hole Remote Call Inference - Implementation - Cure Documentation</title>
    <meta name="description" content=" Overview">
    <link rel="icon" type="image/png" href="../media/logo-128x128.png">
    <link rel="stylesheet" href="../css/style.css">
</head>
<body>
    <!-- Header -->
    <header class="site-header">
        <div class="nav-container">
            <div class="logo-section">
                <img src="../media/logo-128x128.png" alt="Cure Logo" class="logo">
                <div>
                    <h1 class="site-title">Cure</h1>
                    <p class="site-tagline">Verification-First Programming</p>
                </div>
            </div>
            <nav class="main-nav">
                <ul>
                    <li><a href="../index.html">Home</a></li>
                    <li><a href="../docs.html">Documentation</a></li>
                    <li><a href="../api/index.html">API Reference</a></li>
                </ul>
            </nav>
        </div>
    </header>

    <!-- Main Content -->
    <div class="doc-page">
        <div class="doc-nav">
            <a href="../docs.html">← Back to Documentation</a>
        </div>
        
        <h1 id="lsp-type-hole-remote-call-inference-implementation">LSP Type Hole Remote Call Inference - Implementation</h1>
<h2 id="overview">Overview</h2>
<p>This document describes the successful implementation of type inference for remote calls (imported functions) in the Cure LSP's type hole feature.</p>
<h2 id="problem-statement">Problem Statement</h2>
<p>The LSP type hole feature needed to infer types for functions that use imported functions. For example:</p>
<div class="codehilite"><pre><span></span><code><span class="kn">import</span><span class="w"> </span><span class="nn">Std.List</span><span class="w"> </span><span class="p">[</span><span class="nb">map</span><span class="p">,</span><span class="w"> </span><span class="nb">filter</span><span class="p">]</span>

<span class="k">def</span><span class="w"> </span><span class="nf">double_list</span><span class="p">(</span><span class="n">numbers</span><span class="p">:</span><span class="w"> </span><span class="nb">List</span><span class="p">(</span><span class="nb">Int</span><span class="p">)):</span><span class="w"> </span><span class="n">_</span><span class="w"> </span><span class="o">=</span>
<span class="w">  </span><span class="nb">map</span><span class="p">(</span><span class="n">numbers</span><span class="p">,</span><span class="w"> </span><span class="n">fn</span><span class="p">(</span><span class="n">x</span><span class="p">)</span><span class="w"> </span><span class="o">-&gt;</span><span class="w"> </span><span class="n">x</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="mi">2</span><span class="w"> </span><span class="n">end</span><span class="p">)</span>
</code></pre></div>

<p>The <code>_</code> type hole should be inferred as <code>List(Int)</code> by analyzing the call to the imported <code>map/2</code> function.</p>
<h2 id="solution-architecture">Solution Architecture</h2>
<h3 id="key-insight-from-cure_typechecker">Key Insight from <code>cure_typechecker</code></h3>
<p>After investigating <code>check_multiclause_function</code> in <code>cure_typechecker.erl</code>, we discovered that:</p>
<ol>
<li>Multi-clause functions are checked by calling <code>check_single_clause_function</code> for each clause</li>
<li>Each clause check returns <code>{ok, NewEnv, Result}</code> with the function added to <code>NewEnv</code></li>
<li>However, <code>check_multiclause_function</code> <strong>discards</strong> these environments and returns the original <code>Env</code></li>
<li>This is intentional - the function signature is added during a separate "signature collection" pass</li>
</ol>
<h3 id="our-approach">Our Approach</h3>
<p>To work around this, we:</p>
<ol>
<li><strong>Extract imports from the module</strong> - Parse the AST to find <code>import_def</code> records</li>
<li><strong>Build an enriched environment</strong> - Add imported function types to the base environment</li>
<li><strong>Create a synthetic single-clause function</strong> - For multi-clause functions, extract the first clause</li>
<li><strong>Call <code>check_function</code> directly</strong> - This adds the function to the returned environment</li>
<li><strong>Extract the inferred type</strong> - Look up the function in the returned environment and extract its return type</li>
</ol>
<h2 id="implementation-details">Implementation Details</h2>
<h3 id="import-processing">Import Processing</h3>
<div class="codehilite"><pre><span></span><code><span class="nf">build_module_env</span><span class="p">(</span><span class="nv">AST</span><span class="p">)</span><span class="w"> </span><span class="k">when</span><span class="w"> </span><span class="nb">is_list</span><span class="p">(</span><span class="nv">AST</span><span class="p">)</span><span class="w"> </span><span class="o">-&gt;</span>
<span class="w">    </span><span class="c">% Extract module_def and its imports</span>
<span class="w">    </span><span class="k">case</span><span class="w"> </span><span class="p">[</span><span class="nv">M</span><span class="w"> </span><span class="p">||</span><span class="w"> </span><span class="nv">M</span><span class="w"> </span><span class="o">&lt;-</span><span class="w"> </span><span class="nv">AST</span><span class="p">,</span><span class="w"> </span><span class="nb">is_record</span><span class="p">(</span><span class="nv">M</span><span class="p">,</span><span class="w"> </span><span class="n">module_def</span><span class="p">)]</span><span class="w"> </span><span class="k">of</span>
<span class="w">        </span><span class="p">[</span><span class="nl">#module_def</span><span class="p">{</span><span class="n">items</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nv">Items</span><span class="p">}</span><span class="w"> </span><span class="p">|</span><span class="w"> </span><span class="p">_]</span><span class="w"> </span><span class="o">-&gt;</span>
<span class="w">            </span><span class="nv">BaseEnv</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nn">cure_typechecker</span><span class="p">:</span><span class="nf">builtin_env</span><span class="p">(),</span>
<span class="w">            </span><span class="nv">Imports</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">[</span><span class="nv">Item</span><span class="w"> </span><span class="p">||</span><span class="w"> </span><span class="nv">Item</span><span class="w"> </span><span class="o">&lt;-</span><span class="w"> </span><span class="nv">Items</span><span class="p">,</span><span class="w"> </span><span class="nb">is_record</span><span class="p">(</span><span class="nv">Item</span><span class="p">,</span><span class="w"> </span><span class="n">import_def</span><span class="p">)],</span>
<span class="w">            </span><span class="n">process_imports_for_env</span><span class="p">(</span><span class="nv">Imports</span><span class="p">,</span><span class="w"> </span><span class="nv">BaseEnv</span><span class="p">);</span>
<span class="w">        </span><span class="p">...</span>
<span class="w">    </span><span class="k">end</span><span class="p">.</span>
</code></pre></div>

<h3 id="function-type-inference">Function Type Inference</h3>
<p>For multi-clause functions (which is how the parser represents most functions):</p>
<div class="codehilite"><pre><span></span><code><span class="c">% Extract first clause</span>
<span class="p">[</span><span class="nv">FirstClause</span><span class="w"> </span><span class="p">|</span><span class="w"> </span><span class="p">_]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nv">Clauses</span><span class="p">,</span>
<span class="nv">CheckParams</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nv">FirstClause</span><span class="nl">#function_clause.params</span><span class="p">,</span>
<span class="nv">CheckBody</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nv">FirstClause</span><span class="nl">#function_clause.body</span><span class="p">,</span>
<span class="nv">CheckReturnType</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">case</span><span class="w"> </span><span class="n">is_type_hole</span><span class="p">(</span><span class="nv">ReturnType</span><span class="p">)</span><span class="w"> </span><span class="k">of</span><span class="w"> </span>
<span class="w">    </span><span class="n">true</span><span class="w"> </span><span class="o">-&gt;</span><span class="w"> </span><span class="n">undefined</span><span class="p">;</span><span class="w">  </span><span class="c">% Let type checker infer</span>
<span class="w">    </span><span class="n">false</span><span class="w"> </span><span class="o">-&gt;</span><span class="w"> </span><span class="nv">ReturnType</span><span class="w"> </span>
<span class="k">end</span><span class="p">,</span>

<span class="c">% Create synthetic single-clause function</span>
<span class="nv">SyntheticFuncDef</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nl">#function_def</span><span class="p">{</span>
<span class="w">    </span><span class="n">name</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nv">Name</span><span class="p">,</span>
<span class="w">    </span><span class="n">params</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nv">CheckParams</span><span class="p">,</span>
<span class="w">    </span><span class="n">return_type</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nv">CheckReturnType</span><span class="p">,</span>
<span class="w">    </span><span class="n">body</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nv">CheckBody</span><span class="p">,</span>
<span class="w">    </span><span class="n">clauses</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">undefined</span><span class="p">,</span><span class="w">  </span><span class="c">% Force single-clause checking</span>
<span class="w">    </span><span class="p">...</span>
<span class="p">},</span>

<span class="c">% Type check and extract result</span>
<span class="p">{</span><span class="n">ok</span><span class="p">,</span><span class="w"> </span><span class="nv">NewEnv</span><span class="p">,</span><span class="w"> </span><span class="p">{</span><span class="n">typecheck_result</span><span class="p">,</span><span class="w"> </span><span class="n">true</span><span class="p">,</span><span class="w"> </span><span class="nv">ResultType</span><span class="p">,</span><span class="w"> </span><span class="p">_,</span><span class="w"> </span><span class="p">_}}</span><span class="w"> </span><span class="o">=</span><span class="w"> </span>
<span class="w">    </span><span class="nn">cure_typechecker</span><span class="p">:</span><span class="nf">check_function</span><span class="p">(</span><span class="nv">SyntheticFuncDef</span><span class="p">,</span><span class="w"> </span><span class="nv">EnvWithImports</span><span class="p">),</span>
<span class="nv">FunType</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nn">cure_types</span><span class="p">:</span><span class="nf">lookup_env</span><span class="p">(</span><span class="nv">NewEnv</span><span class="p">,</span><span class="w"> </span><span class="nv">Name</span><span class="p">),</span>
<span class="nv">ReturnType</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">extract_return_type</span><span class="p">(</span><span class="nv">FunType</span><span class="p">)</span>
</code></pre></div>

<h3 id="import-format-handling">Import Format Handling</h3>
<p>The parser provides imports in two formats:</p>
<ol>
<li><strong>Record format</strong>: <code>#function_import{name = map, arity = 2}</code></li>
<li><strong>Atom format</strong>: Just <code>map</code> (without arity information)</li>
</ol>
<p>For atom format imports, we default to arity 2 (common for stdlib functions like <code>map/2</code>, <code>filter/2</code>).</p>
<div class="codehilite"><pre><span></span><code><span class="nf">import_single_item</span><span class="p">(</span><span class="nv">Module</span><span class="p">,</span><span class="w"> </span><span class="nv">FunctionName</span><span class="p">,</span><span class="w"> </span><span class="nv">Env</span><span class="p">)</span><span class="w"> </span><span class="k">when</span><span class="w"> </span><span class="nb">is_atom</span><span class="p">(</span><span class="nv">FunctionName</span><span class="p">)</span><span class="w"> </span><span class="o">-&gt;</span>
<span class="w">    </span><span class="nv">Arity</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">2</span><span class="p">,</span><span class="w">  </span><span class="c">% Default arity for stdlib functions</span>
<span class="w">    </span><span class="nv">FunctionType</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">create_imported_function_type</span><span class="p">(</span><span class="nv">Module</span><span class="p">,</span><span class="w"> </span><span class="nv">FunctionName</span><span class="p">,</span><span class="w"> </span><span class="nv">Arity</span><span class="p">),</span>
<span class="w">    </span><span class="nv">NewEnv</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nn">cure_types</span><span class="p">:</span><span class="nf">extend_env</span><span class="p">(</span><span class="nv">Env</span><span class="p">,</span><span class="w"> </span><span class="nv">FunctionName</span><span class="p">,</span><span class="w"> </span><span class="nv">FunctionType</span><span class="p">),</span>
<span class="w">    </span><span class="p">{</span><span class="n">ok</span><span class="p">,</span><span class="w"> </span><span class="nv">NewEnv</span><span class="p">}.</span>
</code></pre></div>

<h3 id="type-conversion">Type Conversion</h3>
<p>Internal type representations are converted to AST format for display:</p>
<div class="codehilite"><pre><span></span><code><span class="nf">convert_type_to_ast_format</span><span class="p">({</span><span class="n">list_type</span><span class="p">,</span><span class="w"> </span><span class="nv">ElemType</span><span class="p">,</span><span class="w"> </span><span class="p">_</span><span class="nv">Length</span><span class="p">})</span><span class="w"> </span><span class="o">-&gt;</span>
<span class="w">    </span><span class="nl">#dependent_type</span><span class="p">{</span>
<span class="w">        </span><span class="n">name</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">&#39;List&#39;</span><span class="p">,</span>
<span class="w">        </span><span class="n">type_params</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">[</span><span class="n">convert_type_to_ast_format</span><span class="p">(</span><span class="nv">ElemType</span><span class="p">)],</span>
<span class="w">        </span><span class="p">...</span>
<span class="w">    </span><span class="p">}.</span>
</code></pre></div>

<h2 id="results">Results</h2>
<p>The implementation successfully:</p>
<p>✅ Detects type holes in function return types<br />
✅ Extracts and processes module imports<br />
✅ Loads imported function types into the environment<br />
✅ Infers return types for functions using imported functions<br />
✅ Handles both single-clause and multi-clause functions<br />
✅ Reports type errors when inference fails  </p>
<h3 id="example-output">Example Output</h3>
<p>For <code>examples/type_holes_demo.cure</code>:</p>
<div class="codehilite"><pre><span></span><code><span class="nx">Found</span><span class="w"> </span><span class="mi">2</span><span class="w"> </span><span class="k">type</span><span class="w"> </span><span class="nx">holes</span><span class="p">:</span>
<span class="w">  </span><span class="o">-</span><span class="w"> </span><span class="sc">&#39;_&#39;</span><span class="w"> </span><span class="nx">at</span><span class="w"> </span><span class="nx">line</span><span class="w"> </span><span class="mi">12</span><span class="w"> </span><span class="p">(</span><span class="nx">double_list</span><span class="p">)</span>
<span class="w">    </span><span class="err">✓</span><span class="w"> </span><span class="nx">Inferred</span><span class="w"> </span><span class="k">type</span><span class="p">:</span><span class="w"> </span><span class="nx">List</span><span class="p">(</span><span class="nx">Int</span><span class="p">)</span>

<span class="w">  </span><span class="o">-</span><span class="w"> </span><span class="sc">&#39;_&#39;</span><span class="w"> </span><span class="nx">at</span><span class="w"> </span><span class="nx">line</span><span class="w"> </span><span class="mi">17</span><span class="w"> </span><span class="p">(</span><span class="nx">process_data</span><span class="p">)</span><span class="w">  </span>
<span class="w">    </span><span class="err">✓</span><span class="w"> </span><span class="nx">Inferred</span><span class="w"> </span><span class="k">type</span><span class="p">:</span><span class="w"> </span><span class="nx">List</span><span class="p">(</span><span class="nx">Int</span><span class="p">)</span>
</code></pre></div>

<p>Both functions now correctly infer <code>List(Int)</code> with fully resolved type parameters!</p>
<h2 id="files-modified">Files Modified</h2>
<ul>
<li><code>/opt/Proyectos/Ammotion/cure/lsp/cure_lsp_type_holes.erl</code> - Main implementation</li>
<li><code>infer_function_return_type/2</code> - Core type inference logic</li>
<li><code>build_module_env/1</code> - Import extraction and environment building</li>
<li><code>process_imports_for_env/2</code> - Import processing pipeline</li>
<li><code>import_single_item/3</code> - Individual import handling</li>
<li><code>create_imported_function_type/3</code> - Type creation for imports</li>
</ul>
<h2 id="technical-challenges-overcome">Technical Challenges Overcome</h2>
<ol>
<li><strong>Multi-clause function handling</strong> - Discovered that <code>check_multiclause_function</code> doesn't return the function in the environment</li>
<li><strong>Import format variations</strong> - Handled both record and atom formats for imports</li>
<li><strong>Module structure</strong> - Imports are stored in <code>items</code> list, not a separate field</li>
<li><strong>Type hole detection</strong> - Distinguished type holes (<code>_</code>) from regular undefined types</li>
<li><strong>Environment threading</strong> - Properly passed enriched environments through the type checking pipeline</li>
</ol>
<h2 id="future-improvements">Future Improvements</h2>
<ol>
<li><strong>Arity inference</strong> - Query modules for actual arities instead of defaulting to 2</li>
<li><strong>Caching</strong> - Cache imported function types to avoid repeated lookups</li>
<li><strong>Error messages</strong> - Provide more detailed error messages when type inference fails</li>
<li><strong>Type parameter inference</strong> - Better handling of polymorphic type parameters in inferred types</li>
<li><strong>Multi-clause unification</strong> - Unify types across all clauses instead of just using the first</li>
</ol>
<h2 id="testing">Testing</h2>
<p>Test file: <code>/opt/Proyectos/Ammotion/cure/examples/type_holes_demo.cure</code></p>
<p>The implementation has been tested with:<br />
- Functions using <code>map/2</code> from <code>Std.List</code><br />
- Functions using <code>filter/2</code> from <code>Std.List</code><br />
- Multi-clause function definitions<br />
- Both valid code (successful inference) and invalid code (expected errors)</p>
<h2 id="conclusion">Conclusion</h2>
<p>The LSP type hole feature now successfully infers types for functions that use imported functions, providing a complete Idris-style type hole experience in the Cure language.</p>
    </div>

    <!-- Footer -->
    <footer class="site-footer">
        <div class="footer-content">
            <div class="footer-section">
                <h4>Documentation</h4>
                <ul>
                    <li><a href="../docs.html">Getting Started</a></li>
                    <li><a href="language-spec.html">Language Specification</a></li>
                    <li><a href="type-system.html">Type System</a></li>
                    <li><a href="fsm-usage.html">FSM Guide</a></li>
                </ul>
            </div>

            <div class="footer-section">
                <h4>Reference</h4>
                <ul>
                    <li><a href="../api/index.html">API Reference</a></li>
                    <li><a href="std-summary.html">Standard Library</a></li>
                    <li><a href="feature-reference.html">Feature Reference</a></li>
                    <li><a href="cli-usage.html">CLI Usage</a></li>
                </ul>
            </div>

            <div class="footer-section">
                <h4>Resources</h4>
                <ul>
                    <li><a href="editor-setup.html">Editor Setup</a></li>
                    <li><a href="project-overview.html">Project Overview</a></li>
                    <li><a href="cure-ultimate-description.html">Ultimate Guide</a></li>
                </ul>
            </div>
        </div>

        <div class="footer-bottom">
            <p>&copy; 2025 Cure Programming Language. Verification-first programming for the BEAM.</p>
        </div>
    </footer>
</body>
</html>
