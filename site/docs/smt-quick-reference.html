<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>SMT Solver Quick Reference - Cure Documentation</title>
    <meta name="description" content="Status: ✅ Production Ready  
Solver: Z3 4.13.3  
Test Coverage: 100% (12/12 tests passing)">
    <link rel="icon" type="image/png" href="../media/logo-128x128.png">
    <link rel="stylesheet" href="../css/style.css">
</head>
<body>
    <!-- Header -->
    <header class="site-header">
        <div class="nav-container">
            <div class="logo-section">
                <img src="../media/logo-128x128.png" alt="Cure Logo" class="logo">
                <div>
                    <h1 class="site-title">Cure</h1>
                    <p class="site-tagline">Verification-First Programming</p>
                </div>
            </div>
            <nav class="main-nav">
                <ul>
                    <li><a href="../index.html">Home</a></li>
                    <li><a href="../docs.html">Documentation</a></li>
                    <li><a href="../api/index.html">API Reference</a></li>
                </ul>
            </nav>
        </div>
    </header>

    <!-- Main Content -->
    <div class="doc-page">
        <div class="doc-nav">
            <a href="../docs.html">← Back to Documentation</a>
        </div>
        
        <h1>SMT Solver Quick Reference</h1>

<strong>Status:</strong> ✅ Production Ready  
<strong>Solver:</strong> Z3 4.13.3  
<strong>Test Coverage:</strong> 100% (12/12 tests passing)

<p>---</p>

<h2>Quick Start</h2>

<h3>1. Verify Z3 is Installed</h3>
<pre><code>z3 --version
<h1>Z3 version 4.13.3 - 64 bit</h1>
</code></pre>

<h3>2. Run SMT Tests</h3>
<pre><code>make clean && make all
<p>erl -pa <em>build/ebin -s smt</em>process<em>test run -s smt</em>parser_test run -s init stop</p>
<h1>All 12 tests should pass</h1>
</code></pre>

<p>---</p>

<h2>API Reference</h2>

<h3>High-Level API (<code>cure<em>smt</em>solver.erl</code>)</h3>

<h4>Check if Constraint is Satisfiable</h4>
<pre><code>cure<em>smt</em>solver:check_constraint(Constraint, Env).
<p>% Returns: sat | unsat | unknown</p>
</code></pre>

<h4>Prove Constraint Always Holds</h4>
<pre><code>cure<em>smt</em>solver:prove_constraint(Constraint, Env).
<p>% Returns: true | false | unknown</p>
</code></pre>

<h4>Find Counterexample</h4>
<pre><code>cure<em>smt</em>solver:find_counterexample(Constraint, Env).
<p>% Returns: {ok, Model} | none | unknown</p>
</code></pre>

<h3>Mid-Level API (Direct Solver Access)</h3>

<h4>Start Solver</h4>
<pre><code>{ok, Pid} = cure<em>smt</em>process:start_solver(z3, 5000).
<p>% Solver: z3 | cvc5</p>
<p>% Timeout: milliseconds</p>
</code></pre>

<h4>Execute Query</h4>
<pre><code>Query = cure<em>smt</em>translator:generate_query(Constraint, Env),
<p>Result = cure<em>smt</em>process:execute_query(Pid, Query).</p>
<p>% Returns: sat | unsat | {sat, Lines} | {error, Reason}</p>
</code></pre>

<h4>Parse Model</h4>
<pre><code>{ok, Model} = cure<em>smt</em>parser:parse_model(Lines).
<p>% Returns: {ok, #{var => value}} | {error, Reason}</p>
</code></pre>

<h4>Stop Solver</h4>
<pre><code>cure<em>smt</em>process:stop_solver(Pid).
</code></pre>

<p>---</p>

<h2>Examples</h2>

<h3>Example 1: Verify Positive Number</h3>
<pre><code>% Constraint: x > 0
<p>Constraint = #binary<em>op</em>expr{</p>
<p>    op = '>',</p>
<p>    left = #identifier_expr{name = x},</p>
<p>    right = #literal_expr{value = 0}</p>
<p>},</p>

<p>Env = #{x => {type, int}},</p>

<p>% Check if satisfiable</p>
<p>cure<em>smt</em>solver:check_constraint(Constraint, Env).</p>
<p>% => sat (there exists x > 0)</p>

<p>% Find example</p>
<p>cure<em>smt</em>solver:find_counterexample(</p>
<p>    #unary<em>op</em>expr{op = 'not', operand = Constraint},</p>
<p>    Env</p>
<p>).</p>
<p>% => {ok, #{x => 0}} (x=0 is counterexample to x > 0)</p>
</code></pre>

<h3>Example 2: Verify Division Safety</h3>
<pre><code>% Constraint: y /= 0
<p>Constraint = #binary<em>op</em>expr{</p>
<p>    op = '/=',</p>
<p>    left = #identifier_expr{name = y},</p>
<p>    right = #literal_expr{value = 0}</p>
<p>},</p>

<p>Env = #{y => {type, int}},</p>

<p>% This is satisfiable (y can be non-zero)</p>
<p>cure<em>smt</em>solver:check_constraint(Constraint, Env).</p>
<p>% => sat</p>

<p>% But can we find y = 0? (violates constraint)</p>
<p>cure<em>smt</em>solver:find_counterexample(Constraint, Env).</p>
<p>% => {ok, #{y => 0}} (counterexample exists)</p>
</code></pre>

<h3>Example 3: Prove Arithmetic Property</h3>
<pre><code>% Constraint: x + y == y + x (commutativity)
<p>Constraint = #binary<em>op</em>expr{</p>
<p>    op = '==',</p>
<p>    left = #binary<em>op</em>expr{</p>
<p>        op = '+',</p>
<p>        left = #identifier_expr{name = x},</p>
<p>        right = #identifier_expr{name = y}</p>
<p>    },</p>
<p>    right = #binary<em>op</em>expr{</p>
<p>        op = '+',</p>
<p>        left = #identifier_expr{name = y},</p>
<p>        right = #identifier_expr{name = x}</p>
<p>    }</p>
<p>},</p>

<p>Env = #{x => {type, int}, y => {type, int}},</p>

<p>% This should be proven true</p>
<p>cure<em>smt</em>solver:prove_constraint(Constraint, Env).</p>
<p>% => true (no counterexample exists)</p>
</code></pre>

<h3>Example 4: Complex Constraint</h3>
<pre><code>% Constraint: (x > 0) and (y > 0) => (x + y > 0)
<p>Constraint = #binary<em>op</em>expr{</p>
<p>    op = '=>',</p>
<p>    left = #binary<em>op</em>expr{</p>
<p>        op = 'and',</p>
<p>        left = #binary<em>op</em>expr{op = '>', left = var(x), right = lit(0)},</p>
<p>        right = #binary<em>op</em>expr{op = '>', left = var(y), right = lit(0)}</p>
<p>    },</p>
<p>    right = #binary<em>op</em>expr{</p>
<p>        op = '>',</p>
<p>        left = #binary<em>op</em>expr{op = '+', left = var(x), right = var(y)},</p>
<p>        right = lit(0)</p>
<p>    }</p>
<p>},</p>

<p>Env = #{x => {type, int}, y => {type, int}},</p>

<p>cure<em>smt</em>solver:prove_constraint(Constraint, Env).</p>
<p>% => true (proven!)</p>
</code></pre>

<p>---</p>

<h2>Constraint Translation</h2>

<h3>Supported Operators</h3>

<h4>Arithmetic</h4>
<ul>
<li><code>+</code>, <code>-</code>, <code><em></code> → <code>(+ x y)</code>, <code>(- x y)</code>, <code>(</em> x y)</code></li>
<li><code>/</code> → <code>(/ x y)</code> (real division)</li>
<li><code>div</code> → <code>(div x y)</code> (integer division)</li>
<li><code>rem</code> → <code>(mod x y)</code> (remainder)</li>
</ul>

<h4>Comparison</h4>
<ul>
<li><code>==</code>, <code>/=</code> → <code>(= x y)</code>, <code>(not (= x y))</code></li>
<li><code><</code>, <code>></code> → <code>(< x y)</code>, <code>(> x y)</code></li>
<li><code>=<</code>, <code>>=</code> → <code>(<= x y)</code>, <code>(>= x y)</code></li>
</ul>

<h4>Boolean</h4>
<ul>
<li><code>and</code>, <code>or</code>, <code>not</code> → <code>(and x y)</code>, <code>(or x y)</code>, <code>(not x)</code></li>
<li><code>andalso</code>, <code>orelse</code> → same as <code>and</code>, <code>or</code></li>
<li><code>=></code> → <code>(=> x y)</code> (implication)</li>
</ul>

<h4>Unary</h4>
<ul>
<li><code>-</code> (negation) → <code>(- x)</code></li>
<li><code>not</code> (boolean) → <code>(not x)</code></li>
</ul>

<h3>Type Mapping</h3>
<ul>
<li><code>Int</code>, <code>Nat</code> → <code>Int</code> (SMT integer)</li>
<li><code>Bool</code> → <code>Bool</code> (SMT boolean)</li>
<li><code>Float</code>, <code>Real</code> → <code>Real</code> (SMT real)</li>
</ul>

<h3>Logic Inference</h3>
<p>The translator automatically infers the SMT logic:</p>
<ul>
<li><code>QF_LIA</code> - Linear Integer Arithmetic (Int only)</li>
<li><code>QF_LRA</code> - Linear Real Arithmetic (Real only)</li>
<li><code>QF_LIRA</code> - Linear Mixed Integer/Real Arithmetic</li>
<li><code>QF_NIA</code> - Nonlinear Integer Arithmetic (with *, /)</li>
</ul>

<p>---</p>

<h2>Timeout Configuration</h2>

<p>Default timeout is 5000ms. Configure per-solver:</p>

<pre><code>{ok, Pid} = cure<em>smt</em>process:start_solver(z3, 10000). % 10 seconds
</code></pre>

<p>Or use default:</p>
<pre><code>{ok, Pid} = cure<em>smt</em>process:start_solver(z3, 5000).
</code></pre>

<p>---</p>

<h2>Error Handling</h2>

<p>All functions have graceful error handling:</p>

<pre><code>case cure<em>smt</em>solver:check_constraint(Constraint, Env) of
<p>    sat -> io:format("Satisfiable~n");</p>
<p>    unsat -> io:format("Unsatisfiable~n");</p>
<p>    unknown -> io:format("Solver could not determine~n");</p>
<p>    {error, Reason} -> io:format("Error: ~p~n", [Reason])</p>
<p>end.</p>
</code></pre>

<p>If SMT solver fails, the system falls back to symbolic evaluation.</p>

<p>---</p>

<h2>Testing</h2>

<h3>Run All Tests</h3>
<pre><code>erl -pa <em>build/ebin -s smt</em>process<em>test run -s smt</em>parser_test run -s init stop
</code></pre>

<h3>Run Process Tests Only</h3>
<pre><code>erl -pa <em>build/ebin -s smt</em>process_test run -s init stop
</code></pre>

<h3>Run Parser Tests Only</h3>
<pre><code>erl -pa <em>build/ebin -s smt</em>parser_test run -s init stop
</code></pre>

<p>---</p>

<h2>Troubleshooting</h2>

<h3>Z3 Not Found</h3>
<pre><code>Error: Z3 solver not found
</code></pre>
<strong>Solution:</strong> Install Z3
<pre><code>sudo apt install z3  # Ubuntu/Debian
<p>brew install z3      # macOS</p>
</code></pre>

<h3>Timeout Errors</h3>
<pre><code>{error, timeout}
</code></pre>
<strong>Solution:</strong> Increase timeout
<pre><code>{ok, Pid} = cure<em>smt</em>process:start_solver(z3, 30000). % 30 seconds
</code></pre>

<h3>Parse Errors</h3>
<pre><code>{error, {parse_error, Reason}}
</code></pre>
<strong>Solution:</strong> Check constraint syntax and types in environment.

<p>---</p>

<h2>Performance Tips</h2>

<ol>
<li><strong>Reuse solver processes</strong> - Starting solver has ~50ms overhead</li>
<li><strong>Use appropriate timeout</strong> - Complex constraints may need >5s</li>
<li><strong>Simplify constraints</strong> - Break complex constraints into parts</li>
<li><strong>Cache results</strong> - Identical constraints return same result</li>
</ol>

<p>---</p>

<h2>Architecture</h2>

<pre><code>User Code
<p>    ↓</p>
<p>cure<em>smt</em>solver (High-level API)</p>
<p>    ↓</p>
<p>cure<em>smt</em>translator (AST → SMT-LIB)</p>
<p>    ↓</p>
<p>cure<em>smt</em>process (Solver management)</p>
<p>    ↓</p>
<p>Z3 Solver (via Erlang port)</p>
<p>    ↓</p>
<p>cure<em>smt</em>parser (Model extraction)</p>
<p>    ↓</p>
<p>Result</p>
</code></pre>

<p>---</p>

<h2>Files</h2>

<h3>Core Implementation</h3>
<ul>
<li><code>src/smt/cure<em>smt</em>solver.erl</code> - High-level API</li>
<li><code>src/smt/cure<em>smt</em>translator.erl</code> - Constraint translation</li>
<li><code>src/smt/cure<em>smt</em>process.erl</code> - Solver process management</li>
<li><code>src/smt/cure<em>smt</em>parser.erl</code> - Model parser</li>
</ul>

<h3>Tests</h3>
<ul>
<li><code>test/smt<em>process</em>test.erl</code> - Process management tests (7 tests)</li>
<li><code>test/smt<em>parser</em>test.erl</code> - Parser tests (5 tests)</li>
</ul>

<h3>Documentation</h3>
<ul>
<li><code>docs/SMT<em>INTEGRATION</em>COMPLETE.md</code> - Complete overview</li>
<li><code>docs/SMT<em>INTEGRATION</em>PLAN.md</code> - Original plan</li>
<li><code>docs/SMT<em>COMPLETION</em>PLAN.md</code> - 4-step completion plan</li>
<li><code>docs/SMT<em>SOLVER</em>INSTALLATION.md</code> - Installation guide</li>
</ul>

<p>---</p>

<h2>Integration Status</h2>

<h3>✅ Completed</h3>
<ul>
<li>Core SMT solver implementation</li>
<li>Z3 solver support with process management</li>
<li>Constraint translation (AST → SMT-LIB)</li>
<li>Model parsing and result extraction</li>
<li>Comprehensive test suite (12/12 tests passing)</li>
<li>High-level API for constraint checking</li>
</ul>

<h3>📋 Planned</h3>
<ol>
<li><strong>CLI Integration</strong>: Add command-line flags for SMT solver control</li>
</ol>
<ul>
<li><code>--smt-solver [z3|cvc5]</code></li>
<li><code>--smt-timeout <ms></code></li>
<li><code>--no-smt</code></li>
</ul>
<ol>
<li><strong>Type Checker Integration</strong>: Automatic verification during type checking</li>
<li><strong>CVC5 Support</strong>: Complete CVC5 solver implementation (stub exists)</li>
<li><strong>Result Caching</strong>: Cache constraint checking results for performance</li>
<li><strong>Distributed Solver Pool</strong>: Parallel constraint solving</li>
</ol>

<p>---</p>

<strong>Version:</strong> 1.0  
<strong>Last Updated:</strong> October 31, 2025  
<strong>Status:</strong> Production Ready ✅

<strong>Note</strong>: SMT solver integration is available at the Erlang API level. CLI integration is not yet implemented.

    </div>

    <!-- Pill Decoration -->
    <img src="../media/pill-512x512.png" alt="" class="pill-decoration">

    <!-- Footer -->
    <footer class="site-footer">
        <div class="footer-content">
            <div class="footer-section">
                <h4>Documentation</h4>
                <ul>
                    <li><a href="../docs.html">Getting Started</a></li>
                    <li><a href="language-spec.html">Language Specification</a></li>
                    <li><a href="type-system.html">Type System</a></li>
                    <li><a href="fsm-usage.html">FSM Guide</a></li>
                </ul>
            </div>

            <div class="footer-section">
                <h4>Reference</h4>
                <ul>
                    <li><a href="../api/index.html">API Reference</a></li>
                    <li><a href="std-summary.html">Standard Library</a></li>
                    <li><a href="feature-reference.html">Feature Reference</a></li>
                    <li><a href="cli-usage.html">CLI Usage</a></li>
                </ul>
            </div>

            <div class="footer-section">
                <h4>Resources</h4>
                <ul>
                    <li><a href="editor-setup.html">Editor Setup</a></li>
                    <li><a href="project-overview.html">Project Overview</a></li>
                    <li><a href="cure-ultimate-description.html">Ultimate Guide</a></li>
                </ul>
            </div>
        </div>

        <div class="footer-bottom">
            <p>&copy; 2025 Cure Programming Language. Verification-first programming for the BEAM.</p>
        </div>
    </footer>
</body>
</html>
