## Dependent Types with SMT Verification
##
## This file demonstrates dependent type checking using the integrated
## SMT solver. The Cure compiler will verify these constraints at compile time.

module DependentTypesSMT

## Safe division - divisor must be non-zero
def safe_div(x: Int, y: Int): Int when y /= 0 =
    x / y

## Vector head - vector must be non-empty
def vector_head<T, n: Nat>(v: Vector(T, n)): T when n > 0 =
    v[0]

## Array access - index must be in bounds
def array_get<T, n: Nat>(arr: Vector(T, n), i: Nat): T when i < n =
    arr[i]

## Positive sqrt - input must be non-negative
def safe_sqrt(x: Int): Float when x >= 0 =
    Math.sqrt(x)

## Range constraint - value must be in range
def clamp(x: Int, min: Int, max: Int): Int when min =< max =
    if x < min then
        min
    else if x > max then
        max
    else
        x

## Test cases that should compile
def test_safe_operations() =
    # These should all pass SMT verification
    let result1 = safe_div(10, 5)       # 5 /= 0 ✓
    let result2 = safe_div(20, 2)       # 2 /= 0 ✓
    let result3 = safe_sqrt(16)         # 16 >= 0 ✓
    let result4 = safe_sqrt(0)          # 0 >= 0 ✓
    let result5 = clamp(5, 0, 10)       # 0 =< 10 ✓
    
    # Vector operations
    let vec = [1, 2, 3]
    let head = vector_head(vec)         # 3 > 0 ✓
    let elem = array_get(vec, 1)        # 1 < 3 ✓
    
    result1

## Test cases that should fail (commented out to allow compilation)
## Uncomment to see SMT solver catch the violations

# def test_unsafe_operations() =
#     # These should fail SMT verification
#     let bad1 = safe_div(10, 0)         # 0 /= 0 ✗ (counterexample: y = 0)
#     let bad2 = safe_sqrt(-5)           # -5 >= 0 ✗ (counterexample: x = -5)
#     let bad3 = clamp(5, 10, 0)         # 10 =< 0 ✗ (counterexample: min=10, max=0)
#     
#     # Vector operations with violations
#     let empty = []
#     let bad4 = vector_head(empty)      # 0 > 0 ✗ (counterexample: n = 0)
#     let bad5 = array_get([1, 2], 5)    # 5 < 2 ✗ (counterexample: i=5, n=2)
#     
#     bad1

## Complex constraint - demonstrates SMT solving power
def safe_avg(x: Int, y: Int): Int when x > 0 and y > 0 =
    (x + y) / 2

## Implication constraint
def process_positive(x: Int, threshold: Int): Bool when x > threshold => x > 0 =
    x > threshold

## Multiple constraints
def bounded_div(x: Int, y: Int, min: Int, max: Int): Int 
    when y /= 0 and min =< max and x >= min and x =< max =
    x / y

## Property: Addition is commutative (always provable)
def test_commutativity(x: Int, y: Int): Bool when x + y == y + x =
    true

## Property: Positive sum (conditional property)
def positive_sum(x: Int, y: Int): Int when x > 0 and y > 0 => x + y > 0 =
    x + y
