# Pattern Matching Examples in Cure
# This file demonstrates various pattern matching techniques and features

module PatternMatching do
  export [demo_all/0, list_operations/1, result_handling/1, record_matching/1]

  # Import standard types for demonstration (functions removed due to import issues)
  import Std [Result, Option, List]

  # Record definitions for examples
  record Person do
    name: String
    age: Int
    email: String
  end

  record Point do
    x: Float
    y: Float
  end

  # Union types for demonstration
  type Shape = Circle(Float) | Rectangle(Float, Float) | Square(Float)
  type Status = Active | Inactive | Pending | Archived

  # === BASIC PATTERN MATCHING ===

  # Simple value matching
  def describe_number(n: Int): String =
    match n do
      0 -> "zero"
      1 -> "one"
      2 -> "two"
      _ -> "other number"
    end

  # List pattern matching with head/tail destructuring
  def list_operations(list: List(Int)): String =
    match list do
      [] -> "empty list"
      [x] -> "single element: " ++ show(x)
      [x, y] -> "two elements: " ++ show(x) ++ " and " ++ show(y)
      [head | tail] -> 
        "head is " ++ show(head) ++ ", tail has " ++ show(length(tail)) ++ " elements"
    end

  # Pattern matching with guards
  def classify_number(n: Int): String =
    match n do
      x when x < 0 -> "negative: " ++ show(x)
      x when x == 0 -> "zero"
      x when x > 0 and x <= 10 -> "small positive: " ++ show(x)
      x when x > 10 and x <= 100 -> "medium positive: " ++ show(x)
      x when x > 100 -> "large positive: " ++ show(x)
    end

  # === RECORD PATTERN MATCHING ===

  def greet_person(person: Person): String =
    match person do
      Person{name: name, age: age} when age >= 65 ->
        "Hello, senior " ++ name ++ "!"
      Person{name: name, age: age} when age >= 18 ->
        "Hello, " ++ name ++ "! You are " ++ show(age) ++ " years old."
      Person{name: name, age: age} when age >= 13 ->
        "Hey there, teen " ++ name ++ "!"
      Person{name: name, age: _} ->
        "Hi, young " ++ name ++ "!"
    end

  def record_matching(person: Person): String =
    match person do
      # Match specific name
      Person{name: "Alice", age: age} ->
        "Special greeting for Alice, age " ++ show(age)
      
      # Match email domain pattern (simplified - no string pattern matching for now)  
      Person{email: email, name: name} when email == "user@company.com" ->
        "Corporate user: " ++ name
      
      # Generic pattern with field extraction
      Person{name: name, age: age, email: email} ->
        name ++ " (" ++ show(age) ++ ") - " ++ email
    end

  # === UNION TYPE PATTERN MATCHING ===

  def calculate_area(shape: Shape): Float =
    match shape do
      Circle(radius) -> 3.14159 * radius * radius
      Rectangle(width, height) -> width * height
      Square(side) -> side * side
    end

  def shape_description(shape: Shape): String =
    match shape do
      Circle(r) when r > 10.0 -> "Large circle with radius " ++ show(r)
      Circle(r) -> "Circle with radius " ++ show(r)
      Rectangle(w, h) when w == h -> "Square-like rectangle " ++ show(w) ++ "x" ++ show(h)
      Rectangle(w, h) -> "Rectangle " ++ show(w) ++ "x" ++ show(h)
      Square(s) -> "Square with side " ++ show(s)
    end

  # === RESULT AND OPTION PATTERN MATCHING ===

  def result_handling(result: Result(Int, String)): String =
    match result do
      Ok(value) when value > 100 -> "Success with large value: " ++ show(value)
      Ok(value) -> "Success: " ++ show(value)
      Error(msg) -> "Failed: " ++ msg
    end

  def option_handling(opt: Option(String)): String =
    match opt do
      Some(value) -> "String: " ++ value
      None -> "No value provided"
    end

  # === NESTED PATTERN MATCHING ===

  def process_nested_result(result: Result(Option(Int), String)): String =
    match result do
      Ok(Some(value)) when value > 0 -> "Positive value: " ++ show(value)
      Ok(Some(value)) -> "Non-positive value: " ++ show(value)
      Ok(None) -> "Success but no value"
      Error(msg) -> "Error: " ++ msg
    end

  # === TUPLE PATTERN MATCHING ===

  def process_coordinates(point: {Float, Float}): String =
    match point do
      {0.0, 0.0} -> "Origin point"
      {x, 0.0} -> "On X-axis at " ++ show(x)
      {0.0, y} -> "On Y-axis at " ++ show(y)
      {x, y} when x == y -> "Diagonal point at " ++ show(x)
      {x, y} when x > 0.0 and y > 0.0 -> "First quadrant: (" ++ show(x) ++ ", " ++ show(y) ++ ")"
      {x, y} -> "Point: (" ++ show(x) ++ ", " ++ show(y) ++ ")"
    end

  # === COMPLEX NESTED MATCHING ===

  def analyze_data(data: List(Result(Person, String))): String =
    match data do
      [] -> "No data to analyze"
      [Ok(person)] -> "Single person: " ++ person.name
      [Error(err)] -> "Single error: " ++ err
      results -> 
        let successful = filter_successes(results)
        let errors = filter_errors(results)
        "Processed " ++ show(length(successful)) ++ " people, " ++ 
        show(length(errors)) ++ " errors"
    end

  # Helper functions for the complex example
  def filter_successes(results: List(Result(Person, String))): List(Person) =
    match results do
      [] -> []
      [Ok(person) | rest] -> [person | filter_successes(rest)]
      [Error(_) | rest] -> filter_successes(rest)
    end

  def filter_errors(results: List(Result(Person, String))): List(String) =
    match results do
      [] -> []
      [Ok(_) | rest] -> filter_errors(rest)
      [Error(err) | rest] -> [err | filter_errors(rest)]
    end

  # === DEMONSTRATION FUNCTION ===

  def demo_all(): Unit =
    # Test basic number matching
    print("=== Number Classification ===")
    print(describe_number(0))        # "zero"
    print(describe_number(2))        # "two"
    print(classify_number(-5))       # "negative: -5"
    print(classify_number(50))       # "medium positive: 50"
    
    # Test list operations
    print("\n=== List Operations ===")
    print(list_operations([]))       # "empty list"
    print(list_operations([42]))     # "single element: 42"
    print(list_operations([1, 2, 3, 4]))  # head/tail description
    
    # Test record matching
    print("\n=== Record Matching ===")
    let alice = Person{name: "Alice", age: 30, email: "alice@example.com"}
    let bob = Person{name: "Bob", age: 17, email: "bob@company.com"}
    print(greet_person(alice))
    print(record_matching(bob))
    
    # Test shape calculations
    print("\n=== Shape Calculations ===")
    let circle = Circle(5.0)
    let square = Square(4.0)
    print("Circle area: " ++ show(calculate_area(circle)))
    print(shape_description(square))
    
    # Test result handling
    print("\n=== Result Handling ===")
    print(result_handling(Ok(150)))
    print(result_handling(Error("Network timeout")))
    print(option_handling(Some("Hello")))
    print(option_handling(None))
    
    # Test coordinates
    print("\n=== Coordinate Processing ===")
    print(process_coordinates({0.0, 0.0}))
    print(process_coordinates({5.0, 5.0}))
    print(process_coordinates({3.0, -2.0}))
    
    ok

end
