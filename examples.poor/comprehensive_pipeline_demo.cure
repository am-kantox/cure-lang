# Comprehensive Pipeline Operator Demo
# Demonstrates all three rules for the monadic pipeline operator

module ComprehensivePipelineDemo do
  export [main/0, double/1, add_ten/1, safe_divide/2, check_positive/1, make_error/1]

  def main(): Int =
    let _ = println("=== Comprehensive Pipeline Operator Demo ===")
    
    # Rule 1: Error Propagation
    # If LHO is error(reason), just propagate it down the pipe
    let _ = println("\n--- Rule 1: Error Propagation ---")
    let _ = println("Expression: error(\"Initial error\") |> double")
    let result1 = error("Initial error") |> double
    let _ = println("Expected: {'Error', \"Initial error\"}")
    let _ = println_result(result1)
    
    let _ = println("\nChaining with error at start:")
    let _ = println("Expression: error(\"First error\") |> double |> add_ten")
    let result1_chain = error("First error") |> double |> add_ten
    let _ = println_result(result1_chain)
    
    # Rule 2: Ok Value Unwrapping and Wrapping
    # If LHO is ok(value), unwrap the value, pass it to RHO, and wrap result in ok() if not already a monad
    let _ = println("\n--- Rule 2: Ok Value Unwrapping ---")
    let _ = println("Expression: ok(5) |> double")
    let result2 = ok(5) |> double
    let _ = println("Expected: {'Ok', 10}")
    let _ = println_result(result2)
    
    let _ = println("\nChaining ok values:")
    let _ = println("Expression: ok(3) |> double |> add_ten")
    let result2_chain = ok(3) |> double |> add_ten
    let _ = println("Expected: {'Ok', 16}")
    let _ = println_result(result2_chain)
    
    let _ = println("\nOk value leading to error in function:")
    let _ = println("Expression: ok(-5) |> check_positive")
    let result2_error = ok(-5) |> check_positive
    let _ = println("Expected: {'Error', \"Value must be positive\"}")
    let _ = println_result(result2_error)
    
    # Rule 3: Non-monad Value Handling
    # If LHO is neither ok() nor error(), pass it to RHO and wrap result in ok() unless already a monad
    let _ = println("\n--- Rule 3: Non-monad Value Handling ---")
    let _ = println("Expression: 7 |> double")
    let result3 = 7 |> double
    let _ = println("Expected: {'Ok', 14}")
    let _ = println_result(result3)
    
    let _ = println("\nChaining non-monad values:")
    let _ = println("Expression: 4 |> double |> add_ten")
    let result3_chain = 4 |> double |> add_ten
    let _ = println("Expected: {'Ok', 18}")
    let _ = println_result(result3_chain)
    
    let _ = println("\nNon-monad leading to error in function:")
    let _ = println("Expression: -3 |> check_positive")
    let result3_error = -3 |> check_positive
    let _ = println("Expected: {'Error', \"Value must be positive\"}")
    let _ = println_result(result3_error)
    
    # Complex chaining scenarios
    let _ = println("\n--- Complex Chaining Scenarios ---")
    let _ = println("Success chain: 10 |> double |> check_positive |> add_ten")
    let complex1 = 10 |> double |> check_positive |> add_ten
    let _ = println_result(complex1)
    
    let _ = println("\nError in middle of chain: -5 |> double |> check_positive |> add_ten")
    let complex2 = -5 |> double |> check_positive |> add_ten
    let _ = println_result(complex2)
    
    let _ = println("\nMixed monad and non-monad: ok(6) |> add_ten |> check_positive")
    let complex3 = ok(6) |> add_ten |> check_positive
    let _ = println_result(complex3)
    
    # Division examples with Result-returning functions
    let _ = println("\n--- Division Examples ---")
    let _ = println("Safe division success: 20 |> safe_divide(4)")
    let div1 = 20 |> safe_divide(4)
    let _ = println_result(div1)
    
    let _ = println("Safe division by zero: 20 |> safe_divide(0)")
    let div2 = 20 |> safe_divide(0)
    let _ = println_result(div2)
    
    let _ = println("Chaining division: ok(20) |> safe_divide(4) |> double")
    let div3 = ok(20) |> safe_divide(4) |> double
    let _ = println_result(div3)
    
    42

  # Helper functions demonstrating different return types
  
  # Regular function returning plain value
  def double(x: Int): Int =
    x * 2
    
  # Regular function returning plain value
  def add_ten(x: Int): Int =
    x + 10
    
  # Function returning Result type
  def safe_divide(numerator: Int, denominator: Int) =
    if denominator == 0 then
      error("Division by zero")
    else
      ok(numerator / denominator)
    end
    
  # Function returning Result type based on condition
  def check_positive(x: Int) =
    if x > 0 then
      ok(x)
    else
      error("Value must be positive")
    end
  
  # Function that always returns error (for testing)
  def make_error(x: Int) =
    error("Deliberate error from make_error")
    
  # Utility function to print results
  def println_result(result) =
    match result do
      Ok(value) -> 
        let msg = "Result: {'Ok', " ++ int_to_string(value) ++ "}"
        println(msg)
      Error(reason) -> 
        let msg = "Result: {'Error', \"" ++ reason ++ "\"}"
        println(msg)
      _ ->
        println("Result: Unknown format")
    end
end