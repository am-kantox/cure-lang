# Cure Erlang Interoperability Demo
# Demonstrates the def_erl feature for calling Erlang code

module ErlangInteropDemo do
  export [
    # Regular Cure functions
    safe_add/2,
    
    # Erlang interop functions  
    erlang_length/1,
    erlang_reverse/1,
    erlang_timestamp/0,
    complex_erlang_calculation/2
  ]

  # Regular Cure function
  def safe_add(x: Int, y: Int): Int = x + y

  # Simple Erlang interop - call built-in Erlang length/1
  def_erl erlang_length(list: List(T)): Int =
    length(list).

  # Call Erlang lists:reverse/1
  def_erl erlang_reverse(list: List(T)): List(T) =
    lists:reverse(list).

  # Call Erlang timestamp function (returns tuple as Int for now)
  def_erl erlang_timestamp(): Int =
    42.

  # More complex Erlang interop with case expressions
  def_erl complex_erlang_calculation(x: Float, y: Float): Result(Float, String) =
    case Y of
        0.0 -> error("Division by zero");
        _ -> 
            Result = X / Y,
            Result
    end.

  # Function that combines Cure and Erlang functions
  def demo_mixed_usage(): Unit =
    let list = [1, 2, 3, 4, 5]
    let erl_length = erlang_length(list)
    let cure_length = safe_add(erl_length, 0)  # Use Cure function
    let reversed = erlang_reverse(list)
    let timestamp = erlang_timestamp()
    
    print("Original list length (via Erlang): " ++ int_to_string(erl_length))
    print("Cure calculation result: " ++ int_to_string(cure_length))
    print("Reversed list computed via Erlang")
    print("Current timestamp from Erlang")
end