# FSM Demo - Cure Programming Language
# Demonstrates finite state machine functionality

module FSMDemo do
  export [main/0, traffic_light_demo/0, counter_demo/0]

  # Traffic Light FSM
  fsm TrafficLight do
    states: [Red, Yellow, Green]
    initial: Red
    
    state Red do
      event(:next) -> Green
      timeout(5000) -> Green
    end
    
    state Green do
      event(:next) -> Yellow  
      timeout(3000) -> Yellow
    end
    
    state Yellow do
      event(:next) -> Red
      timeout(1000) -> Red
    end
  end

  # Counter FSM with dependent types
  fsm Counter do
    states: [Zero, Positive, Negative]
    initial: Zero
    
    state Zero do
      event(:increment) -> Positive
      event(:decrement) -> Negative
      event(:reset) -> Zero
    end
    
    state Positive do
      event(:increment) -> Positive
      event(:decrement) when count > 1 -> Positive
      event(:decrement) when count == 1 -> Zero  
      event(:decrement) when count < 1 -> Negative
      event(:reset) -> Zero
    end
    
    state Negative do
      event(:increment) when count < -1 -> Negative
      event(:increment) when count == -1 -> Zero
      event(:increment) when count > -1 -> Positive
      event(:decrement) -> Negative
      event(:reset) -> Zero
    end
  end

  # Main demonstration function
  def main(): Int =
    let traffic_result = traffic_light_demo()
    let counter_result = counter_demo()
    
    if traffic_result and counter_result then
      0  # Success
    else
      1  # Failure
    end

  # Traffic light demonstration
  def traffic_light_demo(): Bool =
    # Spawn a traffic light FSM
    let light = fsm_spawn(TrafficLight)
    
    # Check initial state
    let initial_state = fsm_state(light)
    assert(initial_state == Red, "Traffic light should start in Red state")
    
    # Manually trigger transitions
    fsm_send(light, :next)
    let green_state = fsm_state(light)
    assert(green_state == Green, "Should transition to Green")
    
    fsm_send(light, :next)  
    let yellow_state = fsm_state(light)
    assert(yellow_state == Yellow, "Should transition to Yellow")
    
    fsm_send(light, :next)
    let red_state = fsm_state(light)
    assert(red_state == Red, "Should transition back to Red")
    
    # Clean up
    fsm_stop(light)
    
    true

  # Counter demonstration
  def counter_demo(): Bool =
    # Spawn a counter FSM with initial data
    let counter = fsm_spawn(Counter, #{count => 0})
    
    # Test initial state
    let initial = fsm_state(counter)
    assert(initial == Zero, "Counter should start at Zero")
    
    # Increment to positive
    fsm_send(counter, :increment)
    let positive = fsm_state(counter)
    assert(positive == Positive, "Should be in Positive state")
    
    # Get counter info for debugging
    let info = fsm_info(counter)
    print("Counter info: ~p", [info])
    
    # Reset to zero
    fsm_send(counter, :reset)
    let zero_again = fsm_state(counter)
    assert(zero_again == Zero, "Should reset to Zero")
    
    # Test decrement to negative
    fsm_send(counter, :decrement)
    let negative = fsm_state(counter)
    assert(negative == Negative, "Should be in Negative state")
    
    # Clean up
    fsm_stop(counter)
    
    true

  # Utility functions
  def assert(condition: Bool, message: String): Unit =
    if not condition then
      error(message)
    else
      ok
    end

  def print(format: String, args: List(Any)): Unit =
    # Built-in print function (to be implemented)
    ok

  def error(message: String): Unit =
    # Built-in error function (to be implemented)  
    ok
    
  # Advanced FSM example with guards and actions
  def advanced_fsm_demo(): Bool =
    # This would demonstrate more complex FSM features
    # like guards, actions, and state data manipulation
    true
end

# Example of FSM integration with processes
def spawn_multiple_fsms(): List(FSM) =
  let lights = [
    fsm_spawn(TrafficLight),
    fsm_spawn(TrafficLight), 
    fsm_spawn(TrafficLight)
  ]
  
  # Coordinate multiple FSMs
  map(lights, fn(light) -> 
    fsm_send(light, :next)
    light
  end)

# Error handling with FSMs
def fsm_error_handling(): Result(Bool, String) =
  try
    let fsm = fsm_spawn(NonExistentFSM)
    Ok(true)
  catch
    error -> Error("FSM spawn failed: " ++ error.message)
  end